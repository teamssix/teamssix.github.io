<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Teams Six</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.teamssix.com/"/>
  <updated>2019-11-27T12:43:53.640Z</updated>
  <id>https://www.teamssix.com/</id>
  
  <author>
    <name>Teams Six</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【漏洞笔记】Robots.txt站点文件</title>
    <link href="https://www.teamssix.com/year/191127-201447.html"/>
    <id>https://www.teamssix.com/year/191127-201447.html</id>
    <published>2019-11-27T12:14:47.000Z</published>
    <updated>2019-11-27T12:43:53.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：Robots.txt站点文件</p><p>风险等级：低</p><p>问题类型：服务器设置问题</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>Robots.txt文件中声明了不想被搜索引擎访问的部分或者指定搜索引擎收录指定的部分。</p><a id="more"></a><p>此信息可以帮助攻击者得到网站部分文件名称、目录名称，了解网站结构。</p><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>攻击者可通过发现robots.txt文件，收集网站的敏感目录或文件，从而有针对性的进行利用。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>1、将敏感的文件和目录放在一个排除搜索引擎访问的目录中</p><p>2、robots.txt内容可设为Disallow: /，禁止搜索引擎访问网站的任何内容</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：Robots.txt站点文件&lt;/p&gt;
&lt;p&gt;风险等级：低&lt;/p&gt;
&lt;p&gt;问题类型：服务器设置问题&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;Robots.txt文件中声明了不想被搜索引擎访问的部分或者指定搜索引擎收录指定的部分。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Robots.txt" scheme="https://www.teamssix.com/tags/Robots-txt/"/>
    
      <category term="服务器设置问题" scheme="https://www.teamssix.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞笔记】Host头攻击</title>
    <link href="https://www.teamssix.com/year/191127-201443.html"/>
    <id>https://www.teamssix.com/year/191127-201443.html</id>
    <published>2019-11-27T12:14:43.000Z</published>
    <updated>2019-11-27T12:43:48.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：Host头攻击</p><p>风险等级：低</p><p>问题类型：管理员设置问题</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>Host首部字段是HTTP/1.1新增的，旨在告诉服务器，客户端请求的主机名和端口号，主要用来实现虚拟主机技术。</p><a id="more"></a><p>运用虚拟主机技术，单个主机可以运行多个站点。</p><p>例如：hacker和usagidesign两个站点都运行在同一服务器A上，不管我们请求哪个域名，最终都会被解析成服务器A的IP地址，这个时候服务器就不知道该将请求交给哪个站点处理，因此需要Host字段指定请求的主机名。</p><p>我们访问hacker域名，经DNS解析，变成了服务器A的IP，请求传达到服务器A，A接收到请求后，发现请求报文中的Host字段值为hacker，进而将请求交给hacker站点处理。</p><p>这个时候，问题就出现了。为了方便获取网站域名，开发人员一般依赖于请求包中的Host首部字段。例如，在php里用_SERVER[“HTTP_HOST”]，但是这个Host字段值是不可信赖的(可通过HTTP代理工具篡改)。</p><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>如果应用程序没有对Host字段值进行处理，就有可能造成恶意代码的传入。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>对Host字段进行检测</p><p>Nginx，修改ngnix.conf文件，在server中指定一个server_name名单，并添加检测。</p><p>Apache，修改httpd.conf文件，指定ServerName，并开启UseCanonicalName选项。</p><p>Tomcat，修改server.xml文件，配置Host的name属性。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<br><a href="https://www.jianshu.com/p/690acbf9f321" target="_blank" rel="noopener">https://www.jianshu.com/p/690acbf9f321</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：Host头攻击&lt;/p&gt;
&lt;p&gt;风险等级：低&lt;/p&gt;
&lt;p&gt;问题类型：管理员设置问题&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;Host首部字段是HTTP/1.1新增的，旨在告诉服务器，客户端请求的主机名和端口号，主要用来实现虚拟主机技术。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="管理员设置问题" scheme="https://www.teamssix.com/tags/%E7%AE%A1%E7%90%86%E5%91%98%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    
      <category term="Host头" scheme="https://www.teamssix.com/tags/Host%E5%A4%B4/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】常见的HTTP方法</title>
    <link href="https://www.teamssix.com/year/191127-201438.html"/>
    <id>https://www.teamssix.com/year/191127-201438.html</id>
    <published>2019-11-27T12:14:38.000Z</published>
    <updated>2019-11-27T12:43:42.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>根据HTTP标准，HTTP请求可以使用多种请求方法。</p><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT方法。</p><a id="more"></a><h1 id="0x01-GET"><a href="#0x01-GET" class="headerlink" title="0x01 GET"></a>0x01 GET</h1><p>GET方法用于请求指定的页面信息，并返回实体主体。</p><h1 id="0x02-HEAD"><a href="#0x02-HEAD" class="headerlink" title="0x02 HEAD"></a>0x02 HEAD</h1><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体。</p><h1 id="0x03-POST"><a href="#0x03-POST" class="headerlink" title="0x03 POST"></a>0x03 POST</h1><p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。</p><p>数据被包含在请求体中，POST请求可能会导致新的资源建立或已有资源的修改。</p><h1 id="0x04-PUT"><a href="#0x04-PUT" class="headerlink" title="0x04 PUT"></a>0x04 PUT</h1><p>PUT方法用请求有效载荷替换目标资源的所有当前表示。</p><h1 id="0x05-DELETE"><a href="#0x05-DELETE" class="headerlink" title="0x05 DELETE"></a>0x05 DELETE</h1><p>请求服务器删除指定的页面。</p><h1 id="0x06-CONNECT"><a href="#0x06-CONNECT" class="headerlink" title="0x06 CONNECT"></a>0x06 CONNECT</h1><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><h1 id="0x07-OPTIONS"><a href="#0x07-OPTIONS" class="headerlink" title="0x07 OPTIONS"></a>0x07 OPTIONS</h1><p>允许客户端查看服务器的性能。</p><h1 id="0x08-TRACE"><a href="#0x08-TRACE" class="headerlink" title="0x08 TRACE"></a>0x08 TRACE</h1><p>回显服务器收到的请求，主要用于测试或诊断。</p><h1 id="0x09-PATCH"><a href="#0x09-PATCH" class="headerlink" title="0x09 PATCH"></a>0x09 PATCH</h1><p>是对PUT方法的补充，用来对已知资源进行局部更新。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<br><a href="https://www.runoob.com/http/http-methods.html" target="_blank" rel="noopener">https://www.runoob.com/http/http-methods.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;根据HTTP标准，HTTP请求可以使用多种请求方法。&lt;/p&gt;
&lt;p&gt;HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。&lt;/p&gt;
&lt;p&gt;HTTP1.1新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT方法。&lt;/p&gt;
    
    </summary>
    
      <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
      <category term="HTTP方法" scheme="https://www.teamssix.com/tags/HTTP%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞笔记】ASP.NET允许文件调试</title>
    <link href="https://www.teamssix.com/year/191126-215809.html"/>
    <id>https://www.teamssix.com/year/191126-215809.html</id>
    <published>2019-11-26T13:58:09.000Z</published>
    <updated>2019-11-26T14:21:57.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：ASP.NET允许文件调试</p><p>风险等级：低</p><p>问题类型：管理员设置问题</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>发送DEBUG动作的请求，如果服务器返回内容为OK，那么服务器就开启了调试功能，可能会导致有关Web应用程序的敏感信息泄露，例如密码、路径等。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>可能会泄露密码、路径等敏感信息。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>编辑Web.config文件，设置<code>&amp;lt;compilation debug=&quot;false&quot;/&amp;gt;</code></p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：ASP.NET允许文件调试&lt;/p&gt;
&lt;p&gt;风险等级：低&lt;/p&gt;
&lt;p&gt;问题类型：管理员设置问题&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;发送DEBUG动作的请求，如果服务器返回内容为OK，那么服务器就开启了调试功能，可能会导致有关Web应用程序的敏感信息泄露，例如密码、路径等。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ASP.NET" scheme="https://www.teamssix.com/tags/ASP-NET/"/>
    
      <category term="管理员设置问题" scheme="https://www.teamssix.com/tags/%E7%AE%A1%E7%90%86%E5%91%98%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞笔记】IIS短文件名泄露</title>
    <link href="https://www.teamssix.com/year/191126-215804.html"/>
    <id>https://www.teamssix.com/year/191126-215804.html</id>
    <published>2019-11-26T13:58:04.000Z</published>
    <updated>2019-11-26T14:15:42.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：IIS短文件名泄露</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>此漏洞实际是由HTTP请求中旧DOS 8.3名称约定（SFN）的代字符（〜）波浪号引起的。</p><a id="more"></a><p>为了兼容16位MS-DOS程序，Windows为文件名较长的文件（和文件夹）生成了对应的windows 8.3 短文件名。</p><p>Microsoft IIS 波浪号造成的信息泄露是世界网络范围内最常见的中等风险漏洞。这个问题至少从1990年开始就已经存在，但是已经证明难以发现，难以解决或容易被完全忽略。</p><p><strong>受影响的版本：</strong><br>IIS 1.0，Windows NT 3.51<br>IIS 3.0，Windows NT 4.0 Service Pack 2<br>IIS 4.0，Windows NT 4.0选项包<br>IIS 5.0，Windows 2000<br>IIS 5.1，Windows XP Professional和Windows XP Media Center Edition<br>IIS 6.0，Windows Server 2003和Windows XP Professional x64 Edition<br>IIS 7.0，Windows Server 2008和Windows Vista<br>IIS 7.5，Windows 7（远程启用<customerrors>或没有web.config）<br>IIS 7.5，Windows 2008（经典管道模式）<br>注意：IIS使用.Net Framework 4时不受影响</customerrors></p><p><strong>漏洞的局限性：</strong><br>1) 只能猜解前六位，以及扩展名的前3位。<br>2) 名称较短的文件是没有相应的短文件名的。<br>3）需要IIS和.net两个条件都满足。</p><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p><strong>主要危害：利用“~”字符猜解暴露短文件/文件夹名</strong></p><p>由于短文件名的长度固定（xxxxxx~xxxx），因此黑客可直接对短文件名进行暴力破解 ，从而访问对应的文件。</p><p>举个例子，有一个数据库备份文件 backup_<a href="http://www.abc.com_20150101.sql" target="_blank" rel="noopener">www.abc.com_20150101.sql</a> ，它对应的短文件名是 backup<del>1.sql 。因此黑客只要暴力破解出backup</del>1.sql即可下载该文件，而无需破解完整的文件名。</p><p>*<em>次要危害：.Net Framework的拒绝服务攻击 *</em></p><p>攻击者如果在文件夹名称中发送一个不合法的.Net文件请求，.NeFramework将递归搜索所有的根目录，消耗网站资源进而导致DOS问题。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>1、CMD关闭NTFS 8.3文件格式的支持</p><p>2、修改注册表禁用短文件名功能</p><p>3、关闭Web服务扩展- ASP.NET</p><p>4、升级netFramework至4.0以上版本</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<br><a href="https://www.freebuf.com/articles/web/172561.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/172561.html</a><br><a href="https://segmentfault.com/a/1190000006225568" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006225568</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：IIS短文件名泄露&lt;/p&gt;
&lt;p&gt;风险等级：低&lt;/p&gt;
&lt;p&gt;问题类型：信息泄露&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;此漏洞实际是由HTTP请求中旧DOS 8.3名称约定（SFN）的代字符（〜）波浪号引起的。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IIS" scheme="https://www.teamssix.com/tags/IIS/"/>
    
      <category term="信息泄露" scheme="https://www.teamssix.com/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>Pigat：一款被动信息收集聚合工具</title>
    <link href="https://www.teamssix.com/year/191126-215759.html"/>
    <id>https://www.teamssix.com/year/191126-215759.html</id>
    <published>2019-11-26T13:57:59.000Z</published>
    <updated>2019-11-26T14:49:26.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Pigat即Passive Intelligence Gathering Aggregation Tool，翻译过来就是被动信息收集聚合工具，既然叫聚合工具，也就是说该工具将多款被动信息收集工具结合在了一起，进而提高了平时信息收集的效率。</p><p>早在一个月前便萌生了开发这个工具的想法，但是一直没有时间，正好最近有时间了，就简单写一下。</p><a id="more"></a><p>因为我没有太多的开发经验，所以这款工具难免存在需要改进的地方，因此希望各位大佬能够多多反馈这款工具存在的问题，一起完善这个工具。</p><h1 id="0x01-工具原理及功能概述"><a href="#0x01-工具原理及功能概述" class="headerlink" title="0x01 工具原理及功能概述"></a>0x01 工具原理及功能概述</h1><p>这款工具的原理很简单，用户输入目标url，再利用爬虫获取相关被动信息收集网站关于该url的信息，最后回显出来。</p><p>目前该工具具备8个功能，原该工具具备7个功能，分别为收集目标的资产信息、CMS信息、DNS信息、备案信息、IP地址、子域名信息、whois信息，现加入第8个功能：如果在程序中两次IP查询目标URL的结果一致，那么查询该IP的端口，即端口查询功能。</p><h1 id="0x02-工具简单上手使用"><a href="#0x02-工具简单上手使用" class="headerlink" title="0x02 工具简单上手使用"></a>0x02 工具简单上手使用</h1><h2 id="1、查看帮助信息"><a href="#1、查看帮助信息" class="headerlink" title="1、查看帮助信息"></a>1、查看帮助信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># python pigat.py -h</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/pigat1.png" alt></p><h2 id="2、指定url进行信息获取"><a href="#2、指定url进行信息获取" class="headerlink" title="2、指定url进行信息获取"></a>2、指定url进行信息获取</h2><p>如果只指定url这一个参数，没有指定其他参数，则默认获取该url的所有信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># python pigat.py -u teamssix.com</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/pigat2.png" alt></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/pigat3.png" alt></p><h2 id="3、指定url进行单项信息获取"><a href="#3、指定url进行单项信息获取" class="headerlink" title="3、指定url进行单项信息获取"></a>3、指定url进行单项信息获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># python pigat.py -u baidu.com --assert</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/pigat4.png" alt></p><h2 id="4、指定url进行多项信息获取"><a href="#4、指定url进行多项信息获取" class="headerlink" title="4、指定url进行多项信息获取"></a>4、指定url进行多项信息获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># python pigat.py -u teamssix.com --ip --cms</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/pigat5.png" alt></p><h1 id="0x03-工具获取"><a href="#0x03-工具获取" class="headerlink" title="0x03 工具获取"></a>0x03 工具获取</h1><p>关于此工具的下载地址可在我的个人公众号（TeamsSix）回复”pigat”获取。</p><h1 id="0x04-声明"><a href="#0x04-声明" class="headerlink" title="0x04 声明"></a>0x04 声明</h1><p>1、本文在FreeBuf首发，原文地址在文章尾部</p><p>2、由于我的个人疏忽，导致在FreeBuf文中获取工具的方式存在错误的地方，正确的获取方式应是回复”pigat”，而不是”pigta”，这就导致不少人及时回复了关键词也没有获取到工具地址，在这里表示深刻歉意，现在公众号后台规则已经更新，上述两个关键词均可以获取到工具地址。</p><blockquote><p>原文地址：<a href="https://www.freebuf.com/sectool/219681.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/219681.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;Pigat即Passive Intelligence Gathering Aggregation Tool，翻译过来就是被动信息收集聚合工具，既然叫聚合工具，也就是说该工具将多款被动信息收集工具结合在了一起，进而提高了平时信息收集的效率。&lt;/p&gt;
&lt;p&gt;早在一个月前便萌生了开发这个工具的想法，但是一直没有时间，正好最近有时间了，就简单写一下。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="https://www.teamssix.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="被动信息收集" scheme="https://www.teamssix.com/tags/%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
      <category term="pigat" scheme="https://www.teamssix.com/tags/pigat/"/>
    
      <category term="聚合工具" scheme="https://www.teamssix.com/tags/%E8%81%9A%E5%90%88%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞笔记】测试目录</title>
    <link href="https://www.teamssix.com/year/191125-195302.html"/>
    <id>https://www.teamssix.com/year/191125-195302.html</id>
    <published>2019-11-25T11:53:02.000Z</published>
    <updated>2019-11-25T11:56:10.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：测试目录</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>Web应用程序在开发过程中，程序员为了测试代码功能，在Web目录下新建测试目录，存放测试代码，可能包含敏感信息。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>攻击者读取测试目录信息，以便进一步攻击目标站点。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>删除或者限制访问测试目录。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：测试目录&lt;/p&gt;
&lt;p&gt;风险等级：低&lt;/p&gt;
&lt;p&gt;问题类型：信息泄露&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;Web应用程序在开发过程中，程序员为了测试代码功能，在Web目录下新建测试目录，存放测试代码，可能包含敏感信息。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="信息泄露" scheme="https://www.teamssix.com/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
      <category term="测试目录" scheme="https://www.teamssix.com/tags/%E6%B5%8B%E8%AF%95%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞笔记】测试文件</title>
    <link href="https://www.teamssix.com/year/191125-195256.html"/>
    <id>https://www.teamssix.com/year/191125-195256.html</id>
    <published>2019-11-25T11:52:56.000Z</published>
    <updated>2019-11-25T11:56:14.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：测试文件</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>Web应用程序在开发过程中，程序员为了测试代码功能，在Web目录下新建测试目录，存放测试代码，可能包含敏感信息。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>攻击者读取测试文件信息，可能进一步攻击目标站点。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>删除或者限制访问测试文件。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：测试文件&lt;/p&gt;
&lt;p&gt;风险等级：低&lt;/p&gt;
&lt;p&gt;问题类型：信息泄露&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;Web应用程序在开发过程中，程序员为了测试代码功能，在Web目录下新建测试目录，存放测试代码，可能包含敏感信息。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="信息泄露" scheme="https://www.teamssix.com/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
      <category term="测试文件" scheme="https://www.teamssix.com/tags/%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞笔记】敏感文件</title>
    <link href="https://www.teamssix.com/year/191123-174558.html"/>
    <id>https://www.teamssix.com/year/191123-174558.html</id>
    <published>2019-11-23T09:45:58.000Z</published>
    <updated>2019-11-23T09:55:31.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：敏感文件</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>由于网站运维人员疏忽，存放敏感信息的文件被泄露或由于网站运行出错导致敏感信息泄露。</p><p>Web应用程序显露了某些文件名称，此信息可以帮助攻击者对站点进一步的攻击。例如，知道文件名称之后，攻击者便可能获得它的内容，也许还能猜出其它的文件名或目录名，并尝试访问它们。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>攻击者可直接下载用户的相关信息，包括网站的绝对路径、用户的登录名、密码、真实姓名、身份证号、电话号码、邮箱、QQ号等。</p><p>攻击者通过构造特殊URL地址，触发系统web应用程序报错，在回显内容中，获取网站敏感信息。</p><p>攻击者利用泄漏的敏感信息，获取网站服务器web路径，为进一步攻击提供帮助。</p><p>攻击者可能通过文件名，也许还能猜出其它的文件名或目录名，并尝试访问它们。这些可能包含敏感信息。攻击者通过搜集信息，以便进一步攻击目标站点。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>对网站错误信息进行统一返回，模糊化处理；对存放敏感信息的文件进行加密并妥善储存，避免泄漏敏感信息。</p><p>修改复杂的文件名称；从站点中除去不需要的文件。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<a href="https://ninjia.gitbook.io/secskill/web/info" target="_blank" rel="noopener">https://ninjia.gitbook.io/secskill/web/info</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：敏感文件&lt;/p&gt;
&lt;p&gt;风险等级：低&lt;/p&gt;
&lt;p&gt;问题类型：信息泄露&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;由于网站运维人员疏忽，存放敏感信息的文件被泄露或由于网站运行出错导致敏感信息泄露。&lt;/p&gt;
&lt;p&gt;Web应用程序显露了某些文件名称，此信息可以帮助攻击者对站点进一步的攻击。例如，知道文件名称之后，攻击者便可能获得它的内容，也许还能猜出其它的文件名或目录名，并尝试访问它们。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="信息泄露" scheme="https://www.teamssix.com/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
      <category term="敏感文件" scheme="https://www.teamssix.com/tags/%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞笔记】敏感目录</title>
    <link href="https://www.teamssix.com/year/191123-174550.html"/>
    <id>https://www.teamssix.com/year/191123-174550.html</id>
    <published>2019-11-23T09:45:50.000Z</published>
    <updated>2019-11-23T09:55:35.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：敏感目录</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>目标服务器上存在敏感名称的目录。如/admin、/conf、/backup、/db等这些目录中有可能包含了大量的敏感文件和脚本，如服务器的配置信息或管理脚本等。</p><p>Web应用程序显露了某些目录名称，此信息可以帮助攻击者对站点进一步的攻击。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>如果这些名称敏感的目录中包含了危险的功能或信息，恶意攻击者有可能利用这些脚本或信息直接获取目标服务器的控制权或基于这些信息实施进一步的攻击。</p><p>知道目录之后，攻击者便可能获得目录下边的文件名，也许还能猜出其它的文件名或目录名，并尝试访问它们。这些可能包含敏感信息。攻击者通过搜集信息，以便进一步攻击目标站点。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>如果这些目录中包含了敏感内容，可以使用非常规的目录名称，如果能删除也可以删除或者正确设置权限，禁止用户访问。</p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<a href="https://www.izhangheng.com/china-top10-web-site-vulnerability-ranking-and-solutions" target="_blank" rel="noopener">https://www.izhangheng.com/china-top10-web-site-vulnerability-ranking-and-solutions</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：敏感目录&lt;/p&gt;
&lt;p&gt;风险等级：低&lt;/p&gt;
&lt;p&gt;问题类型：信息泄露&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;目标服务器上存在敏感名称的目录。如/admin、/conf、/backup、/db等这些目录中有可能包含了大量的敏感文件和脚本，如服务器的配置信息或管理脚本等。&lt;/p&gt;
&lt;p&gt;Web应用程序显露了某些目录名称，此信息可以帮助攻击者对站点进一步的攻击。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="信息泄露" scheme="https://www.teamssix.com/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
      <category term="敏感目录" scheme="https://www.teamssix.com/tags/%E6%95%8F%E6%84%9F%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞笔记】基于HTTP连接的登录请求</title>
    <link href="https://www.teamssix.com/year/191121-220054.html"/>
    <id>https://www.teamssix.com/year/191121-220054.html</id>
    <published>2019-11-21T14:00:54.000Z</published>
    <updated>2019-11-21T14:02:47.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：基于HTTP连接的登录请求</p><p>风险等级：低</p><p>问题类型：信息泄露</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>应用程序使用HTTP连接接受客户端的登录请求，如果登录请求数据没有加密处理，有可能被攻击者嗅探到客户提交的请求数据，请求数据中一般包含用户名密码。</p><a id="more"></a><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>可能被同一个局域网内的攻击者嗅探到用户输入的登录数据，如账号和密码。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>在提交登录请求数据前加密请求数据或使用HTTPS连接发送登录请求数据。</p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<a href="https://blog.csdn.net/CHS007chs/article/details/52524322" target="_blank" rel="noopener">https://blog.csdn.net/CHS007chs/article/details/52524322</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：基于HTTP连接的登录请求&lt;/p&gt;
&lt;p&gt;风险等级：低&lt;/p&gt;
&lt;p&gt;问题类型：信息泄露&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;应用程序使用HTTP连接接受客户端的登录请求，如果登录请求数据没有加密处理，有可能被攻击者嗅探到客户提交的请求数据，请求数据中一般包含用户名密码。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="信息泄露" scheme="https://www.teamssix.com/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
      <category term="HTTP" scheme="https://www.teamssix.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞笔记】jQuery跨站脚本</title>
    <link href="https://www.teamssix.com/year/191120-214129.html"/>
    <id>https://www.teamssix.com/year/191120-214129.html</id>
    <published>2019-11-20T13:41:29.000Z</published>
    <updated>2019-11-20T14:03:21.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：jQuery跨站脚本</p><p>风险等级：低危</p><p>问题类型：使用已知漏洞的组件</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>关于jQuery：jQuery是美国程序员John Resig所研发的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。</p><a id="more"></a><p>漏洞原理：jQuery中过滤用户输入数据所使用的正则表达式存在缺陷，可能导致 location.hash跨站漏洞</p><p>影响版本：</p><p>jquery-1.7.1~1.8.3</p><p>jquery-1.6.min.js，jquery-1.6.1.min.js，jquery-1.6.2.min.js</p><p>jquery-1.2~1.5</p><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>jQuery 1.4.2版本中，远程攻击者可利用该漏洞向页面中注入任意的HTML。</p><p>jQuery 1.6.3之前版本中，当使用location.hash选择元素时，通过特制的标签，远程攻击者利用该漏洞注入任意web脚本或HTML。</p><p>jQuery 3.0.0之前版本中，攻击者可利用该漏洞执行客户端代码。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><p>目前厂商已发布升级补丁以修复漏洞，详情请关注厂商主页：<a href="https://jquery.com/" target="_blank" rel="noopener">https://jquery.com/</a></p><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix<br>参考文章：<br><a href="http://www.word666.com/wangluo/121052.html" target="_blank" rel="noopener">http://www.word666.com/wangluo/121052.html</a><br><a href="https://blog.csdn.net/qq_36119192/article/details/89811603" target="_blank" rel="noopener">https://blog.csdn.net/qq_36119192/article/details/89811603</a><br><a href="https://www.cnblogs.com/security4399/archive/2013/03/13/2958502.html" target="_blank" rel="noopener">https://www.cnblogs.com/security4399/archive/2013/03/13/2958502.html</a><br><a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201801-582" target="_blank" rel="noopener">http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201801-582</a><br><a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201801-798" target="_blank" rel="noopener">http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201801-798</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：jQuery跨站脚本&lt;/p&gt;
&lt;p&gt;风险等级：低危&lt;/p&gt;
&lt;p&gt;问题类型：使用已知漏洞的组件&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;关于jQuery：jQuery是美国程序员John Resig所研发的一套开源、跨浏览器的JavaScript库。该库简化了HTML与JavaScript之间的操作，并具有模块化、插件扩展等特点。&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="XSS" scheme="https://www.teamssix.com/tags/XSS/"/>
    
      <category term="jQuery" scheme="https://www.teamssix.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>【漏洞笔记】X-Frame-Options Header未配置</title>
    <link href="https://www.teamssix.com/year/191119-144643.html"/>
    <id>https://www.teamssix.com/year/191119-144643.html</id>
    <published>2019-11-19T06:46:43.000Z</published>
    <updated>2019-11-20T13:58:02.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>漏洞名称：X-Frame-Options Header未配置</p><p>风险等级：低危</p><p>问题类型：管理员设置问题</p><h1 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h1><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在&lt;忽略frame&gt;,&lt;忽略iframe&gt;,&lt;忽略embed&gt;或者&lt;忽略object&gt;中展现的标记。</p><p>网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，从而避免点击劫持（clickjacking）攻击。</p><p>X-Frame-Options有三个值：</p><a id="more"></a><h3 id="deny"><a href="#deny" class="headerlink" title="deny"></a>deny</h3><p>表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</p><h3 id="sameorigin"><a href="#sameorigin" class="headerlink" title="sameorigin"></a>sameorigin</h3><p>表示该页面可以在相同域名页面的 frame 中展示。</p><h3 id="allow-from-uri"><a href="#allow-from-uri" class="headerlink" title="allow-from uri"></a>allow-from uri</h3><p>表示该页面可以在指定来源的 frame 中展示。</p><p>换一句话说，如果设置为DENY，不光在别人的网站frame嵌入时会无法加载，在同域名页面中同样会无法加载。</p><p>另一方面，如果设置为SAMEORIGIN，那么页面就可以在同域名页面的frame中嵌套。正常情况下我们通常使用SAMEORIGIN参数。</p><h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><p>攻击者可以使用一个透明的、不可见的iframe，覆盖在目标网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击iframe页面的一些功能性按钮上，导致被劫持。</p><p>也就是说网站内容可能被其他站点引用，可能遭受到点击劫持攻击。</p><h1 id="0x03-修复建议"><a href="#0x03-修复建议" class="headerlink" title="0x03 修复建议"></a>0x03 修复建议</h1><h3 id="配置-Apache"><a href="#配置-Apache" class="headerlink" title="配置 Apache"></a>配置 Apache</h3><p>配置 Apache 在所有页面上发送 X-Frame-Options 响应头，需要把下面这行添加到 ‘site’ 的配置中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header always set X-Frame-Options &quot;sameorigin&quot;</span><br></pre></td></tr></table></figure><p>要将 Apache 的配置 X-Frame-Options 设置成 deny , 按如下配置去设置你的站点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header set X-Frame-Options &quot;deny&quot;</span><br></pre></td></tr></table></figure><p>要将 Apache 的配置 X-Frame-Options 设置成 allow-from，在配置里添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header set X-Frame-Options &quot;allow-from https://example.com/&quot;</span><br></pre></td></tr></table></figure><h3 id="配置-nginx配置"><a href="#配置-nginx配置" class="headerlink" title="配置 nginx配置"></a>配置 nginx配置</h3><p>nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header X-Frame-Options sameorigin always;</span><br></pre></td></tr></table></figure><h3 id="配置-IIS配置"><a href="#配置-IIS配置" class="headerlink" title="配置 IIS配置"></a>配置 IIS配置</h3><p>IIS 发送 X-Frame-Options 响应头，添加下面的配置到 Web.config 文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;system.webServer&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;httpProtocol&gt;</span><br><span class="line">    &lt;customHeaders&gt;</span><br><span class="line">      &lt;add name=&quot;X-Frame-Options&quot; value=&quot;sameorigin&quot; /&gt;</span><br><span class="line">    &lt;/customHeaders&gt;</span><br><span class="line">  &lt;/httpProtocol&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/system.webServer&gt;</span><br></pre></td></tr></table></figure><h3 id="配置-HAProxy"><a href="#配置-HAProxy" class="headerlink" title="配置 HAProxy"></a>配置 HAProxy</h3><p>配置 HAProxy 发送 X-Frame-Options 头，添加这些到你的前端、监听 listen，或者后端的配置里面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rspadd X-Frame-Options:\ sameorigin</span><br></pre></td></tr></table></figure><p>或者，在更加新的版本中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-response set-header X-Frame-Options sameorigin</span><br></pre></td></tr></table></figure><h3 id="配置-Express"><a href="#配置-Express" class="headerlink" title="配置 Express"></a>配置 Express</h3><p>要配置 Express 可以发送 X-Frame-Options header，你可以用借助了 frameguard 来设置头部的 helmet。在你的服务器配置里面添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const helmet = require(&apos;helmet&apos;);</span><br><span class="line">const app = express();</span><br><span class="line">app.use(helmet.frameguard(&#123; action: &quot;sameorigin&quot; &#125;));</span><br></pre></td></tr></table></figure><p>或者，你也可以直接用 frameguard：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const frameguard = require(&apos;frameguard&apos;)</span><br><span class="line">app.use(frameguard(&#123; action: &apos;sameorigin&apos; &#125;))</span><br></pre></td></tr></table></figure><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><blockquote><p>参考文章：<br><a href="https://blog.whsir.com/post-3919.html" target="_blank" rel="noopener">https://blog.whsir.com/post-3919.html</a><br><a href="https://blog.csdn.net/qq_25934401/article/details/81384876" target="_blank" rel="noopener">https://blog.csdn.net/qq_25934401/article/details/81384876</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;漏洞名称：X-Frame-Options Header未配置&lt;/p&gt;
&lt;p&gt;风险等级：低危&lt;/p&gt;
&lt;p&gt;问题类型：管理员设置问题&lt;/p&gt;
&lt;h1 id=&quot;0x01-漏洞描述&quot;&gt;&lt;a href=&quot;#0x01-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞描述&quot;&gt;&lt;/a&gt;0x01 漏洞描述&lt;/h1&gt;&lt;p&gt;X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在&amp;lt;忽略frame&amp;gt;,&amp;lt;忽略iframe&amp;gt;,&amp;lt;忽略embed&amp;gt;或者&amp;lt;忽略object&amp;gt;中展现的标记。&lt;/p&gt;
&lt;p&gt;网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，从而避免点击劫持（clickjacking）攻击。&lt;/p&gt;
&lt;p&gt;X-Frame-Options有三个值：&lt;/p&gt;
    
    </summary>
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/categories/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="漏洞笔记" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"/>
    
      <category term="X-Frame-Options" scheme="https://www.teamssix.com/tags/X-Frame-Options/"/>
    
  </entry>
  
  <entry>
    <title>【Python Threading 学习笔记】6、锁lock</title>
    <link href="https://www.teamssix.com/year/191105-121011.html"/>
    <id>https://www.teamssix.com/year/191105-121011.html</id>
    <published>2019-11-05T04:10:11.000Z</published>
    <updated>2019-11-05T04:24:19.696Z</updated>
    
    <content type="html"><![CDATA[<p>往期内容：</p><p><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p><a href="https://www.teamssix.com/year/191101-112015.html">2、添加线程</a></p><p><a href="https://www.teamssix.com/year/191102-102624.html">3、join功能</a></p><p><a href="https://www.teamssix.com/year/191103-092239.html">4、Queue功能</a></p><p><a href="https://www.teamssix.com/year/191104-101112.html">5、不一定有效率GIL</a></p><h1 id="0x00-关于线程锁lock"><a href="#0x00-关于线程锁lock" class="headerlink" title="0x00 关于线程锁lock"></a>0x00 关于线程锁lock</h1><p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p><p>而使用lock就可以在不同线程使用同一共享内存时，能够确保线程之间互不影响。</p><a id="more"></a><h1 id="0x01-不使用lock锁的情况"><a href="#0x01-不使用lock锁的情况" class="headerlink" title="0x01 不使用lock锁的情况"></a>0x01 不使用lock锁的情况</h1><p>job1：全局变量A的值每次加1，循环7次并打印</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span> <span class="comment"># 全局变量A的值每次加1，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">1</span></span><br><span class="line">      print(<span class="string">'job1'</span>,A)</span><br></pre></td></tr></table></figure><p>job2：全局变量A的值每次加10，循环7次并打印</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span><span class="comment"># 全局变量A的值每次加10，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">10</span></span><br><span class="line">      print(<span class="string">'job2'</span>,A)</span><br></pre></td></tr></table></figure><p>main：定义两个线程并执行job1和job2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span> <span class="comment"># 定义两个线程并执行job1和job2</span></span><br><span class="line">   t1 = threading.Thread(target=job1)</span><br><span class="line">   t2 = threading.Thread(target=job2)</span><br><span class="line">   t1.start()</span><br><span class="line">   t2.start()</span><br><span class="line">   t1.join()</span><br><span class="line">   t2.join()</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span> <span class="comment"># 全局变量A的值每次加1，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">1</span></span><br><span class="line">      print(<span class="string">'job1'</span>,A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span><span class="comment"># 全局变量A的值每次加10，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">10</span></span><br><span class="line">      print(<span class="string">'job2'</span>,A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span> <span class="comment"># 定义两个线程并执行job1和job2</span></span><br><span class="line">   t1 = threading.Thread(target=job1)</span><br><span class="line">   t2 = threading.Thread(target=job2)</span><br><span class="line">   t1.start()</span><br><span class="line">   t2.start()</span><br><span class="line">   t1.join()</span><br><span class="line">   t2.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   A = <span class="number">0</span></span><br><span class="line">   main()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 6_lock.py</span></span><br><span class="line">job1 1</span><br><span class="line">job1 2</span><br><span class="line">job1 3</span><br><span class="line">job1 4</span><br><span class="line">job1 5job2 15</span><br><span class="line">job2 </span><br><span class="line">job1 2625</span><br><span class="line">job2</span><br><span class="line">job1 36 37</span><br><span class="line">job2 </span><br><span class="line">47</span><br><span class="line">job2 57</span><br><span class="line">job2 67</span><br><span class="line">job2 77</span><br></pre></td></tr></table></figure><p>可以看到不使用lock的时候，打印的结果很混乱。</p><h1 id="0x02-使用lock的情况"><a href="#0x02-使用lock的情况" class="headerlink" title="0x02 使用lock的情况"></a>0x02 使用lock的情况</h1><p>使用lock的方法是， 在每个线程执行运算修改共享内存之前，执行lock.acquire()将共享内存上锁， 确保当前线程执行时，内存不会被其他线程访问，执行运算完毕后，使用lock.release()将锁打开， 保证其他的线程可以使用该共享内存。</p><p>为job1和job2加锁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span> <span class="comment"># 全局变量A的值每次加1，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A,lock</span><br><span class="line">   lock.acquire() <span class="comment"># 上锁</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">1</span></span><br><span class="line">      print(<span class="string">'job1'</span>,A)</span><br><span class="line">   lock.release() <span class="comment"># 开锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span><span class="comment"># 全局变量A的值每次加10，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A,lock</span><br><span class="line">   lock.acquire() <span class="comment"># 上锁</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">10</span></span><br><span class="line">      print(<span class="string">'job2'</span>,A)</span><br><span class="line">   lock.release() <span class="comment"># 开锁</span></span><br></pre></td></tr></table></figure><p>在程序入口处定义一个lock</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   lock = threading.Lock()</span><br><span class="line">   A = <span class="number">0</span></span><br><span class="line">   main()</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span> <span class="comment"># 全局变量A的值每次加1，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A,lock</span><br><span class="line">   lock.acquire()</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">1</span></span><br><span class="line">      print(<span class="string">'job1'</span>,A)</span><br><span class="line">   lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job2</span><span class="params">()</span>:</span><span class="comment"># 全局变量A的值每次加10，循环7次并打印</span></span><br><span class="line">   <span class="keyword">global</span> A,lock</span><br><span class="line">   lock.acquire()</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">      A += <span class="number">10</span></span><br><span class="line">      print(<span class="string">'job2'</span>,A)</span><br><span class="line">   lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span> <span class="comment"># 定义两个线程并执行job1和job2</span></span><br><span class="line">   t1 = threading.Thread(target=job1)</span><br><span class="line">   t2 = threading.Thread(target=job2)</span><br><span class="line">   t1.start()</span><br><span class="line">   t2.start()</span><br><span class="line">   t1.join()</span><br><span class="line">   t2.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   lock = threading.Lock()</span><br><span class="line">   A = <span class="number">0</span></span><br><span class="line">   main()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 6_lock.py</span></span><br><span class="line">job1 1</span><br><span class="line">job1 2</span><br><span class="line">job1 3</span><br><span class="line">job1 4</span><br><span class="line">job1 5</span><br><span class="line">job1 6</span><br><span class="line">job1 7</span><br><span class="line">job2 17</span><br><span class="line">job2 27</span><br><span class="line">job2 37</span><br><span class="line">job2 47</span><br><span class="line">job2 57</span><br><span class="line">job2 67</span><br><span class="line">job2 77</span><br></pre></td></tr></table></figure><p>从运行结果来看，使用lock后，一个线程一个线程的执行完，两个线程之间互不影响。<br>至此，整个【Python Threading 学习笔记】系列更新完毕。</p><blockquote><p>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes" target="_blank" rel="noopener">https://github.com/teamssix/Python-Threading-study-notes</a><br>参考文章：<br>1、<a href="https://www.jianshu.com/p/05b6a6f6fdac" target="_blank" rel="noopener">https://www.jianshu.com/p/05b6a6f6fdac</a><br>2、<a href="https://morvanzhou.github.io/tutorials/python-basic/threading" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;往期内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/1901031-202253.html&quot;&gt;1、什么是多线程？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191101-112015.html&quot;&gt;2、添加线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191102-102624.html&quot;&gt;3、join功能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191103-092239.html&quot;&gt;4、Queue功能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191104-101112.html&quot;&gt;5、不一定有效率GIL&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-关于线程锁lock&quot;&gt;&lt;a href=&quot;#0x00-关于线程锁lock&quot; class=&quot;headerlink&quot; title=&quot;0x00 关于线程锁lock&quot;&gt;&lt;/a&gt;0x00 关于线程锁lock&lt;/h1&gt;&lt;p&gt;多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。&lt;/p&gt;
&lt;p&gt;而使用lock就可以在不同线程使用同一共享内存时，能够确保线程之间互不影响。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.teamssix.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Python Threading 学习笔记】5、不一定有效率GIL.md</title>
    <link href="https://www.teamssix.com/year/191104-101112.html"/>
    <id>https://www.teamssix.com/year/191104-101112.html</id>
    <published>2019-11-04T02:11:12.000Z</published>
    <updated>2019-11-04T02:16:15.383Z</updated>
    
    <content type="html"><![CDATA[<p>往期内容：</p><p><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p><a href="https://www.teamssix.com/year/191101-112015.html">2、添加线程</a></p><p><a href="https://www.teamssix.com/year/191102-102624.html">3、join功能</a></p><p><a href="https://www.teamssix.com/year/191103-092239.html">4、Queue功能</a></p><h1 id="0x00-关于GIL"><a href="#0x00-关于GIL" class="headerlink" title="0x00 关于GIL"></a>0x00 关于GIL</h1><p>GIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。</p><a id="more"></a><p>每个CPU在同一时间只能执行一个线程（在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。）</p><p>在Python多线程下，每个线程的执行方式如下：</p><p>1.获取GIL</p><p>2.执行代码直到sleep或者是python虚拟机将其挂起。</p><p>3.释放GIL</p><p>可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。</p><p>也就是说尽管Python支持多线程，但是因为GIL的存在，使得Python还是一次性只能处理一个东西，那是不是说Python中的多线程就完全没用了呢，当然不是的。</p><p>GIL往往只会影响到那些严重依赖CPU的程序，比如各种循环处理、计数等这种CPU密集型的程序；如果程序中大部分只会涉及到I/O，比如文件处理、网络爬虫等这种IO密集型的程序，那么多线程就能够有效的提高效率，因为在爬虫的时候大部分时间都在等待。</p><p>实际上，你完全可以放心的创建几千个Python线程， 现代操作系统运行这么多线程没有任何压力，没啥可担心的。</p><h1 id="0x01-测试GIL"><a href="#0x01-测试GIL" class="headerlink" title="0x01 测试GIL"></a>0x01 测试GIL</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(lists,q)</span>:</span></span><br><span class="line">   res = sum(lists)</span><br><span class="line">   q.put(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multithreading</span><span class="params">(lists)</span>:</span></span><br><span class="line">   q = Queue()</span><br><span class="line">   threads_list = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">      t = threading.Thread(target=job,args=(copy.copy(lists),q),name = <span class="string">'任务 %i'</span> % i)</span><br><span class="line">      t.start()</span><br><span class="line">      threads_list.append(t)</span><br><span class="line">   <span class="keyword">for</span> t <span class="keyword">in</span> threads_list:</span><br><span class="line">      t.join()</span><br><span class="line"></span><br><span class="line">   total = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">      total += q.get()</span><br><span class="line">   print(<span class="string">'使用线程运算结果:'</span>,total)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normal</span><span class="params">(lists)</span>:</span></span><br><span class="line">   total = sum(lists)</span><br><span class="line">   print(<span class="string">'不使用线程运算结果:'</span>,total)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">req_job</span><span class="params">(i)</span>:</span></span><br><span class="line">   requests.get(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">req_multithreading</span><span class="params">(req_lists)</span>:</span></span><br><span class="line">   threads_list = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">      t = threading.Thread(target=req_job,args=(req_lists[i],),name=<span class="string">'爬虫任务 %i'</span> % i)</span><br><span class="line">      t.start()</span><br><span class="line">      threads_list.append(t)</span><br><span class="line">   <span class="keyword">for</span> t <span class="keyword">in</span> threads_list:</span><br><span class="line">      t.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">req_normal</span><span class="params">(req_lists)</span>:</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> req_lists:</span><br><span class="line">      requests.get(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   lists = list(range(<span class="number">1000000</span>)) <span class="comment"># 完成一个较大的计算</span></span><br><span class="line">   req_lists = [<span class="string">'https://www.teamssix.com'</span>,<span class="string">'https://github.com/teamssix'</span>,<span class="string">'https://me.csdn.net/qq_37683287'</span>,<span class="string">'https://space.bilibili.com/148389186'</span>]</span><br><span class="line">   start_time = time.time()</span><br><span class="line">   multithreading(lists)</span><br><span class="line">   print(<span class="string">'计算使用线程耗时:'</span>, time.time() - start_time,<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">   start_time = time.time()</span><br><span class="line">   normal(lists * <span class="number">4</span>)</span><br><span class="line">   print(<span class="string">'计算不使用线程耗时:'</span>, time.time() - start_time,<span class="string">'\n'</span>)</span><br><span class="line">   start_time = time.time()</span><br><span class="line">   req_multithreading(req_lists)</span><br><span class="line">   print(<span class="string">'爬虫使用线程耗时:'</span>, time.time() - start_time)</span><br><span class="line">   start_time = time.time()</span><br><span class="line">   req_normal(req_lists)</span><br><span class="line">   print(<span class="string">'爬虫不使用线程耗时:'</span>, time.time() - start_time)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 5_GIL.py</span></span><br><span class="line">使用线程运算结果: 1999998000000</span><br><span class="line">计算使用线程耗时: 0.39594030380249023 </span><br><span class="line"></span><br><span class="line">不使用线程运算结果: 1999998000000</span><br><span class="line">计算不使用线程耗时: 0.3919515609741211</span><br><span class="line"></span><br><span class="line">爬虫使用线程耗时: 2.2410056591033936</span><br><span class="line">爬虫不使用线程耗时: 7.1159656047821045</span><br></pre></td></tr></table></figure><p>可以看到在计算程序的代码中不使用线程和使用线程的运算结果是相同的，说明不使用线程和使用线程的程序都进行了一样多次的运算，但是很明显可以看到计算的耗时并没有少很多，按照预期我们使用了4个线程，应该会快近4倍才对，这就是因为GIL在作怪。<br>与此同时，可以看到在使用request对一个url发起get请求的时候，使用线程比不使用线程快了3倍多，也进一步的反映出在使用Python进行爬虫的时候，多线程确实可以很大程度上提高效率，但是在进行密集计算任务的时候，多线程就显得很鸡肋了。</p><blockquote><p>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes" target="_blank" rel="noopener">https://github.com/teamssix/Python-Threading-study-notes</a><br>参考文章：<br>1、<a href="https://zhuanlan.zhihu.com/p/20953544" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20953544</a><br>2、<a href="https://morvanzhou.github.io/tutorials/python-basic/threading" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;往期内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/1901031-202253.html&quot;&gt;1、什么是多线程？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191101-112015.html&quot;&gt;2、添加线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191102-102624.html&quot;&gt;3、join功能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191103-092239.html&quot;&gt;4、Queue功能&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-关于GIL&quot;&gt;&lt;a href=&quot;#0x00-关于GIL&quot; class=&quot;headerlink&quot; title=&quot;0x00 关于GIL&quot;&gt;&lt;/a&gt;0x00 关于GIL&lt;/h1&gt;&lt;p&gt;GIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.teamssix.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Python Threading 学习笔记】4、Queue功能</title>
    <link href="https://www.teamssix.com/year/191103-092239.html"/>
    <id>https://www.teamssix.com/year/191103-092239.html</id>
    <published>2019-11-03T01:22:39.000Z</published>
    <updated>2019-11-03T01:46:44.674Z</updated>
    
    <content type="html"><![CDATA[<p>往期内容：</p><p><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p><a href="https://www.teamssix.com/year/191101-112015.html">2、添加线程</a></p><p><a href="https://www.teamssix.com/year/191102-102624.html">3、join功能</a></p><h1 id="0x00-关于Queue"><a href="#0x00-关于Queue" class="headerlink" title="0x00 关于Queue"></a>0x00 关于Queue</h1><p>queue模块实现了各种【多生产者-多消费者】队列，可用于在执行的多个线程之间安全的交换信息。</p><a id="more"></a><p><strong>queue的常用方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">q.size()：返回队列的正确大小。因为其他线程可能正在更新此队列，所以此方法的返回数字不可靠。</span><br><span class="line"></span><br><span class="line">q.empty()：如果队列为空，返回True，否则返回False。</span><br><span class="line"></span><br><span class="line">q.full()：如果队列已满，返回True，否则返回False。</span><br><span class="line"></span><br><span class="line">q.put(item,block,timeout)：将item放入队列。</span><br><span class="line">如果block设为True（默认值），调用者将被阻塞直到队列中出现可用的空闲位置为止。</span><br><span class="line">如果block设为False，队列满时此方法将引发Full异常。</span><br><span class="line"></span><br><span class="line">q.put_nowait(item):等价于q.put(item,False)</span><br><span class="line"></span><br><span class="line">q.get(block,timeout):从队列中删除一项，然后返回这个项。</span><br><span class="line">如果block设为True（默认值），调用者将阻塞，直到队列中出现可用的空闲为止。</span><br><span class="line">如果block设为False，队列为空时将引发Empty异常。</span><br><span class="line">timeout提供可选的超时值，单位为秒，如果超时，将引发Empty异常。</span><br><span class="line"></span><br><span class="line">q.get_nowait()：等价于get(0)</span><br><span class="line"></span><br><span class="line">q.task_done():在队列中数据的消费者用来指示对于项的处理已经结束。如果使用此方法，那么从队列中删除的每一项都应该调用一次。</span><br><span class="line"></span><br><span class="line">q.join()：阻塞直到队列中的所有项均被删除和处理为止。一旦为队列中的每一项都调用了一次q.task_done()方法，此方法将会直接返回。</span><br></pre></td></tr></table></figure><h1 id="0x01-本节代码实现功能"><a href="#0x01-本节代码实现功能" class="headerlink" title="0x01 本节代码实现功能"></a>0x01 本节代码实现功能</h1><p>将数据列表中的数据传入，使用三个线程处理，将结果保存在Queue中，线程执行完后，从Queue中获取存储的结果。</p><h1 id="0x02导入线程-队列的标准模块"><a href="#0x02导入线程-队列的标准模块" class="headerlink" title="0x02导入线程,队列的标准模块"></a>0x02导入线程,队列的标准模块</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br></pre></td></tr></table></figure><h1 id="0x03-定义一个被多线程调用的函数"><a href="#0x03-定义一个被多线程调用的函数" class="headerlink" title="0x03 定义一个被多线程调用的函数"></a>0x03 定义一个被多线程调用的函数</h1><p>该函数的参数是一个列表lists和一个队列q，其功能是对lists列表中的元素除2取整，之后利用q.put()将结果保存在队列q中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(lists,q)</span>:</span> <span class="comment"># 被调用函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">        lists[i] = lists[i]//<span class="number">2</span> <span class="comment"># lists元素除2取整</span></span><br><span class="line">    q.put(lists) <span class="comment"># 多线程调用的函数不能用return返回值</span></span><br></pre></td></tr></table></figure><h1 id="0x04-定义一个多线程函数"><a href="#0x04-定义一个多线程函数" class="headerlink" title="0x04 定义一个多线程函数"></a>0x04 定义一个多线程函数</h1><p>在多线程函数中定义一个Queue用来保存返回值代替return，同时定义一个多线程列表，初始化一个多维数据列表用来传入上面的job()函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multithreading</span><span class="params">()</span>:</span> <span class="comment"># 调用多线程的函数</span></span><br><span class="line">    q = Queue() <span class="comment"># 存放job()函数的返回值</span></span><br><span class="line">    thread_list = []</span><br><span class="line">    data = [[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br></pre></td></tr></table></figure><p>定义三个线程，启动线程并分别join三个线程到主线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment"># 定义三个线程</span></span><br><span class="line">    t = threading.Thread(target=job,args=(data[i],q))</span><br><span class="line">    t.start()</span><br><span class="line">    thread_list.append(t) <span class="comment"># 将线程添加到thread_list列表中 </span></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> thread_list:</span><br><span class="line">    thread.join()</span><br></pre></td></tr></table></figure><p>定义一个空的result_list列表，将队列q中的数据添加到列表中并print</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result_list = []</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment"># 循环三次</span></span><br><span class="line">    result_list.append(q.get())</span><br><span class="line">    print(result_list[j])</span><br></pre></td></tr></table></figure><h1 id="0x05-完整的代码"><a href="#0x05-完整的代码" class="headerlink" title="0x05 完整的代码"></a>0x05 完整的代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(lists,q)</span>:</span> <span class="comment"># 被调用函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">        lists[i] = lists[i]//<span class="number">2</span> <span class="comment"># lists元素除2取整</span></span><br><span class="line">    q.put(lists) <span class="comment"># 多线程调用的函数不能用return返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multithreading</span><span class="params">()</span>:</span> <span class="comment"># 调用多线程的函数</span></span><br><span class="line">    q = Queue() <span class="comment"># 存放job()函数的返回值</span></span><br><span class="line">    thread_list = []</span><br><span class="line">    data = [[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment"># 定义三个线程</span></span><br><span class="line">        t = threading.Thread(target=job,args=(data[i],q))</span><br><span class="line">        t.start()</span><br><span class="line">        thread_list.append(t) <span class="comment"># 将线程添加到thread_list列表中</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> thread_list:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment"># 循环三次</span></span><br><span class="line">        result_list.append(q.get())</span><br><span class="line">        print(result_list[j])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    multithreading()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 4_queue.py</span></span><br><span class="line">[0]</span><br><span class="line">[1, 1]</span><br><span class="line">[2, 2, 3]</span><br></pre></td></tr></table></figure><blockquote><p>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes" target="_blank" rel="noopener">https://github.com/teamssix/Python-Threading-study-notes</a><br>参考文章：<br>1、<a href="https://segmentfault.com/a/1190000016330288" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016330288</a><br>2、<a href="https://morvanzhou.github.io/tutorials/python-basic/threading" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;往期内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/1901031-202253.html&quot;&gt;1、什么是多线程？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191101-112015.html&quot;&gt;2、添加线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191102-102624.html&quot;&gt;3、join功能&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-关于Queue&quot;&gt;&lt;a href=&quot;#0x00-关于Queue&quot; class=&quot;headerlink&quot; title=&quot;0x00 关于Queue&quot;&gt;&lt;/a&gt;0x00 关于Queue&lt;/h1&gt;&lt;p&gt;queue模块实现了各种【多生产者-多消费者】队列，可用于在执行的多个线程之间安全的交换信息。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.teamssix.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Python Threading 学习笔记】3、join功能</title>
    <link href="https://www.teamssix.com/year/191102-102624.html"/>
    <id>https://www.teamssix.com/year/191102-102624.html</id>
    <published>2019-11-02T02:26:24.000Z</published>
    <updated>2019-11-02T12:21:06.105Z</updated>
    
    <content type="html"><![CDATA[<p>往期内容：</p><p><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p><a href="https://www.teamssix.com/year/191101-112015.html">2、添加线程</a></p><h1 id="0x00-不使用join-的结果"><a href="#0x00-不使用join-的结果" class="headerlink" title="0x00 不使用join()的结果"></a>0x00 不使用join()的结果</h1><p>首先在上一节的示例基础上进行简单修改</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_jobs</span><span class="params">()</span>:</span>  <span class="comment"># 定义要添加的线程</span></span><br><span class="line">    print(<span class="string">'任务1开始\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    print(<span class="string">'任务1结束\n'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thread = threading.Thread(target=thread_jobs,name=<span class="string">'任务1'</span>)  <span class="comment"># 定义线程</span></span><br><span class="line">    thread.start()  <span class="comment"># 开始线程</span></span><br><span class="line">    print(<span class="string">'所有任务已完成\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>预计输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">任务1结束</span><br><span class="line">所有任务已完成</span><br></pre></td></tr></table></figure><p>实际输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">所有任务已完成</span><br><span class="line">任务1结束</span><br></pre></td></tr></table></figure><p>可以看到在线程还没有结束的时候，程序就开始运行之后的代码了，也就是说线程和其他部分的程序都是同步进行的，如果想要避免这种情况，想要程序按照代码顺序执行的话，就需要用到join功能。</p><h1 id="0x01-使用join-的结果"><a href="#0x01-使用join-的结果" class="headerlink" title="0x01 使用join()的结果"></a>0x01 使用join()的结果</h1><p>在源代码thread.start()下加入thread.join()即可，原来代码的main函数就变成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thread = threading.Thread(target=thread_jobs,name=<span class="string">'任务1'</span>)  <span class="comment"># 定义线程</span></span><br><span class="line">    thread.start()  <span class="comment"># 开始线程</span></span><br><span class="line">    thread.join() <span class="comment">#加入join功能</span></span><br><span class="line">    print(<span class="string">'所有任务已完成\n'</span>)</span><br></pre></td></tr></table></figure><p>这里就表示必须要等到任务1这个线程结束后，才能执行thread.join()之后的代码，代码运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">任务1结束</span><br><span class="line">所有任务已完成</span><br></pre></td></tr></table></figure><p>使用join控制多个线程的执行顺序很关键。</p><h1 id="0x02-添加第2个线程"><a href="#0x02-添加第2个线程" class="headerlink" title="0x02 添加第2个线程"></a>0x02 添加第2个线程</h1><p>这时如果我们加入第2个线程，但是不加入join功能，看看又是什么样，第2个线程的任务量较小，因此比第1个线程会更快执行，加入的第2个线程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_jobs2</span><span class="params">()</span>:</span> <span class="comment"># 定义第2个线程</span></span><br><span class="line">    print(<span class="string">'任务2开始\n'</span>)</span><br><span class="line">    print(<span class="string">'任务2结束\n'</span>)</span><br></pre></td></tr></table></figure><p>输出的一种结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">任务2开始</span><br><span class="line">任务2结束</span><br><span class="line">所有任务已完成</span><br><span class="line">任务1结束</span><br></pre></td></tr></table></figure><p>注意这个时候任务1和任务2都没有添加join，也就是说输出的内容是什么完全看谁执行的快，谁先执行完谁就先输出，因此这里的输出结果并不唯一，这种杂乱的输出方式是不能接收的，所以需要使用join来控制。</p><h1 id="0x03-在不同位置使用join-的结果"><a href="#0x03-在不同位置使用join-的结果" class="headerlink" title="0x03 在不同位置使用join()的结果"></a>0x03 在不同位置使用join()的结果</h1><p>如果在任务2开始前只对任务1加入join功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread.start()  <span class="comment"># 开始线程1</span></span><br><span class="line">thread.join()  <span class="comment"># 对任务1加入join功能</span></span><br><span class="line">thread2.start() <span class="comment"># 开始线程2</span></span><br><span class="line">print(<span class="string">'所有任务已完成\n'</span>)</span><br></pre></td></tr></table></figure><p>其输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">任务1结束</span><br><span class="line">任务2开始</span><br><span class="line">任务2结束</span><br><span class="line">所有任务已完成</span><br></pre></td></tr></table></figure><p>可以看到程序会先执行任务1再执行接下来的操作，如果在任务2开始后只对任务1加入join功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread.start()  <span class="comment"># 开始线程1</span></span><br><span class="line">thread2.start() <span class="comment"># 开始线程2</span></span><br><span class="line">thread.join()  <span class="comment"># 对任务1加入join功能</span></span><br><span class="line">print(<span class="string">'所有任务已完成\n'</span>)</span><br></pre></td></tr></table></figure><p>其输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">任务2开始</span><br><span class="line">任务2结束</span><br><span class="line">任务1结束</span><br><span class="line">所有任务已完成</span><br></pre></td></tr></table></figure><p>任务1先于任务2启动，但由于任务2的处理时间较短，因此先于任务1完成，而由于任务1加入了join，因此“所有任务已完成”也在任务1完成后再显示。</p><h1 id="0x04-最终代码及输出结果"><a href="#0x04-最终代码及输出结果" class="headerlink" title="0x04 最终代码及输出结果"></a>0x04 最终代码及输出结果</h1><p>如果只对任务2加入join，同样输出结果就是要先等任务2执行完再执行其他程序，但是为了避免不必要的麻烦，推荐下面这种1221的V型排布，毕竟如果每个线程start()后就加入其join()，那就和单线程无异了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread.start()  <span class="comment"># 开始线程1</span></span><br><span class="line">thread2.start() <span class="comment"># 开始线程2</span></span><br><span class="line">thread2.join()  <span class="comment"># 对任务2加入join功能</span></span><br><span class="line">thread.join()  <span class="comment"># 对任务1加入join功能</span></span><br></pre></td></tr></table></figure><p>最终完整代码及输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_jobs</span><span class="params">()</span>:</span>  <span class="comment"># 定义第1个线程</span></span><br><span class="line">    print(<span class="string">'任务1开始\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    print(<span class="string">'任务1结束\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_jobs2</span><span class="params">()</span>:</span> <span class="comment"># 定义第2个线程</span></span><br><span class="line">    print(<span class="string">'任务2开始\n'</span>)</span><br><span class="line">    print(<span class="string">'任务2结束\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thread = threading.Thread(target=thread_jobs,name=<span class="string">'任务1'</span>)  <span class="comment"># 定义线程1</span></span><br><span class="line">    thread2 = threading.Thread(target=thread_jobs2, name=<span class="string">'任务2'</span>)  <span class="comment"># 定义线程2</span></span><br><span class="line">    thread.start()  <span class="comment"># 开始线程1</span></span><br><span class="line">    thread2.start() <span class="comment"># 开始线程2</span></span><br><span class="line">    thread2.join()  <span class="comment"># 对任务2加入join功能</span></span><br><span class="line">    thread.join()  <span class="comment"># 对任务1加入join功能</span></span><br><span class="line">    print(<span class="string">'所有任务已完成\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 3_join.py</span></span><br><span class="line">任务1开始</span><br><span class="line">任务2开始</span><br><span class="line">任务2结束</span><br><span class="line">任务1结束</span><br><span class="line">所有任务已完成</span><br></pre></td></tr></table></figure><blockquote><p>参考文章：<a href="https://morvanzhou.github.io/tutorials/python-basic/threading" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading</a><br>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes" target="_blank" rel="noopener">https://github.com/teamssix/Python-Threading-study-notes</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;往期内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/1901031-202253.html&quot;&gt;1、什么是多线程？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.teamssix.com/year/191101-112015.html&quot;&gt;2、添加线程&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-不使用join-的结果&quot;&gt;&lt;a href=&quot;#0x00-不使用join-的结果&quot; class=&quot;headerlink&quot; title=&quot;0x00 不使用join()的结果&quot;&gt;&lt;/a&gt;0x00 不使用join()的结果&lt;/h1&gt;&lt;p&gt;首先在上一节的示例基础上进行简单修改&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.teamssix.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Python Threading 学习笔记】2、添加线程</title>
    <link href="https://www.teamssix.com/year/191101-112015.html"/>
    <id>https://www.teamssix.com/year/191101-112015.html</id>
    <published>2019-11-01T03:20:15.000Z</published>
    <updated>2019-11-02T12:21:46.033Z</updated>
    
    <content type="html"><![CDATA[<p>往期内容：<br><a href="https://www.teamssix.com/year/1901031-202253.html">1、什么是多线程？</a></p><p>这一节主要学习Threading模块的一些基本操作，如获取线程数，添加线程等。</p><a id="more"></a><p>首先导入Threading模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br></pre></td></tr></table></figure><p>获取已激活的线程数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.active_count()</span><br></pre></td></tr></table></figure><p>查看所有线程信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.enumerate()</span><br></pre></td></tr></table></figure><p>查看现在正在运行的线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threading.current_thread()</span><br></pre></td></tr></table></figure><p>添加线程，threading.Thread()接收参数target代表这个线程要完成的任务，需自行定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_jobs</span><span class="params">()</span>:</span>  <span class="comment"># 定义要添加的线程</span></span><br><span class="line">    print(<span class="string">'已激活的线程数： %s'</span> % threading.active_count())</span><br><span class="line">    print(<span class="string">'所有线程信息： %s'</span> % threading.enumerate())</span><br><span class="line">    print(<span class="string">'正在运行的线程： %s'</span> % threading.current_thread())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thread = threading.Thread(target=thread_jobs, )  <span class="comment"># 定义线程</span></span><br><span class="line">    thread.start()  <span class="comment"># 开始线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 2_add_thread.py</span></span><br><span class="line">已激活的线程数： 2</span><br><span class="line">所有线程信息： [&lt;_MainThread(MainThread, stopped 16800)&gt;, &lt;Thread(Thread-1, started 20512)&gt;]</span><br><span class="line">正在运行的线程 &lt;Thread(Thread-1, started 20512)&gt;</span><br></pre></td></tr></table></figure><blockquote><p>代码项目地址：<a href="https://github.com/teamssix/Python-Threading-study-notes" target="_blank" rel="noopener">https://github.com/teamssix/Python-Threading-study-notes</a><br>参考文章：<a href="https://morvanzhou.github.io/tutorials/python-basic/threading" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;往期内容：&lt;br&gt;&lt;a href=&quot;https://www.teamssix.com/year/1901031-202253.html&quot;&gt;1、什么是多线程？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这一节主要学习Threading模块的一些基本操作，如获取线程数，添加线程等。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.teamssix.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Python Threading 学习笔记】1、什么是多线程？</title>
    <link href="https://www.teamssix.com/year/1901031-202253.html"/>
    <id>https://www.teamssix.com/year/1901031-202253.html</id>
    <published>2019-10-31T12:22:53.000Z</published>
    <updated>2019-11-02T12:21:38.866Z</updated>
    
    <content type="html"><![CDATA[<p>多线程类似于同时执行多个不同程序，比如一个很大的数据，直接运行的话可能需要10秒钟才能运行完。</p><a id="more"></a><p>但如果使用Threading或者说使用多线程，我们把数据分成5段，每一段数据都放到一个单独的线程里面运算，所有线程同时开始。</p><p>这就好比原本一个工作只有一个人在做，但现在有了5个人同时在做，很明显可以大大的提高效率，节省时间。</p><p>如果平时有用过IDM下载东西的小伙伴，在下载文件的时候可以打开显示细节，就可以看到多个线程同时下载，传输速度基本能达到本地带宽的最高速度，下图可以很直观的看到多个线程同时下载的过程。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Threading1.gif" alt></p><blockquote><p>参考文章：<a href="https://morvanzhou.github.io/tutorials/python-basic/threading" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/python-basic/threading</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程类似于同时执行多个不同程序，比如一个很大的数据，直接运行的话可能需要10秒钟才能运行完。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
      <category term="多线程" scheme="https://www.teamssix.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【续】CFS三层靶机中的Flag位置及其获取</title>
    <link href="https://www.teamssix.com/year/191021-213828.html"/>
    <id>https://www.teamssix.com/year/191021-213828.html</id>
    <published>2019-10-21T13:38:28.000Z</published>
    <updated>2019-11-02T12:22:53.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近写了一篇《CFS三层靶机搭建及其内网渗透》的文章，里面满满的干货，本篇文章需要结合《CFS三层靶机搭建及其内网渗透》一起看，这篇文章可以在本文底部找到阅读链接。</p><a id="more"></a><h1 id="0x01-Target1"><a href="#0x01-Target1" class="headerlink" title="0x01 Target1"></a>0x01 Target1</h1><p>1、系统根目录下</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag1.png" alt></p><p>2、网站根目录下</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag2.png" alt></p><p>3、网站robots.txt文件中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag3.png" alt></p><h1 id="0x02-Target2"><a href="#0x02-Target2" class="headerlink" title="0x02 Target2"></a>0x02 Target2</h1><p>1、系统根目录下</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag4.png" alt></p><p>2、日志文件中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag5.png" alt></p><p>3、passwd文件中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag6.png" alt></p><p>4、crontab文件中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag7.png" alt></p><p>5、网站根目录下</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag8.png" alt></p><p>6、管理后台中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag9.png" alt></p><h1 id="0x03-Target3"><a href="#0x03-Target3" class="headerlink" title="0x03 Target3"></a>0x03 Target3</h1><p>1、通过meterpreter上传Everything工具并安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; upload ./Everything_64.exe C:</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag10.png" alt></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag11.png" alt></p><p>2、利用Everything，直接搜索flag文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag12.png" alt></p><p>3、找到两处flag，继续找寻发现计划任务中存在第三处flag</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag13.png" alt></p><p>4、最后一处在事件日志的注册表中被找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Eventlog</span><br></pre></td></tr></table></figure><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/flag14.png" alt></p><blockquote><p>《CFS三层靶机搭建及其内网渗透》文章地址：<br>1、首发地址：<a href="https://www.anquanke.com/post/id/187908" target="_blank" rel="noopener">https://www.anquanke.com/post/id/187908</a><br>2、博客地址：<a href="https://www.teamssix.com/year/191021-211425.html">https://www.teamssix.com/year/191021-211425.html</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近写了一篇《CFS三层靶机搭建及其内网渗透》的文章，里面满满的干货，本篇文章需要结合《CFS三层靶机搭建及其内网渗透》一起看，这篇文章可以在本文底部找到阅读链接。&lt;/p&gt;
    
    </summary>
    
      <category term="实例演示" scheme="https://www.teamssix.com/categories/%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA/"/>
    
    
      <category term="内网渗透" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="CFS" scheme="https://www.teamssix.com/tags/CFS/"/>
    
      <category term="比赛" scheme="https://www.teamssix.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
</feed>
